<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JVM,类加载,垃圾回收,">










<meta name="description" content="转载自：https://github.com/crossoverJie/Java-Interview 1. Java 运行时的内存划分 1.1 程序计数器记录当前线程所执行的字节码行号，用于获取下一条执行的字节码。 当多线程运行时，每个线程切换后需要知道上一次所运行的状态、位置。由此也可以看出程序计数器是每个线程私有的。 1.2 虚拟机栈虚拟机栈是有一个一个的栈帧组成，栈帧是在每一个方法调用时产生">
<meta name="keywords" content="JVM,类加载,垃圾回收">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM学习总结">
<meta property="og:url" content="http://pibigstar.com/2019/08/21/JVM学习总结/index.html">
<meta property="og:site_name" content="派大星的博客">
<meta property="og:description" content="转载自：https://github.com/crossoverJie/Java-Interview 1. Java 运行时的内存划分 1.1 程序计数器记录当前线程所执行的字节码行号，用于获取下一条执行的字节码。 当多线程运行时，每个线程切换后需要知道上一次所运行的状态、位置。由此也可以看出程序计数器是每个线程私有的。 1.2 虚拟机栈虚拟机栈是有一个一个的栈帧组成，栈帧是在每一个方法调用时产生">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://img-blog.csdn.net/20180719085543943?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bm1veGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180719085731728?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bm1veGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180719085952968?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bm1veGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180719090050134?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bm1veGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180719090152905?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bm1veGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180719090233139?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bm1veGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180719090857515?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bm1veGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180719091249178?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bm1veGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:updated_time" content="2019-09-30T03:12:59.252Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM学习总结">
<meta name="twitter:description" content="转载自：https://github.com/crossoverJie/Java-Interview 1. Java 运行时的内存划分 1.1 程序计数器记录当前线程所执行的字节码行号，用于获取下一条执行的字节码。 当多线程运行时，每个线程切换后需要知道上一次所运行的状态、位置。由此也可以看出程序计数器是每个线程私有的。 1.2 虚拟机栈虚拟机栈是有一个一个的栈帧组成，栈帧是在每一个方法调用时产生">
<meta name="twitter:image" content="https://img-blog.csdn.net/20180719085543943?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bm1veGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://pibigstar.com/2019/08/21/JVM学习总结/">





  <title>JVM学习总结 | 派大星的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">派大星的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">很多事情不是会了才能做，而是做了才能学会</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pibigstar.com/2019/08/21/JVM学习总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="派大星">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/qq.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="派大星的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">JVM学习总结</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-21T09:09:04+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>转载自：<a href="https://github.com/crossoverJie/Java-Interview" target="_blank" rel="noopener">https://github.com/crossoverJie/Java-Interview</a></p>
<h1 id="1-Java-运行时的内存划分"><a href="#1-Java-运行时的内存划分" class="headerlink" title="1. Java 运行时的内存划分"></a>1. Java 运行时的内存划分</h1><p><img src="https://img-blog.csdn.net/20180719085543943?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bm1veGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<h2 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h2><p>记录当前线程所执行的字节码行号，用于获取下一条执行的字节码。</p>
<p>当多线程运行时，每个线程切换后需要知道上一次所运行的状态、位置。由此也可以看出程序计数器是每个线程私有的。</p>
<h2 id="1-2-虚拟机栈"><a href="#1-2-虚拟机栈" class="headerlink" title="1.2 虚拟机栈"></a>1.2 虚拟机栈</h2><p>虚拟机栈是有一个一个的栈帧组成，栈帧是在每一个方法调用时产生的。</p>
<p>每一个栈帧由局部变量区、操作数栈等组成。每创建一个栈帧压栈，当一个方法执行完毕之后则出栈。</p>
<p>如果出现方法递归调用出现死循环的话就会造成栈帧过多，最终会抛出 stackoverflow 异常。<br>这块内存区域也是线程私有的。</p>
<h2 id="1-3-Java-堆"><a href="#1-3-Java-堆" class="headerlink" title="1.3 Java 堆"></a>1.3 Java 堆</h2><p>Java 堆是整个虚拟机所管理的最大内存区域，所有的对象创建都是在这个区域进行内存分配。</p>
<p>这块区域也是垃圾回收器重点管理的区域，由于大多数垃圾回收器都采用分代回收算法，所有堆内存也分为 新生代、老年代，可以方便垃圾的准确回收。</p>
<p><strong>这块内存属于线程共享区域。</strong></p>
<h2 id="1-4-方法区"><a href="#1-4-方法区" class="headerlink" title="1.4 方法区"></a>1.4 方法区</h2><p>方法区主要用于存放已经被虚拟机加载的类信息，如常量，静态变量。 这块区域也被称为永久代。</p>
<h2 id="1-5-运行时常量池"><a href="#1-5-运行时常量池" class="headerlink" title="1.5 运行时常量池"></a>1.5 运行时常量池</h2><p>运行时常量池是方法区的一部分，其中存放了一些符号引用。当 new 一个对象时，会检查这个区域是否有这个符号的引用。</p>
<h1 id="2-类的加载机制"><a href="#2-类的加载机制" class="headerlink" title="2. 类的加载机制"></a>2. 类的加载机制</h1><h2 id="2-1-双亲委派模型"><a href="#2-1-双亲委派模型" class="headerlink" title="2.1 双亲委派模型"></a>2.1 双亲委派模型</h2><p>模型如下图：</p>
<p><img src="https://img-blog.csdn.net/20180719085731728?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bm1veGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p>双亲委派模型中除了启动类加载器之外其余都需要有自己的父类加载器</p>
<p>当一个类收到了类加载请求时: 自己不会首先加载，而是委派给父加载器进行加载，每个层次的加载器都是这样。</p>
<p>所以最终每个加载请求都会经过启动类加载器。只有当父类加载返回不能加载时子加载器才会进行加载。</p>
<p>双亲委派的好处 : 由于每个类加载都会经过最顶层的启动类加载器，比如 java.lang.Object这样的类在各个类加载器下都是同一个类(只有当两个类是由同一个类加载器加载的才有意义，这两个类才相等。)</p>
<p>如果没有双亲委派模型，由各个类加载器自行加载的话。当用户自己编写了一个 java.lang.Object类，那样系统中就会出现多个 Object，这样 Java 程序中最基本的行为都无法保证，程序会变的非常混乱。</p>
<h1 id="3-垃圾回收"><a href="#3-垃圾回收" class="headerlink" title="3. 垃圾回收"></a>3. 垃圾回收</h1><blockquote>
<p>垃圾回收主要思考三件事情:</p>
</blockquote>
<ul>
<li>哪种内存需要回收？</li>
<li>什么时候回收？</li>
<li>怎么回收？</li>
</ul>
<h2 id="3-1-对象是否存活"><a href="#3-1-对象是否存活" class="headerlink" title="3.1 对象是否存活"></a>3.1 对象是否存活</h2><p><strong>引用计数法</strong></p>
<p>这是一种非常简单易理解的回收算法。每当有一个地方引用一个对象的时候则在引用计数器上 +1，当失效的时候就 -1，无论什么时候计数器为 0 的时候则认为该对象死亡可以回收了。</p>
<p>这种算法虽然简单高效，但是却无法解决循环引用的问题，因此 Java 虚拟机并没有采用这种算法。</p>
<p><strong>可达性分析算法</strong></p>
<p>主流的语言其实都是采用可达性分析算法:</p>
<p>可达性算法是通过一个称为 GC Roots 的对象向下搜索，整个搜索路径就称为引用链，当一个对象到 GC Roots 没有任何引用链 JVM 就认为该对象是可以被回收的。</p>
<p><img src="https://img-blog.csdn.net/20180719085952968?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bm1veGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p>如图:Object1、2、3、4 都是存活的对象，而 Object5、6、7都是可回收对象。</p>
<p>可以用作 GC-Roots 的对象有:</p>
<ul>
<li>方法区中静态变量所引用的对象。</li>
<li>虚拟机栈中所引用的对象。</li>
</ul>
<h2 id="3-2-垃圾回收算法"><a href="#3-2-垃圾回收算法" class="headerlink" title="3.2 垃圾回收算法"></a>3.2 垃圾回收算法</h2><p><strong>标记-清除算法</strong></p>
<p>标记清除算法分为两个步骤，标记和清除。 首先将需要回收的对象标记起来，然后统一清除。但是存在两个主要的问题:</p>
<p>标记和清除的效率都不高。<br>清除之后容易出现不连续内存，当需要分配一个较大内存时就不得不需要进行一次垃圾回收。<br>标记清除过程如下:</p>
<p><img src="https://img-blog.csdn.net/20180719090050134?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bm1veGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p><strong>复制算法</strong></p>
<p>复制算法是将内存划分为两块大小相等的区域，每次使用时都只用其中一块区域，当发生垃圾回收时会将存活的对象全部复制到未使用的区域，然后对之前的区域进行全部回收。</p>
<p>这样简单高效，而且还不存在标记清除算法中的内存碎片问题，但就是有点浪费内存。</p>
<p>在新生代会使用该算法。<br>新生代中分为一个 Eden 区和两个 Survivor 区。通常两个区域的比例是 8:1:1 ，使用时会用到 Eden 区和其中一个 Survivor 区。当发生回收时则会将还存活的对象从 Eden ，Survivor 区拷贝到另一个 Survivor 区，当该区域内存也不足时则会使用分配担保利用老年代来存放内存。</p>
<p>复制算法过程：</p>
<p><img src="https://img-blog.csdn.net/20180719090152905?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bm1veGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p><strong>标记整理算法</strong></p>
<p>复制算法如果在存活对象较多时效率明显会降低，特别是在老年代中并没有多余的内存区域可以提供内存担保。</p>
<p>所以老年代中使用的时候分配整理算法，它的原理和分配清除算法类似，只是最后一步的清除改为了将存活对象全部移动到一端，然后再将边界之外的内存全部回收。</p>
<p><img src="https://img-blog.csdn.net/20180719090233139?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bm1veGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p><strong>分代回收算法</strong></p>
<p>现代多数的商用 JVM 的垃圾收集器都是采用的分代回收算法，和之前所提到的算法并没有新的内容。</p>
<p>只是将 Java 堆分为了新生代和老年代。由于新生代中存活对象较少，所以采用复制算法，简单高效。</p>
<p>而老年代中对象较多，并且没有可以担保的内存区域，所以一般采用标记清除或者是标记整理算法。</p>
<h1 id="4-OOM-分析"><a href="#4-OOM-分析" class="headerlink" title="4. OOM 分析"></a>4. OOM 分析</h1><h2 id="4-1-Java-堆内存溢出"><a href="#4-1-Java-堆内存溢出" class="headerlink" title="4.1 Java 堆内存溢出"></a>4.1 Java 堆内存溢出</h2><p>在 Java 堆中只要不断的创建对象，并且 GC-Roots 到对象之间存在引用链，这样 JVM 就不会回收对象。</p>
<p>只要将-Xms(最小堆),-Xmx(最大堆) 设置为一样禁止自动扩展堆内存。</p>
<p>当使用一个 while(true) 循环来不断创建对象就会发生 OutOfMemory，还可以使用 -XX:+HeapDumpOutofMemoryErorr 当发生 OOM 时会自动 dump 堆栈到文件中。</p>
<p>伪代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        list.add(<span class="string">"1"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当出现 OOM 时可以通过工具来分析 GC-Roots 引用链 ，查看对象和 GC-Roots 是如何进行关联的，是否存在对象的生命周期过长，或者是这些对象确实改存在的，那就要考虑将堆内存调大了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:<span class="number">3210</span>)</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:<span class="number">3181</span>)</span><br><span class="line">	at java.util.ArrayList.grow(ArrayList.java:<span class="number">261</span>)</span><br><span class="line">	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:<span class="number">235</span>)</span><br><span class="line">	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:<span class="number">227</span>)</span><br><span class="line">	at java.util.ArrayList.add(ArrayList.java:<span class="number">458</span>)</span><br><span class="line">	at com.crossoverjie.oom.HeapOOM.main(HeapOOM.java:<span class="number">18</span>)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:<span class="number">147</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>java.lang.OutOfMemoryError: Java heap space表示堆内存溢出。</p>
<h2 id="4-2-MetaSpace-元数据-内存溢出"><a href="#4-2-MetaSpace-元数据-内存溢出" class="headerlink" title="4.2 MetaSpace (元数据) 内存溢出"></a>4.2 MetaSpace (元数据) 内存溢出</h2><blockquote>
<p>JDK8 中将永久代移除，使用 MetaSpace 来保存类加载之后的类信息，字符串常量池也被移动到 Java 堆。</p>
</blockquote>
<p><code>PermSize</code> 和 <code>MaxPermSize</code> 已经不能使用了，在 JDK8 中配置这两个参数将会发出警告。</p>
<p>JDK 8 中将类信息移到到了本地堆内存(Native Heap)中，将原有的永久代移动到了本地堆中成为 MetaSpace ,如果不指定该区域的大小，JVM 将会动态的调整。</p>
<p>可以使用<code>-XX:MaxMetaspaceSize=10M</code> 来限制最大元数据。这样当不停的创建类时将会占满该区域并出现 OOM。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        Enhancer  enhancer = <span class="keyword">new</span> Enhancer() ;</span><br><span class="line">        enhancer.setSuperclass(HeapOOM.class);</span><br><span class="line">        enhancer.setUseCache(<span class="keyword">false</span>) ;</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> methodProxy.invoke(o,objects) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        enhancer.create() ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 cglib 不停的创建新类，最终会抛出:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.reflect.InvocationTargetException</span><br><span class="line">	at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">	at net.sf.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:<span class="number">459</span>)</span><br><span class="line">	at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:<span class="number">336</span>)</span><br><span class="line">	... <span class="number">11</span> more</span><br><span class="line">Caused by: java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">	at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">763</span>)</span><br><span class="line">	... <span class="number">16</span> more</span><br></pre></td></tr></table></figure>

<p>注意：这里的 OOM 伴随的是 java.lang.OutOfMemoryError: Metaspace 也就是元数据溢出。</p>
<h1 id="5-对象的创建与内存分配"><a href="#5-对象的创建与内存分配" class="headerlink" title="5. 对象的创建与内存分配"></a>5. 对象的创建与内存分配</h1><h2 id="5-1-创建对象"><a href="#5-1-创建对象" class="headerlink" title="5.1 创建对象"></a>5.1 创建对象</h2><p>当 JVM 收到一个 new 指令时，会检查指令中的参数在常量池是否有这个符号的引用，还会检查该类是否已经被加载过了，如果没有的话则要进行一次类加载。</p>
<p>接着就是分配内存了，通常有两种方式：</p>
<ul>
<li>指针碰撞</li>
<li>空闲列表</li>
</ul>
<p>使用指针碰撞的前提是堆内存是<strong>完全工整</strong>的，用过的内存和没用的内存各在一边每次分配的时候只需要将指针向空闲内存一方移动一段和内存大小相等区域即可。</p>
<p>当堆中已经使用的内存和未使用的内存互相交错时，指针碰撞的方式就行不通了，这时就需要采用空闲列表的方式。虚拟机会维护一个空闲的列表，用于记录哪些内存是可以进行分配的，分配时直接从可用内存中直接分配即可。</p>
<p>堆中的内存是否工整是有<strong>垃圾收集器</strong>来决定的，如果带有压缩功能的垃圾收集器就是采用指针碰撞的方式来进行内存分配的。</p>
<p>分配内存时也会出现并发问题:</p>
<p>这样可以在创建对象的时候使用 CAS 这样的乐观锁来保证。</p>
<p>也可以将内存分配安排在每个线程独有的空间进行，每个线程首先在堆内存中分配一小块内存，称为本地分配缓存(TLAB : Thread Local Allocation Buffer)。</p>
<p>分配内存时，只需要在自己的分配缓存中分配即可，由于这个内存区域是线程私有的，所以不会出现并发问题。</p>
<p>可以使用 -XX:+/-UseTLAB 参数来设定 JVM 是否开启 TLAB 。</p>
<p>内存分配之后需要对该对象进行设置，如对象头。对象头的一些应用可以查看 Synchronize 关键字原理。</p>
<h4 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h4><p>一个对象被创建之后自然是为了使用，在 Java 中是通过栈来引用堆内存中的对象来进行操作的。</p>
<p>对于我们常用的 HotSpot 虚拟机来说，这样引用关系是通过直接指针来关联的。</p>
<p>如图:</p>
<p><img src="https://img-blog.csdn.net/20180719090857515?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bm1veGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p>这样的好处就是：在 Java 里进行频繁的对象访问可以提升访问速度(相对于使用句柄池来说)。</p>
<h2 id="5-2-内存分配"><a href="#5-2-内存分配" class="headerlink" title="5.2 内存分配"></a>5.2 内存分配</h2><p>####Eden 区分配</p>
<p>简单的来说对象都是在堆内存中分配的，往细一点看则是优先在 Eden 区分配。</p>
<p>这里就涉及到堆内存的划分了，为了方便垃圾回收，JVM 将堆内存分为新生代和老年代。</p>
<p>而新生代中又会划分为 Eden 区，<code>from Survivor、to Survivor</code>区。</p>
<p>其中 Eden 和 Survivor 区的比例默认是<code>8:1:1</code>，当然也支持参数调整 <code>-XX:SurvivorRatio=8</code>。</p>
<p>当在 Eden 区分配内存不足时，则会发生 minorGC ，由于 Java 对象多数是朝生夕灭的特性，所以 minorGC 通常会比较频繁，效率也比较高。</p>
<p>当发生 minorGC 时，JVM 会根据<code>复制算法</code>将存活的对象拷贝到另一个未使用的 Survivor 区，如果 Survivor 区内存不足时，则会使用分配担保策略将对象移动到老年代中。</p>
<p>谈到 minorGC 时，就不得不提到 fullGC(majorGC) ，这是指发生在老年代的 GC ，不论是效率还是速度都比 minorGC 慢的多，回收时还会发生 stop the world 使程序发生停顿，所以应当尽量避免发生 fullGC 。</p>
<h4 id="老年代分配"><a href="#老年代分配" class="headerlink" title="老年代分配"></a>老年代分配</h4><p>也有一些情况会导致对象直接在老年代分配，比如当分配一个大对象时(大的数组，很长的字符串)，由于 Eden 区没有足够大的连续空间来分配时，会导致提前触发一次 GC，所以尽量别频繁的创建大对象。</p>
<p>因此 JVM 会根据一个阈值来判断大于该阈值对象直接分配到老年代，这样可以避免在新生代频繁的发生 GC。</p>
<p>对于一些在新生代的老对象 JVM 也会根据某种机制移动到老年代中。</p>
<p>JVM 是根据记录对象年龄的方式来判断该对象是否应该移动到老年代，根据新生代的复制算法，当一个对象被移动到 Survivor 区之后 JVM 就给该对象的年龄记为1，每当熬过一次 minorGC 后对象的年龄就 +1 ，直到达到阈值(默认为15)就移动到老年代中。</p>
<p>可以使用<code>-XX:MaxTenuringThreshold=15</code> 来配置这个阈值。</p>
<p>###总结</p>
<p>虽说这些内容略显枯燥，但当应用发生不正常的 GC 时，可以方便更快的定位问题。</p>
<h1 id="6-volatile-关键字"><a href="#6-volatile-关键字" class="headerlink" title="6. volatile 关键字"></a>6. volatile 关键字</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不管是在面试还是实际开发中     <code>volatile</code>都是一个应该掌握的技能。</p>
<p>首先来看看为什么会出现这个关键字。</p>
<h2 id="6-1-内存可见性"><a href="#6-1-内存可见性" class="headerlink" title="6.1 内存可见性"></a>6.1 内存可见性</h2><hr>
<p>由于 Java 内存模型<code>(JMM)</code>规定，所有的变量都存放在主内存中，而每个线程都有着自己的工作内存(高速缓存)。</p>
<p>线程在工作时，需要将主内存中的数据拷贝到工作内存中。这样对数据的任何操作都是基于工作内存(效率提高)，并且不能直接操作主内存以及其他线程工作内存中的数据，之后再将更新之后的数据刷新到主内存中。</p>
<p>这里所提到的主内存可以简单认为是<code>堆内存</code>，而工作内存则可以认为是<code>栈内存</code>。<br>如下图所示：<br><img src="https://img-blog.csdn.net/20180719091249178?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1bm1veGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p>所以在并发运行时可能会出现线程 B 所读取到的数据是线程 A 更新之前的数据。</p>
<p>显然这肯定是会出问题的，因此 <strong>volatile 的作用出现了</strong>：</p>
<blockquote>
<p>当一个变量被 volatile 修饰时，任何线程对它的写操作都会立即刷新到主内存中，并且会强制让缓存了该变量的线程中的数据清空，必须从主内存重新读取最新数据。</p>
</blockquote>
<p>volatile 修饰之后并不是让线程直接从主内存中获取数据，依然需要将变量拷贝到工作内存中。</p>
<p><strong>内存可见性的应用</strong></p>
<p>当我们需要在两个线程间依据主内存通信时，通信的那个变量就必须的用 volatile 来修饰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volatile</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"正在运行。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">"执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Volatile aVolatile = <span class="keyword">new</span> Volatile();</span><br><span class="line">        <span class="keyword">new</span> Thread(aVolatile,<span class="string">"thread A"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main 线程正在运行"</span>) ;</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>) ;</span><br><span class="line"></span><br><span class="line">        aVolatile.stopThread();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        flag = <span class="keyword">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程在修改了标志位使得线程 A 立即停止，如果没有用 volatile 修饰，就有可能出现延迟。</p>
<p>但这里有个误区，这样的使用方式容易给人的感觉是：</p>
<p>对 volatile 修饰的变量进行并发操作是线程安全的。<br>这里要重点强调，volatile 并不能保证线程安全性（不能保证其原子性）！</p>
<p>如下程序:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileInc</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span> ; <span class="comment">//使用 volatile 修饰基本数据内存不能保证原子性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//private static AtomicInteger count = new AtomicInteger() ;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span> ;i++)&#123;</span><br><span class="line">            count ++ ;</span><br><span class="line">            <span class="comment">//count.incrementAndGet() ;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        VolatileInc volatileInc = <span class="keyword">new</span> VolatileInc() ;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(volatileInc,<span class="string">"t1"</span>) ;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(volatileInc,<span class="string">"t2"</span>) ;</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//t1.join();</span></span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//t2.join();</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span> ;i++)&#123;</span><br><span class="line">            count ++ ;</span><br><span class="line">            <span class="comment">//count.incrementAndGet();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"最终Count="</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们三个线程(t1,t2,main)同时对一个 int 进行累加时会发现最终的值都会小于 30000。</p>
<blockquote>
<p>这是因为虽然 volatile 保证了内存可见性，每个线程拿到的值都是最新值，但 count ++ 这个操作并不是原子的，这里面涉及到获取值、自增、赋值的操作并不能同时完成。<br>所以想到达到线程安全可以使这三个线程串行执行(其实就是单线程，没有发挥多线程的优势)。</p>
</blockquote>
<p>也可以使用 synchronize 或者是锁的方式来保证原子性。</p>
<p>还可以用 Atomic 包中 AtomicInteger 来替换 int，它利用了 CAS 算法来保证了原子性。</p>
<h2 id="6-2-指令重排"><a href="#6-2-指令重排" class="headerlink" title="6.2 指令重排"></a>6.2 指令重排</h2><p>内存可见性只是 volatile 的其中一个语义，它还可以防止 JVM 进行指令重排优化。</p>
<p>举一个伪代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span> ;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> b=<span class="number">20</span> ;<span class="comment">//2</span></span><br><span class="line"><span class="keyword">int</span> c= a+b ;<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>一段特别简单的代码，理想情况下它的执行顺序是：1&gt;2&gt;3。但有可能经过 JVM 优化之后的执行顺序变为了 2&gt;1&gt;3。</p>
<blockquote>
<p>如果下一段的语句没有使用上一段语句的结果，JVM就认为两句语句是没有关联的就可能进行重排，JVM不会保证代码的执行顺序，但会保证最终的结果都是一样的</p>
</blockquote>
<p>可以发现不管 JVM 怎么优化，前提都是保证单线程中最终结果不变的情况下进行的。</p>
<p>可能这里还看不出有什么问题，那看下一段伪代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,String&gt; value ;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = fasle ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下方法发生在线程 A 中 初始化 Map</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//耗时操作</span></span><br><span class="line">	value = getMapValue() ;<span class="comment">//1</span></span><br><span class="line">	flag = <span class="keyword">true</span> ;<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发生在线程 B中 等到 Map 初始化成功进行其他操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">		sleep() ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//dosomething</span></span><br><span class="line">	doSomeThing(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就能看出问题了，当 flag 没有被 volatile 修饰时，JVM 对 1 和 2 进行重排，导致 value 都还没有被初始化就有可能被线程 B 使用了。</p>
<p>所以加上 volatile 之后可以防止这样的重排优化，保证业务的正确性。</p>
<p>指令重排的的应用</p>
<p>一个经典的使用场景就是双重懒加载的单例模式了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//防止指令重排</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 volatile 关键字主要是为了防止指令重排。</p>
<p>如果不用 ，singleton = new Singleton();，这段代码其实是分为三步：</p>
<ul>
<li>分配内存空间。(1)</li>
<li>初始化对象。(2)</li>
<li>将 singleton 对象指向分配的内存地址。(3)</li>
</ul>
<p>加上 volatile 是为了让以上的三步操作顺序执行，反之有可能第二步在第三步之前被执行就有可能某个线程拿到的单例对象是还没有初始化的，以致于报错。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>volatile 在 Java 并发中用的很多，比如像<code>Atomic</code>包中的 <code>value</code>、以及 <code>AbstractQueuedLongSynchronizer</code>中的 <code>state</code>都是被定义为 volatile 来用于保证内存可见性。</p>
<p>将这块理解透彻对我们编写并发程序时可以提供很大帮助。</p>

      
    </div>
    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      
    </div>

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JVM/" rel="tag"><i class="fa fa-tag"></i> JVM</a>
          
            <a href="/tags/类加载/" rel="tag"><i class="fa fa-tag"></i> 类加载</a>
          
            <a href="/tags/垃圾回收/" rel="tag"><i class="fa fa-tag"></i> 垃圾回收</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/21/QQ每天定时领取群礼物/" rel="next" title="QQ每天定时领取群礼物">
                <i class="fa fa-chevron-left"></i> QQ每天定时领取群礼物
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/23/使用GitHub创建个人官网/" rel="prev" title="使用GitHub创建个人官网">
                使用GitHub创建个人官网 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/qq.png" alt="派大星">
            
              <p class="site-author-name" itemprop="name">派大星</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">137</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">64</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">230</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/pibigstar" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/junmoxi" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-yelp"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Java-运行时的内存划分"><span class="nav-number">1.</span> <span class="nav-text">1. Java 运行时的内存划分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-程序计数器"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 程序计数器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-虚拟机栈"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 虚拟机栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Java-堆"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 Java 堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-方法区"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 方法区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-运行时常量池"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 运行时常量池</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-类的加载机制"><span class="nav-number">2.</span> <span class="nav-text">2. 类的加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-双亲委派模型"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 双亲委派模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-垃圾回收"><span class="nav-number">3.</span> <span class="nav-text">3. 垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-对象是否存活"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 对象是否存活</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-垃圾回收算法"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 垃圾回收算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-OOM-分析"><span class="nav-number">4.</span> <span class="nav-text">4. OOM 分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-Java-堆内存溢出"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 Java 堆内存溢出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-MetaSpace-元数据-内存溢出"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 MetaSpace (元数据) 内存溢出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-对象的创建与内存分配"><span class="nav-number">5.</span> <span class="nav-text">5. 对象的创建与内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-创建对象"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 创建对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象访问"><span class="nav-number">5.1.0.1.</span> <span class="nav-text">对象访问</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-内存分配"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#老年代分配"><span class="nav-number">5.2.0.1.</span> <span class="nav-text">老年代分配</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#6-volatile-关键字"><span class="nav-number">6.</span> <span class="nav-text">6. volatile 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">6.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-内存可见性"><span class="nav-number">6.2.</span> <span class="nav-text">6.1 内存可见性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-指令重排"><span class="nav-number">6.3.</span> <span class="nav-text">6.2 指令重排</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">6.3.1.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">派大星</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>








        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

</body>
</html>
<!-- 页面点击小红心 -->
 <script type="text/javascript" src="/js/src/clicklove.js"></script>
